var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var auth_exports = {};
__export(auth_exports, {
  default: () => Auth
});
module.exports = __toCommonJS(auth_exports);
var import_errors = require("../errors.js");
var import_types = require("../types/types.js");
var import_oauthUtils = require("../utils/oauthUtils.js");
var import_utils = require("../utils/utils.js");
var import_restClient = __toESM(require("./restClient.js"));
var import_rpcClient = __toESM(require("./rpcClient.js"));
const OnlyWebIntegrationError = new import_errors.CustomError(
  "Only supported for AuthType.WebIntegration"
);
class Auth {
  constructor(config) {
    if (!config.host) {
      throw new import_errors.CustomError("Empty host in config");
    }
    let host;
    let isSecure;
    let getUrlError;
    try {
      const tenantUrl = (0, import_utils.getUrl)(config.host, config.isSecure);
      host = tenantUrl.host;
      isSecure = tenantUrl.protocol === "https:";
    } catch (error) {
      getUrlError = error;
    }
    if (getUrlError) {
      throw new import_errors.CustomError("Invalid host in config");
    }
    if (config.isSecure !== void 0 && config.isSecure !== isSecure) {
      throw new import_errors.CustomError("Ambiguous config, mismatch for host and isSecure");
    }
    this.config = {
      ...config,
      host,
      isSecure
    };
    if (this.config.authType === import_types.AuthType.WebIntegration && !("autoRedirect" in this.config)) {
      this.config.autoRedirect = false;
    }
    if (this.config.authType === import_types.AuthType.OAuth2) {
      this.config.scopes = [
        "user_default",
        ...(this.config?.scopes ?? []).filter((v) => v !== "user_default")
      ];
    }
    (0, import_utils.validateConfig)(this.config);
    const restClient = new import_restClient.default(this.config);
    this.rpcClient = new import_rpcClient.default(this.config);
    this.rpc = (appId, rpcConfig = { delta: true }) => this.rpcClient.rpc(appId, rpcConfig);
    Object.assign(this.rpc, { interceptors: this.rpcClient.interceptors });
    this.rest = restClient.restClientInstance;
    this.generateWebsocketUrl = (appId, appendAccessToken) => (0, import_utils.generateWebsocketUrl)(appId, this.rest, this.config, appendAccessToken);
    if (this.config.autoRedirect) {
      this.isAuthenticated().then((loggedIn) => {
        if (!loggedIn) {
          this.authenticate();
        }
      });
    }
  }
  /**
   * Get access
   * For WebIntegration:
   * Navigates to the login page and redirects back to the current page after login
   */
  authenticate() {
    if (this.config.authType !== import_types.AuthType.WebIntegration) {
      throw OnlyWebIntegrationError;
    }
    const loginUrl = (0, import_utils.getUrl)(`${this.config.host}/login`, this.config.isSecure);
    loginUrl.searchParams.append("returnto", window.location.href);
    loginUrl.searchParams.append(
      "qlik-web-integration-id",
      this.config.webIntegrationId
    );
    window.location.assign(loginUrl.href);
  }
  /**
   * checks authentication status using the "/users/me" endpoint
   */
  async isAuthenticated() {
    return this.rest("/users/me").then((res) => res.status === 200).catch(() => false);
  }
  /**
   * checks authorization status using the "/users/me" endpoint
   */
  async isAuthorized() {
    return this.isAuthenticated();
  }
  /**
   * invalidate the current session
   */
  deauthenticate() {
    if (this.config.authType !== import_types.AuthType.WebIntegration) {
      throw OnlyWebIntegrationError;
    }
    const logoutUrl = (0, import_utils.getUrl)(`${this.config.host}/logout`, this.config.isSecure);
    logoutUrl.searchParams.append("returnto", window.location.href);
    window.location.assign(logoutUrl.href);
  }
  /**
   * getSessionCookie - For JWTAuth:
   * function helper for getting the session cookies.
   */
  async getSessionCookie() {
    const signedToken = await this.config.fetchToken();
    const resp = await this.rest.fetch(
      (0, import_utils.getUrl)(`${this.config.host}/login/jwt-session`, this.config?.isSecure).toString(),
      {
        method: "POST",
        credentials: "include",
        mode: "cors",
        headers: {
          "content-type": "application/json",
          Authorization: `Bearer ${signedToken}`,
          "qlik-web-integration-id": this.config.webIntegrationId
        }
      }
    );
    if (resp.status !== 200) {
      throw new import_errors.AuthenticationError(import_errors.AuthenticationErrorMsg.UNAUTHENTICATED);
    }
    return resp;
  }
  /**
   * exchange credentials with token against the authorization server
   * @param url - The callback url with query parameters
   */
  async authorize(url) {
    const urlParams = url ? Object.fromEntries(new URL(url).searchParams.entries()) : {};
    const code = urlParams?.code;
    const state = urlParams?.state;
    const error = urlParams?.error;
    if (error) {
      throw new import_errors.CustomError({
        error,
        error_code: urlParams?.error_code,
        error_description: urlParams?.error_description,
        error_detail: urlParams?.error_detail,
        error_uri: urlParams?.error_uri
      });
    }
    if (import_utils.isBrowser) {
      this.state = localStorage.getItem(`${this.config.clientId}_state`) ?? "";
      this.verifier = localStorage.getItem(`${this.config.clientId}_verifier`) ?? "";
      localStorage.removeItem(`${this.config.clientId}_state`);
      localStorage.removeItem(`${this.config.clientId}_verifier`);
    }
    if (this.state && state !== this.state) {
      throw new Error("The received state parameter does not match the original state value");
    }
    const body = JSON.stringify({
      grant_type: code ? "authorization_code" : "client_credentials",
      scope: this.config.scopes.join(" "),
      ...code ? { code } : {},
      ...this.config.redirectUri ? { redirect_uri: this.config.redirectUri } : {},
      ...this.verifier ? { code_verifier: this.verifier } : {},
      client_id: this.config.clientId
    });
    const response = await this.rest("/oauth/token", { method: "POST", body });
    const responseJson = await response.json();
    this.config.apiKey = responseJson.access_token;
    this.config.refreshToken = responseJson?.refresh_token;
    return responseJson;
  }
  /**
   * deauthorize
   * revokes the Auth instance oauth token
   */
  async deauthorize() {
    await this.rest(
      "/oauth/revoke",
      {
        method: "POST",
        body: JSON.stringify({
          token: this.config.apiKey,
          token_type_hint: "access_token"
        })
      }
    );
    this.config.apiKey = "";
  }
  /**
   * refreshToken
   * method helper for refreshing the token
   */
  async refreshToken() {
    if (this.config.authType !== import_types.AuthType.OAuth2 || !this.config.scopes.includes("offline_access") || !this.config.refreshToken) {
      throw new import_errors.CustomError(
        "Method only available for AuthType OAuth2, that have offline_access scope"
      );
    }
    const response = await this.rest(
      "/oauth/token",
      {
        method: "POST",
        body: JSON.stringify({
          grant_type: "refresh_token",
          refresh_token: this.config.refreshToken
        })
      }
    ).then((resp) => resp.json());
    this.config.apiKey = response.access_token;
    this.config.refreshToken = response.refresh_token;
    return response;
  }
  /**
   * generateAuthorizationUrl
   * @param state - for validating against potential CSRF attacks,
   * will generate and use a random string if not set
   */
  async generateAuthorizationUrl(state) {
    const { url, verifier, state: usedState } = await (0, import_oauthUtils.generateAuthorizationUrl)(this.config, state);
    this.verifier = verifier;
    this.state = usedState;
    if (import_utils.isBrowser) {
      localStorage.setItem(`${this.config.clientId}_state`, this.state);
      localStorage.setItem(`${this.config.clientId}_verifier`, this.verifier);
    }
    return { url, verifier, state: usedState };
  }
}

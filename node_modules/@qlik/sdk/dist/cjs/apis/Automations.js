var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Automations_exports = {};
__export(Automations_exports, {
  AutomationDetailResponseObject: () => AutomationDetailResponseObject,
  Automations: () => Automations
});
module.exports = __toCommonJS(Automations_exports);
var import_auth = __toESM(require("../auth/auth.js"));
var import_listable = __toESM(require("../listable.js"));
class AutomationDetailResponseObject {
  constructor({
    connectorIds,
    createdAt,
    description,
    endpointIds,
    executionToken,
    id,
    lastRun,
    lastRunAt,
    lastRunStatus,
    name,
    ownerId,
    runMode,
    schedules,
    snippetIds,
    state = "available",
    updatedAt,
    workspace,
    ...rest
  }, auth) {
    this.auth = auth;
    this.connectorIds = connectorIds;
    this.createdAt = createdAt;
    this.description = description;
    this.endpointIds = endpointIds;
    this.executionToken = executionToken;
    this.id = id;
    if (lastRun !== void 0 && lastRun !== null) {
      this.lastRun = lastRun;
    }
    this.lastRunAt = lastRunAt;
    this.lastRunStatus = lastRunStatus;
    this.name = name;
    this.ownerId = ownerId;
    this.runMode = runMode;
    if (schedules !== void 0 && schedules !== null) {
      this.schedules = schedules;
    }
    this.snippetIds = snippetIds;
    this.state = state;
    this.updatedAt = updatedAt;
    this.workspace = workspace;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
  /**
    Copy an automation.
  
      @param name - Name of the new automation.
    */
  async copy(name) {
    const response = await this.auth.rest(
      "/automations/{id}/actions/copy".replace("{id}", this.id ?? ""),
      {
        method: "POST",
        body: JSON.stringify({ name })
      }
    );
    return response.json();
  }
  /**
    Disables an automation.
  
    */
  async disable() {
    await this.auth.rest(
      "/automations/{id}/actions/disable".replace("{id}", this.id ?? ""),
      {
        method: "POST"
      }
    );
  }
  /**
    Enable an automation.
  
    */
  async enable() {
    await this.auth.rest(
      "/automations/{id}/actions/enable".replace("{id}", this.id ?? ""),
      {
        method: "POST"
      }
    );
  }
  /**    This step will remove the history and change logs of this automation. All linked connections used inside an automation will be detached.
    Move an automation to a different user.
  
      @param ownerId -
    */
  async move(ownerId) {
    await this.auth.rest(
      "/automations/{id}/actions/move".replace("{id}", this.id ?? ""),
      {
        method: "POST",
        body: JSON.stringify({ ownerId })
      }
    );
  }
  /**    Creates a temporary pre-signed AWS S3 URL to download the raw logs of a completed run. This URL is valid for 5 minutes.
    Export a run.
  
      @param runId - The unique identifier for the run.
    */
  async export(runId) {
    const response = await this.auth.rest(
      "/automations/{id}/runs/{runId}/actions/export".replace("{id}", this.id ?? "").replace("{runId}", runId),
      {
        method: "POST"
      }
    );
    return response.json();
  }
  /**    This action allows you to retry a specific run by creating a new run using the same inputs.
    Retry a run.
  
      @param runId - The unique identifier for the run.
    */
  async retry(runId) {
    await this.auth.rest(
      "/automations/{id}/runs/{runId}/actions/retry".replace("{id}", this.id ?? "").replace("{runId}", runId),
      {
        method: "POST"
      }
    );
  }
  /**    Force a run to be stopped immediately.
    Stop a running automation.
  
      @param runId - The unique identifier for the run.
    */
  async stop(runId) {
    await this.auth.rest(
      "/automations/{id}/runs/{runId}/actions/stop".replace("{id}", this.id ?? "").replace("{runId}", runId),
      {
        method: "POST"
      }
    );
  }
  /**
    Retrieves a run
  
      @param runId - The unique identifier for the run.
    */
  async getRun(runId) {
    const response = await this.auth.rest(
      "/automations/{id}/runs/{runId}".replace("{id}", this.id ?? "").replace("{runId}", runId),
      {
        method: "GET"
      }
    );
    return response.json();
  }
  /**
    Retrieves a list of runs for a specific automation.
  
      @param filter - Allowed filters: status, context, startTime and title
      @param limit - The number of runs to retrieve.
      @param sort - The field to sort by, with +- prefix indicating sort order. (?query=-startTime => sort on the startTime field using descending order)
    */
  async getRuns(queryParams = { limit: 10, sort: "id" }) {
    const response = await this.auth.rest(
      `${"/automations/{id}/runs".replace("{id}", this.id ?? "")}?${new URLSearchParams(Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => [k, v.toString()])).toString()}`,
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new import_listable.default(responseJson, this.auth, null, queryParams);
  }
  /**
    Create a run
  
      @param data - Run object to create
    */
  async createRun(data) {
    const response = await this.auth.rest(
      "/automations/{id}/runs".replace("{id}", this.id ?? ""),
      {
        method: "POST",
        body: JSON.stringify(data)
      }
    );
    return response.json();
  }
  /**
    Delete an automation
  
    */
  async delete() {
    await this.auth.rest(
      "/automations/{id}".replace("{id}", this.id ?? ""),
      {
        method: "DELETE"
      }
    );
  }
  /**
    Update an automation
  
      @param data - Automation object to update
    */
  async set(data) {
    const response = await this.auth.rest(
      "/automations/{id}".replace("{id}", this.id ?? ""),
      {
        method: "PUT",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    Object.keys(responseJson).forEach((key) => {
      if (this[key]) {
        this[key] = responseJson[key];
      }
    });
    return this;
  }
}
class Automations {
  constructor(config) {
    this.config = config instanceof import_auth.default ? config.config : config;
    this.auth = config instanceof import_auth.default ? config : new import_auth.default(config);
  }
  /**
    Retrieves the automation settings.
  
    */
  async getSettings() {
    const response = await this.auth.rest(
      "/automations/settings",
      {
        method: "GET"
      }
    );
    return response.json();
  }
  /**
    Update the automation settings.
  
      @param data -
    */
  async setSettings(data) {
    const response = await this.auth.rest(
      "/automations/settings",
      {
        method: "PUT",
        body: JSON.stringify(data)
      }
    );
    return response.json();
  }
  /**    Limitations:
   * Maximum 1000 metrics per API call
    Retrieves all automation usage for a tenant
  
      @param filter - Indicates how the metrics should be filtered
      @param breakdownBy - If specified, result will be broken apart for each automation
    */
  async getUsages(queryParams) {
    const response = await this.auth.rest(
      `/automations/usage?${new URLSearchParams(Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => [k, v.toString()])).toString()}`,
      {
        method: "GET"
      }
    );
    return response.json();
  }
  /**
    Retrieves an automation
  
      @param id - The unique identifier for the automation.
    */
  async get(id) {
    const response = await this.auth.rest(
      "/automations/{id}".replace("{id}", id),
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new AutomationDetailResponseObject(responseJson, this.auth);
  }
  /**
    Retrieves a list of automations
  
      @param filter - Allowed filters: name, runMode, lastRunStatus, ownerId
      @param limit - The number of automations to retrieve.
      @param sort - The field to sort by, with +- prefix indicating sort order. (?query=-name => sort on the name field using descending order)
    */
  async getAutomations(queryParams = { limit: 100, sort: "id" }) {
    const response = await this.auth.rest(
      `/automations?${new URLSearchParams(Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => [k, v.toString()])).toString()}`,
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new import_listable.default(responseJson, this.auth, null, queryParams);
  }
  /**
    Create an automation
  
      @param data - Automation object to create
    */
  async create(data) {
    const response = await this.auth.rest(
      "/automations",
      {
        method: "POST",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    return new AutomationDetailResponseObject(responseJson, this.auth);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AutomationDetailResponseObject,
  Automations
});

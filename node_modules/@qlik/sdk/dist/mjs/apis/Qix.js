import { GenericError } from "../errors.js";
class Doc {
  constructor({
    qGenericId,
    qGenericType,
    qHandle,
    qType,
    ...rest
  }, session, auth) {
    this.auth = auth;
    this.session = session;
    this.qGenericId = qGenericId;
    this.qGenericType = qGenericType;
    this.qHandle = qHandle;
    this.qType = qType;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
  /**    Returns a handle to a field.
  
      @param qFieldName - Name of the field.
      @param qStateName - Name of the alternate state.
  Default state is current selections.
    */
  async getField(qFieldName, qStateName) {
    const params = {};
    params.qFieldName = qFieldName;
    if (qStateName !== void 0) {
      params.qStateName = qStateName;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetField",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new Field(response, this.session, this.auth);
    return obj;
  }
  /**    Returns the description of a field.
  
      @param qFieldName - Name of the field.
    */
  async getFieldDescription(qFieldName) {
    const params = {};
    params.qFieldName = qFieldName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetFieldDescription",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qReturn"];
  }
  /**    Returns a handle to a variable.
    @deprecated
    @param qName - Name of the variable.
  */
  async getVariable(qName) {
    const params = {};
    params.qName = qName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetVariable",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericVariable(response, this.session, this.auth);
    return obj;
  }
  /**    Returns a list of table states.
  
  The following states apply:
  
  • 0 The table is not loosely coupled.
  
  • 1 The table is loosely coupled.
  
  • 2 The table is loosely coupled and cannot be changed to another state using the Qlik Engine API.
  
  The last three values in the vector are for internal use.
  In case of circular references, the engine automatically sets the table state to loosely coupled to avoid creating loops.
  
    */
  async getLooselyCoupledVector() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetLooselyCoupledVector",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qv"];
    return response;
  }
  /**    Sets a list of table states, one for each table.
  
  The following states apply:
  
  • 0 The table is not loosely coupled.
  
  • 1 The table is loosely coupled.
  
  • 2 The table is loosely coupled and cannot be changed to another state using the Qlik Engine API.
  
  The last three values in the vector are for internal use.
  
      @param qv - The list of table states to set. A state will not be changed if already set to 2.
    */
  async setLooselyCoupledVector(qv) {
    const params = {};
    params.qv = qv;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetLooselyCoupledVector",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Evaluates an expression and returns the result as a string.
  
   Example:
  The client sends:
  ```
  {
      "handle": 1,
      "method": "Evaluate",
      "params": {
          "qExpression": "Sum(Holes)"
      },
      "id": 6,
      "jsonrpc": "2.0"
  }
  ```
  The engine returns:
  ```
  {
      "jsonrpc": "2.0",
      "id": 6,
      "result": {
          "qReturn": "361716"
      }
  }
  ```
  
      @param qExpression - Expression to evaluate.
    */
  async evaluate(qExpression) {
    const params = {};
    params.qExpression = qExpression;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Evaluate",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Evaluates an expression and returns the result as a dual.
  
   Example:
  The client sends:
  ```
  {
      "handle": 1,
      "method": "EvaluateEx",
      "params": {
          "qExpression": "Sum(Holes)"
      },
      "id": 7,
      "jsonrpc": "2.0"
  }
  ```
  The engine returns:
  ```
  {
      "jsonrpc": "2.0",
      "id": 7,
      "result": {
          "qReturn": "361716"
      }
  }
  ```
  
      @param qExpression - Expression to evaluate.
    */
  async evaluateEx(qExpression) {
    const params = {};
    params.qExpression = qExpression;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "EvaluateEx",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qValue"];
  }
  /**    Clear selections in fields for current state. Locked fields are not cleared by default.
  
      @param qLockedAlso - When true, clears the selection for locked fields.
      @param qStateName - Alternate state name. When set, applies to alternate state instead of current
    */
  async clearAll(qLockedAlso, qStateName) {
    const params = {};
    if (qLockedAlso !== void 0) {
      params.qLockedAlso = qLockedAlso;
    }
    if (qStateName !== void 0) {
      params.qStateName = qStateName;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ClearAll",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Locks all selections in fields for current state.
  
      @param qStateName - Alternate state name. When set, applies to alternate state instead of current.
    */
  async lockAll(qStateName) {
    const params = {};
    if (qStateName !== void 0) {
      params.qStateName = qStateName;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "LockAll",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Unlocks all selections in fields for current state.
  
      @param qStateName - Alternate state name. When set, applies to alternate state instead of current.
    */
  async unlockAll(qStateName) {
    const params = {};
    if (qStateName !== void 0) {
      params.qStateName = qStateName;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "UnlockAll",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Loads the last logical operation (if any).
  
    */
  async back() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Back",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Loads the next logical operation (if any).
  
    */
  async forward() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Forward",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Creates a variable.
    @deprecated
    @param qName - Name of the variable. Variable names are case sensitive.
  */
  async createVariable(qName) {
    const params = {};
    params.qName = qName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateVariable",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Removes a variable.
    @deprecated
    @param qName - Name of the variable. Variable names are case sensitive.
  */
  async removeVariable(qName) {
    const params = {};
    params.qName = qName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "RemoveVariable",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Returns locale information.
  
    */
  async getLocaleInfo() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetLocaleInfo",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qReturn"];
  }
  /**    Returns:
  
  • The list of tables in an app and the fields inside each table.
  
  • The list of derived fields.
  
  • The list of key fields.
  
      @param qWindowSize - Size of the window that is used to display the results.
      @param qNullSize -
      @param qCellHeight - Height of a cell in a table in pixels.
      @param qSyntheticMode - One of:
  
  • true for internal table viewer:
  Shows a more detailed view on how the Qlik engine defines the relations between fields and the quality of the keys.
  
  • false for source table viewer:
  Shows the natural relation between fields without reference to synthetic keys and resultant linking synthetic tables. Instead synthetic keys are represented by multiple connectors between tables.
      @param qIncludeSysVars - If set to true, the system variables are included.
      @param qIncludeProfiling - If set to true, profiling information is included.
    */
  async getTablesAndKeys(qWindowSize, qNullSize, qCellHeight, qSyntheticMode, qIncludeSysVars, qIncludeProfiling) {
    const params = {};
    params.qWindowSize = qWindowSize;
    params.qNullSize = qNullSize;
    params.qCellHeight = qCellHeight;
    params.qSyntheticMode = qSyntheticMode;
    params.qIncludeSysVars = qIncludeSysVars;
    if (qIncludeProfiling !== void 0) {
      params.qIncludeProfiling = qIncludeProfiling;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetTablesAndKeys",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"];
  }
  /**    Returns information about the position of the tables in the data model viewer.
  The position of the broom points and the position of the connection points cannot be retrieved in Qlik Sense.
  
   Representation of tables, broom points and connection points:
  
  The green circles represent the broom points.
  The red circle represents a connection point.
  
    */
  async getViewDlgSaveInfo() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetViewDlgSaveInfo",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qReturn"];
  }
  /**    Sets the positions of the tables in the data model viewer.
  The position of the broom points and the position of the connection points cannot be set in Qlik Sense.
  
   Representation of tables, broom points and connection points:
  
  The green circles represent the broom points.
  The red circle represents a connection point.
  
      @param qInfo - Information about the table.
    */
  async setViewDlgSaveInfo({ qCtlInfo: { qInternalView: { qZoomFactor = 1, ...restQCtlInfoQInternalView } = { qZoomFactor: 1 }, qSourceView: { qZoomFactor: qZoomFactor2 = 1, ...restQCtlInfoQSourceView } = { qZoomFactor: 1 }, ...restQCtlInfo } = { qInternalView: { qZoomFactor: 1 }, qSourceView: { qZoomFactor: 1 } }, ...rest } = {}) {
    const params = {};
    params.qInfo = { qCtlInfo: { qInternalView: { qZoomFactor, ...restQCtlInfoQInternalView }, qSourceView: { qZoomFactor: qZoomFactor2, ...restQCtlInfoQSourceView }, ...restQCtlInfo }, ...rest };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetViewDlgSaveInfo",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Creates a script that contains one section. This section contains SET statements that give localized information from the regional settings of the computer.
  The computer regional settings are retrieved when the engine starts.
  
      @param qLocalizedMainSection - Name of the script section.
  The default value is Main .
    */
  async getEmptyScript(qLocalizedMainSection) {
    const params = {};
    if (qLocalizedMainSection !== void 0) {
      params.qLocalizedMainSection = qLocalizedMainSection;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetEmptyScript",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Reloads the script that is set in an app.
  
   Logs:
  When this method is called, audit activity logs are produced to track the user activity.
  In the case of errors, both audit activity logs and system services logs are produced.
  The log files are named as follows:
  | Audit activity log                                                                                                                        | System service log                                                                                                            |
  |-------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|
  | _\_AuditActivity\_Engine.txt_ in Qlik Sense Enterprise  _\_AuditActivity\_Engine.log_ in Qlik Sense Desktop | _\_Service\_Engine.txt_ in Qlik Sense Enterprise  _\_Service\_Engine.log_ in Qlik Sense Desktop |
  
   Where to find the log files:
  The location of the log files depends on whether you have installed Qlik Sense Enterprise or Qlik Sense Desktop.
  | Qlik Sense Enterprise                 | Qlik Sense Desktop                       |
  |---------------------------------------|------------------------------------------|
  | _%ProgramData%/Qlik/Sense/Log/Engine_ | _%UserProfile%/Documents/Qlik/Sense/Log_ |
  
      @param qMode - Error handling mode
  One of:
  
  • 0: for default mode.
  
  • 1: for ABEND; the reload of the script ends if an error occurs.
  
  • 2: for ignore; the reload of the script continues even if an error is detected in the script.
      @param qPartial - Set to true for partial reload.
  The default value is false.
      @param qDebug - Set to true if debug breakpoints are to be honored. The execution of the script will be in debug mode.
  The default value is false.
    */
  async doReload(qMode, qPartial, qDebug) {
    const params = {};
    if (qMode !== void 0) {
      params.qMode = qMode;
    }
    if (qPartial !== void 0) {
      params.qPartial = qPartial;
    }
    if (qDebug !== void 0) {
      params.qDebug = qDebug;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DoReload",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Lists the breakpoints in the script of an app.
  
    */
  async getScriptBreakpoints() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetScriptBreakpoints",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qBreakpoints"];
    return response.map((r) => r);
  }
  /**    Set some breakpoints in the script of an app.
  
      @param qBreakpoints - Information about the breakpoints.
    */
  async setScriptBreakpoints(qBreakpoints) {
    const params = {};
    params.qBreakpoints = qBreakpoints;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetScriptBreakpoints",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Gets values in script.
  
    */
  async getScript() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetScript",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qScript"];
    return response;
  }
  /**    Fetches updated variables after a statement execution.
  
  If qRefSeqNo and qSetSeqNo are set to 0, it means that the variables were not updated.
  
    */
  async getTextMacros() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetTextMacros",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qMacros"];
    return response.map((r) => r);
  }
  /**    Limits the number of rows of data to load from a data source.
  This method works when reloading in debug mode.
  
      @param qLimit - Fetch limit.
  Number of rows to load.
    */
  async setFetchLimit(qLimit) {
    const params = {};
    params.qLimit = qLimit;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetFetchLimit",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Saves an app. All objects and data in the data model are saved.
  
      @param qFileName - Name of the file to save.
    */
  async doSave(qFileName) {
    const params = {};
    if (qFileName !== void 0) {
      params.qFileName = qFileName;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DoSave",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Retrieves the data of a specific table.
  
      @param qOffset - Position from the top, starting from 0.
  If the offset is set to 0, the rows starting from the position/index 0 are shown.
      @param qRows - Number of rows to show.
      @param qSyntheticMode - If this parameter is set to true, the internal data/table representation is shown. Synthetic fields are present (if any).
      @param qTableName - Name of the table.
    */
  async getTableData(qOffset, qRows, qSyntheticMode, qTableName) {
    const params = {};
    params.qOffset = qOffset;
    params.qRows = qRows;
    params.qSyntheticMode = qSyntheticMode;
    params.qTableName = qTableName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetTableData",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qData"];
    return response.map((r) => r);
  }
  /**    Evaluates an app.
  Returns dynamic properties (if any) in addition to the engine (fixed) properties.
  A data set is returned.
  
    */
  async getAppLayout() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetAppLayout",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qLayout"];
  }
  /**    Sets properties to an app.
  The qLastReloadTime, qMigrationHash and qSavedInProductVersion properties does not need to be set but if they are, they should match the current values in the app layout.
  
      @param qProp - Information about the properties of an app.
    */
  async setAppProperties({
    chartAnimations = true,
    qStateName = "$",
    theme = "horizon",
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      chartAnimations,
      qStateName,
      theme,
      ...rest
    };
    params.qProp.qInfo = { qType: "appprops" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetAppProperties",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Gets the properties of an app.
  
    */
  async getAppProperties() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetAppProperties",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qProp"];
  }
  /**    Gets the lineage information of the app. The lineage information includes the LOAD and STORE statements from the data load script associated with this app.
  An array of lineage information.
  
    */
  async getLineage() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetLineage",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qLineage"];
    return response.map((r) => r);
  }
  /**    Creates a transient object. For example, you can use a transient object to create an app overview or a story overview.
  It is possible to create a transient object that is linked to another object.
  A linked object is an object that points to a linking object. The linking object is defined in the properties of the linked object (in qExtendsId ).
  The linked object has the same properties as the linking object.
  The linking object cannot be a transient object.
  
      @param qProp - Information about the object.
    */
  async createSessionObject({
    qBookmarkListDef: { qType = "bookmark", ...restQBookmarkListDef } = { qType: "bookmark" },
    qHyperCubeDef: {
      qMaxStackedCells = 5e3,
      qMode = "DATA_MODE_STRAIGHT",
      qNoOfLeftDims = -1,
      qPseudoDimPos = -1,
      ...restQHyperCubeDef
    } = {
      qMaxStackedCells: 5e3,
      qMode: "DATA_MODE_STRAIGHT",
      qNoOfLeftDims: -1,
      qPseudoDimPos: -1
    },
    qListObjectDef: { qFrequencyMode = "NX_FREQUENCY_NONE", ...restQListObjectDef } = { qFrequencyMode: "NX_FREQUENCY_NONE" },
    qNxLibraryDimensionDef: { coloring: { baseColor: { index = 6, ...restQNxLibraryDimensionDefColoringBaseColor } = { index: 6 }, ...restQNxLibraryDimensionDefColoring } = { baseColor: { index: 6 } }, ...restQNxLibraryDimensionDef } = { coloring: { baseColor: { index: 6 } } },
    qNxLibraryMeasureDef: { qNumFormat: { qType: qType2 = "UNKNOWN", qnDec = 10, ...restQNxLibraryMeasureDefQNumFormat } = { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: index2 = 6, ...restQNxLibraryMeasureDefColoringBaseColor } = { index: 6 }, gradient: { limitType = "percent", ...restQNxLibraryMeasureDefColoringGradient } = { limitType: "percent" }, ...restQNxLibraryMeasureDefColoring } = { baseColor: { index: 6 }, gradient: { limitType: "percent" } }, ...restQNxLibraryMeasureDef } = { qNumFormat: { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: 6 }, gradient: { limitType: "percent" } } },
    qVariableListDef: {
      qData: { tags = "/tags", ...restQVariableListDefQData } = { tags: "/tags" },
      qShowConfig = true,
      qShowReserved = true,
      qType: qType3 = "variable",
      ...restQVariableListDef
    } = {
      qData: { tags: "/tags" },
      qShowConfig: true,
      qShowReserved: true,
      qType: "variable"
    },
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      qBookmarkListDef: { qType, ...restQBookmarkListDef },
      qHyperCubeDef: {
        qMaxStackedCells,
        qMode,
        qNoOfLeftDims,
        qPseudoDimPos,
        ...restQHyperCubeDef
      },
      qListObjectDef: { qFrequencyMode, ...restQListObjectDef },
      qNxLibraryDimensionDef: { coloring: { baseColor: { index, ...restQNxLibraryDimensionDefColoringBaseColor }, ...restQNxLibraryDimensionDefColoring }, ...restQNxLibraryDimensionDef },
      qNxLibraryMeasureDef: { qNumFormat: { qType: qType2, qnDec, ...restQNxLibraryMeasureDefQNumFormat }, coloring: { baseColor: { index: index2, ...restQNxLibraryMeasureDefColoringBaseColor }, gradient: { limitType, ...restQNxLibraryMeasureDefColoringGradient }, ...restQNxLibraryMeasureDefColoring }, ...restQNxLibraryMeasureDef },
      qVariableListDef: {
        qData: { tags, ...restQVariableListDefQData },
        qShowConfig,
        qShowReserved,
        qType: qType3,
        ...restQVariableListDef
      },
      ...rest
    };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateSessionObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /**    Removes a transient object.
  
  The operation is successful if qSuccess is set to true.
  
      @param qId - Identifier of the transient object to remove.
    */
  async destroySessionObject(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DestroySessionObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Creates a generic object at app level. For more information on generic objects, see Generic object.
  It is possible to create a generic object that is linked to another object.
  A linked object is an object that points to a linking object. The linking object is defined in the properties of the linked object (in qExtendsId ).
  The linked object has the same properties as the linking object.
  The linking object cannot be a transient object.
  
      @param qProp - Information about the object.
    */
  async createObject({
    qBookmarkListDef: { qType = "bookmark", ...restQBookmarkListDef } = { qType: "bookmark" },
    qHyperCubeDef: {
      qMaxStackedCells = 5e3,
      qMode = "DATA_MODE_STRAIGHT",
      qNoOfLeftDims = -1,
      qPseudoDimPos = -1,
      ...restQHyperCubeDef
    } = {
      qMaxStackedCells: 5e3,
      qMode: "DATA_MODE_STRAIGHT",
      qNoOfLeftDims: -1,
      qPseudoDimPos: -1
    },
    qListObjectDef: { qFrequencyMode = "NX_FREQUENCY_NONE", ...restQListObjectDef } = { qFrequencyMode: "NX_FREQUENCY_NONE" },
    qNxLibraryDimensionDef: { coloring: { baseColor: { index = 6, ...restQNxLibraryDimensionDefColoringBaseColor } = { index: 6 }, ...restQNxLibraryDimensionDefColoring } = { baseColor: { index: 6 } }, ...restQNxLibraryDimensionDef } = { coloring: { baseColor: { index: 6 } } },
    qNxLibraryMeasureDef: { qNumFormat: { qType: qType2 = "UNKNOWN", qnDec = 10, ...restQNxLibraryMeasureDefQNumFormat } = { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: index2 = 6, ...restQNxLibraryMeasureDefColoringBaseColor } = { index: 6 }, gradient: { limitType = "percent", ...restQNxLibraryMeasureDefColoringGradient } = { limitType: "percent" }, ...restQNxLibraryMeasureDefColoring } = { baseColor: { index: 6 }, gradient: { limitType: "percent" } }, ...restQNxLibraryMeasureDef } = { qNumFormat: { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: 6 }, gradient: { limitType: "percent" } } },
    qVariableListDef: {
      qData: { tags = "/tags", ...restQVariableListDefQData } = { tags: "/tags" },
      qShowConfig = true,
      qShowReserved = true,
      qType: qType3 = "variable",
      ...restQVariableListDef
    } = {
      qData: { tags: "/tags" },
      qShowConfig: true,
      qShowReserved: true,
      qType: "variable"
    },
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      qBookmarkListDef: { qType, ...restQBookmarkListDef },
      qHyperCubeDef: {
        qMaxStackedCells,
        qMode,
        qNoOfLeftDims,
        qPseudoDimPos,
        ...restQHyperCubeDef
      },
      qListObjectDef: { qFrequencyMode, ...restQListObjectDef },
      qNxLibraryDimensionDef: { coloring: { baseColor: { index, ...restQNxLibraryDimensionDefColoringBaseColor }, ...restQNxLibraryDimensionDefColoring }, ...restQNxLibraryDimensionDef },
      qNxLibraryMeasureDef: { qNumFormat: { qType: qType2, qnDec, ...restQNxLibraryMeasureDefQNumFormat }, coloring: { baseColor: { index: index2, ...restQNxLibraryMeasureDefColoringBaseColor }, gradient: { limitType, ...restQNxLibraryMeasureDefColoringGradient }, ...restQNxLibraryMeasureDefColoring }, ...restQNxLibraryMeasureDef },
      qVariableListDef: {
        qData: { tags, ...restQVariableListDefQData },
        qShowConfig,
        qShowReserved,
        qType: qType3,
        ...restQVariableListDef
      },
      ...rest
    };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /**    Removes an app object.
  The children of the object (if any) are removed as well.
  
  The operation is successful if qSuccess is set to true.
  
      @param qId - Identifier of the object to remove.
    */
  async destroyObject(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DestroyObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Returns the type of the app object and the corresponding handle.
  
      @param qId - Identifier of the object to retrieve.
    */
  async getObject(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /**    Returns all objects compatible with options.
  
      @param qOptions - Object type filter and requested properties.
    */
  async getObjects(qOptions) {
    const params = {};
    params.qOptions = qOptions;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetObjects",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qList"];
    return response.map((r) => r);
  }
  /**    Returns all bookmarks compatible with options.
  
      @param qOptions - Bookmark type filter and requested properties.
    */
  async getBookmarks({
    qData: {
      creationDate = "/creationDate",
      description = "/qMetaDef/description",
      selectionFields = "/selectionFields",
      sheetId = "/sheetId",
      title = "/qMetaDef/title",
      ...restQData
    } = {
      creationDate: "/creationDate",
      description: "/qMetaDef/description",
      selectionFields: "/selectionFields",
      sheetId: "/sheetId",
      title: "/qMetaDef/title"
    },
    qTypes = ["bookmark"],
    ...rest
  } = {}) {
    const params = {};
    params.qOptions = {
      qData: {
        creationDate,
        description,
        selectionFields,
        sheetId,
        title,
        ...restQData
      },
      qTypes,
      ...rest
    };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetBookmarks",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qList"];
    return response.map((r) => r);
  }
  /**    Clones root level objects, such as sheets and stories. The CloneObject method works for both app objects and child objects.
  When you clone an object that contains children, the children are cloned as well.
  If you for example want to clone a visualization, you must provide the qID of the root object, in this case the sheet since CloneObject clones root level objects.
  It is not possible to clone a session object.
  
  The identifier is set by the engine.
  
      @param qId - Identifier of the object to clone. The identifier must be a root object.
    */
  async cloneObject(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CloneObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qCloneId"];
    return response;
  }
  /**    Creates a draft of an object.
  This method can be used to create a draft of a sheet or a story that is published. This is a way to continue working on a sheet or a story that is published.
  Replace the published object by the content of the draft by invoking the CommitDraft method.
  
  The identifier is set by the engine.
      @deprecated
      @param qId - Identifier of the object to create a draft from.
    */
  async createDraft(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateDraft",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qDraftId"];
    return response;
  }
  /**    Commits the draft of an object that was previously created by invoking the CreateDraft method.
  Committing a draft replaces the corresponding published object.
      @deprecated
      @param qId - Identifier of the draft to commit.
    */
  async commitDraft(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CommitDraft",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Removes the draft of an object.
  The children of the draft object (if any) are removed as well.
  This method can be used to cancel the work on the draft of an object. For example, if you had created a draft of a sheet that is published, you might not want anymore to replace the published sheet.
  
  The operation is successful if qSuccess is set to true.
      @deprecated
      @param qId - Identifier of the draft object to remove.
      @param qSourceId - Identifier of the source object (the object from which a draft was created).
    */
  async destroyDraft(qId, qSourceId) {
    const params = {};
    params.qId = qId;
    params.qSourceId = qSourceId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DestroyDraft",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Undoes the previous operation.
  
  The operation is successful if qSuccess is set to true.
  
    */
  async undo() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Undo",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Redoes the previous operation.
  
  The operation is successful if qSuccess is set to true.
  
    */
  async redo() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Redo",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Clears entirely the undo and redo buffer.
  
    */
  async clearUndoBuffer() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ClearUndoBuffer",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Creates a master dimension.
  A master dimension is stored in the library of an app and can be used in many objects. Several generic objects can contain the same dimension.
  
      @param qProp - Information about the properties.
    */
  async createDimension({ qDim: { coloring: { baseColor: { index = 6, ...restQDimColoringBaseColor } = { index: 6 }, ...restQDimColoring } = { baseColor: { index: 6 } }, ...restQDim } = { coloring: { baseColor: { index: 6 } } }, ...rest } = {}) {
    const params = {};
    params.qProp = { qDim: { coloring: { baseColor: { index, ...restQDimColoringBaseColor }, ...restQDimColoring }, ...restQDim }, ...rest };
    params.qProp.qInfo = { qType: "dimension" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateDimension",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericDimension(response, this.session, this.auth);
    return obj;
  }
  /**    Removes a dimension.
  
  The operation is successful if qSuccess is set to true.
  
      @param qId - Identifier of the dimension to remove.
    */
  async destroyDimension(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DestroyDimension",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Returns the handle of a dimension.
  
      @param qId - Identifier of the dimension.
    */
  async getDimension(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetDimension",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericDimension(response, this.session, this.auth);
    return obj;
  }
  /**    Clones a dimension.
  
  The identifier is set by the engine.
  
      @param qId - Identifier of the object to clone.
    */
  async cloneDimension(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CloneDimension",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qCloneId"];
    return response;
  }
  /**    Creates a master measure.
  A master measure is stored in the library of an app and can be used in many objects. Several generic objects can contain the same measure.
  
      @param qProp - Information about the properties.
    */
  async createMeasure({ qMeasure: { qNumFormat: { qType = "UNKNOWN", qnDec = 10, ...restQMeasureQNumFormat } = { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index = 6, ...restQMeasureColoringBaseColor } = { index: 6 }, gradient: { limitType = "percent", ...restQMeasureColoringGradient } = { limitType: "percent" }, ...restQMeasureColoring } = { baseColor: { index: 6 }, gradient: { limitType: "percent" } }, ...restQMeasure } = { qNumFormat: { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: 6 }, gradient: { limitType: "percent" } } }, ...rest } = {}) {
    const params = {};
    params.qProp = { qMeasure: { qNumFormat: { qType, qnDec, ...restQMeasureQNumFormat }, coloring: { baseColor: { index, ...restQMeasureColoringBaseColor }, gradient: { limitType, ...restQMeasureColoringGradient }, ...restQMeasureColoring }, ...restQMeasure }, ...rest };
    params.qProp.qInfo = { qType: "measure" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateMeasure",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericMeasure(response, this.session, this.auth);
    return obj;
  }
  /**    Removes a generic measure.
  
  The operation is successful if qSuccess is set to true.
  
      @param qId - Identifier of the measure to remove.
    */
  async destroyMeasure(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DestroyMeasure",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Returns the handle of a measure.
  
      @param qId - Identifier of the measure.
    */
  async getMeasure(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetMeasure",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericMeasure(response, this.session, this.auth);
    return obj;
  }
  /**    Clones a measure.
  
  The identifier is set by the engine.
  
      @param qId - Identifier of the object to clone.
    */
  async cloneMeasure(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CloneMeasure",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qCloneId"];
    return response;
  }
  /**    Creates a transient variable.
  To set some properties to the variable, use the SetProperties method.
  
   Definition:
  A variable in Qlik Sense is a named entity, containing a data value. This value can be static or be the result of a calculation. A variable acquires its value at the same time that the variable is created or after when updating the properties of the variable. Variables can be used in bookmarks and can contain numeric or alphanumeric data. Any change made to the variable is applied everywhere the variable is used.
  When a variable is used in an expression, it is substituted by its value or the variable's definition.
  
   Example:
  The variable x contains the text string Sum(Sales) .
  In a chart, you define the expression $(x)/12 . The effect is exactly the same as having the chart expression Sum(Sales)/12 .
  However, if you change the value of the variable x to Sum(Budget) , the data in the chart are immediately recalculated with the expression interpreted as Sum(Budget)/12 .
  
      @param qProp - Name of the variable. Variable names are case sensitive.
    */
  async createSessionVariable({ qNumberPresentation: { qType = "UNKNOWN", qnDec = 10, ...restQNumberPresentation } = { qType: "UNKNOWN", qnDec: 10 }, ...rest } = {}) {
    const params = {};
    params.qProp = { qNumberPresentation: { qType, qnDec, ...restQNumberPresentation }, ...rest };
    params.qProp.qInfo = { qType: "variable" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateSessionVariable",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericVariable(response, this.session, this.auth);
    return obj;
  }
  /**    Removes a transient variable.
  
  The operation is successful if qSuccess is set to true.
  
      @param qId - Identifier of the variable.
    */
  async destroySessionVariable(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DestroySessionVariable",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Creates a variable.
  To create a variable via a script, you need to use the SetScript method. For more information, see Create a variable.
  To set some properties to the variable, use the SetProperties method.  In a published app, only transient variables can be created. See CreateSessionVariable method.
  
   Definition:
  A variable in Qlik Sense is a named entity, containing a data value. This value can be static or be the result of a calculation. A variable acquires its value at the same time that the variable is created or after when updating the properties of the variable. Variables can be used in bookmarks and can contain numeric or alphanumeric data. Any change made to the variable is applied everywhere the variable is used.
  When a variable is used in an expression, it is substituted by its value or the variable's definition.
  
   Example:
  The variable x contains the text string Sum(Sales) .
  In a chart, you define the expression $(x)/12 . The effect is exactly the same as having the chart expression Sum(Sales)/12 .
  However, if you change the value of the variable x to Sum(Budget) , the data in the chart are immediately recalculated with the expression interpreted as Sum(Budget)/12 .
  
      @param qProp - Name of the variable. Variable names are case sensitive and must be unique.
    */
  async createVariableEx({ qNumberPresentation: { qType = "UNKNOWN", qnDec = 10, ...restQNumberPresentation } = { qType: "UNKNOWN", qnDec: 10 }, ...rest } = {}) {
    const params = {};
    params.qProp = { qNumberPresentation: { qType, qnDec, ...restQNumberPresentation }, ...rest };
    params.qProp.qInfo = { qType: "variable" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateVariableEx",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericVariable(response, this.session, this.auth);
    return obj;
  }
  /**    Removes a variable.
  Script-defined variables cannot be removed using the DestroyVariableById method or the DestroyVariableByName method. For more information, see Remove a variable.
  
  The operation is successful if qSuccess is set to true.
  
      @param qId - Identifier of the variable.
    */
  async destroyVariableById(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DestroyVariableById",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Removes a variable.
  Script-defined variables cannot be removed using the DestroyVariableById method or the DestroyVariableByName method. For more information, see Remove a variable.
  
  The operation is successful if qSuccess is set to true.
  
      @param qName - Name of the variable.
    */
  async destroyVariableByName(qName) {
    const params = {};
    params.qName = qName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DestroyVariableByName",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Gets the handle of a variable.
  
      @param qId - Identifier of the variable.
    */
  async getVariableById(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetVariableById",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericVariable(response, this.session, this.auth);
    return obj;
  }
  /**    Gets the handle of a variable.
  
      @param qName - Name of the variable.
    */
  async getVariableByName(qName) {
    const params = {};
    params.qName = qName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetVariableByName",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericVariable(response, this.session, this.auth);
    return obj;
  }
  /**    Checks if a given expression is valid.
  The expression is correct if the parameters qErrorMsg , qBadFieldNames and qDangerousFieldNames are empty.
  
      @param qExpr - Expression to check.
      @param qLabels - List of labels.
    */
  async checkExpression(qExpr, qLabels) {
    const params = {};
    params.qExpr = qExpr;
    if (qLabels !== void 0) {
      params.qLabels = qLabels;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CheckExpression",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"];
  }
  /**    Checks if:
  
  • A given expression is valid.
  
  • A number is correct according to the locale.
  
      @param qExpr - Expression to check.
    */
  async checkNumberOrExpression(qExpr) {
    const params = {};
    params.qExpr = qExpr;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CheckNumberOrExpression",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"];
  }
  /**    Adds an alternate state in the app.
  You can create multiple states within a Qlik Sense app and apply these states to specific objects within the app. Objects in a given state are not affected by user selections in the other states.
  
      @param qStateName - Name of the alternate state.
    */
  async addAlternateState(qStateName) {
    const params = {};
    params.qStateName = qStateName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "AddAlternateState",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Removes an alternate state in the app.
  
      @param qStateName - Name of the alternate state.
    */
  async removeAlternateState(qStateName) {
    const params = {};
    params.qStateName = qStateName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "RemoveAlternateState",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Adds an session alternate state in the app.
  You can create multiple states within a Qlik Sense app and apply these states to specific objects within the app. Objects in a given state are not affected by user selections in the other states.
  A session alternate state is not persisted and is not included in the StateNames array in the AppLayout.
  You can use the optional second parameter to choose any other state to get the initial selection on the new state from
  
      @param qStateName - Name of the alternate state.
      @param qSourceStateName - Name of existing state to copy the initial selections from
    */
  async addSessionAlternateState(qStateName, qSourceStateName) {
    const params = {};
    params.qStateName = qStateName;
    if (qSourceStateName !== void 0) {
      params.qSourceStateName = qSourceStateName;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "AddSessionAlternateState",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Removes an session alternate state in the app.
  The operation is successful if qSuccess is set to true.
  
      @param qStateName - Name of the alternate state.
    */
  async removeSessionAlternateState(qStateName) {
    const params = {};
    params.qStateName = qStateName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "RemoveSessionAlternateState",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Creates a bookmark.
  
      @param qProp - Properties for the object.
    */
  async createBookmark({ creationDate = (/* @__PURE__ */ new Date()).toISOString(), ...rest } = {}) {
    const params = {};
    params.qProp = { creationDate, ...rest };
    params.qProp.qInfo = { qType: "bookmark" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateBookmark",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericBookmark(response, this.session, this.auth);
    return obj;
  }
  /**    Removes a bookmark.
  The operation is successful if qSuccess is set to true.
  
      @param qId - Identifier of the bookmark.
    */
  async destroyBookmark(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DestroyBookmark",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Returns the handle of a bookmark.
  
      @param qId - Identifier of the bookmark.
    */
  async getBookmark(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetBookmark",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericBookmark(response, this.session, this.auth);
    return obj;
  }
  /**    Applies a bookmark.
  The operation is successful if qSuccess is set to true.
  
      @param qId - Identifier of the bookmark.
    */
  async applyBookmark(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ApplyBookmark",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Applies a bookmark and verifies result dataset against originally selected values.
  The operation is successful if qApplySuccess is set to true. qWarnings lists state and field with unmatching values
      @experimental
      @param qId - Identifier of the bookmark.
    */
  async applyAndVerifyBookmark(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ApplyAndVerifyBookmark",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qResult"];
  }
  /**    Clones a bookmark.
  The identifier is set by the engine.
  
      @param qId - Identifier of the object to clone.
    */
  async cloneBookmark(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CloneBookmark",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qCloneId"];
    return response;
  }
  /**    Adds a field on the fly.
  The expression of a field on the fly is persisted but not its values.
  The operation is successful if qSuccess is set to true.
  
      @param qName - Name of the field.
      @param qExpr - Expression value.
  It is not possible to use all aggregation functions. For example, you cannot add a field on the fly with an expression that uses the Sum or Count aggregation functions.
    */
  async addFieldFromExpression(qName, qExpr) {
    const params = {};
    params.qName = qName;
    params.qExpr = qExpr;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "AddFieldFromExpression",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Find the field-on-the-fly by passing its readable name.
  
      @param qReadableName - Readable name of the field-on-the-fly.
    */
  async getFieldOnTheFlyByName(qReadableName) {
    const params = {};
    params.qReadableName = qReadableName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetFieldOnTheFlyByName",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qName"];
    return response;
  }
  /**    Returns the identifier and the type of any generic object in the app.
  
    */
  async getAllInfos() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetAllInfos",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qInfos"];
    return response.map((r) => r);
  }
  /**    Resumes the app as the user left it.
  
    */
  async resume() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Resume",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Aborts any selection mode in an app. For more information about selection mode, see BeginSelections method.
  
      @param qAccept - Set this parameter to true to accept the selections before exiting the selection mode.
    */
  async abortModal(qAccept) {
    const params = {};
    params.qAccept = qAccept;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "AbortModal",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Retrieves any fields that match all of the specified tags or just one of them in the data model of an app.
  Tags set by Qlik Sense are prefixed by the $ sign.
  
      @param qTags - List of tags.
  The GetMatchingFields method looks for fields that match one or all of the tags in this list, depending on the value of qMatchingFieldMode .
      @param qMatchingFieldMode - Matching field mode.
  The default value is MATCHINGFIELDMODE_MATCH_ALL.
  
  One of:
  
  • MATCHINGFIELDMODE_MATCH_ALL
  
  • MATCHINGFIELDMODE_MATCH_ONE
    */
  async getMatchingFields(qTags, qMatchingFieldMode) {
    const params = {};
    params.qTags = qTags;
    if (qMatchingFieldMode !== void 0) {
      params.qMatchingFieldMode = qMatchingFieldMode;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetMatchingFields",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qFieldNames"];
    return response.map((r) => r);
  }
  /**    Retrieves any fields that belong to the same archipelago as the specified field and that match at least one of the specified tags.
  Tags set by Qlik Sense are prefixed by the $ sign.
  
      @param qFieldName - Name of the field.
  This method looks for fields that belong to the same archipelago as this specified field.
      @param qTags - List of tags.
  This method looks for fields that match at least one of the tags in this list.
    */
  async findMatchingFields(qFieldName, qTags) {
    const params = {};
    params.qFieldName = qFieldName;
    params.qTags = qTags;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "FindMatchingFields",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qFieldNames"];
    return response.map((r) => r);
  }
  /**    Scrambles a field so the data is not recognizable. Some properties are retained to help debugging. For example, special characters are not changed, and small numbers are scrambled to another small number.
  Update access is required to use the function in Qlik Sense Enterprise.
  
      @param qFieldName - Name of the field to scramble.
    */
  async scramble(qFieldName) {
    const params = {};
    params.qFieldName = qFieldName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Scramble",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Saves all objects that were modified in the app.
  Data from the data model are not saved. This operation is possible only in Qlik Sense Enterprise.
  
    */
  async saveObjects() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SaveObjects",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Computes a set of association scores for each pair of fields between two given tables that have been loaded in an app.
  When a table contains some synthetic keys, all fields in the synthetic key tables are analyzed against fields in other tables. To denote that a field is a synthetic key, the field name is prefixed by [Synthetic Key]: .
  
      @param qTable1 - Name of the first table.
      @param qTable2 - Name of the second table.
    */
  async getAssociationScores(qTable1, qTable2) {
    const params = {};
    params.qTable1 = qTable1;
    params.qTable2 = qTable2;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetAssociationScores",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qScore"];
    return response.map((r) => r);
  }
  /**    Lists the media files.
      @deprecated
  
    */
  async getMediaList() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetMediaList",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"];
  }
  /**    Lists the content libraries.
  To differentiate a global content library from an app specific content library, you can check the property qAppSpecific . If this property is set to true, it means that the content library is app specific.
  There is always one specific content library per app.
  
   Qlik Sense:
  Returns the global content libraries and the app specific content library.
  When using Qlik Sense, you can have more than one global content library. The global content libraries are common to all apps in the Qlik Sense repository.
  By default, there is one global content library named Default .
  
   Qlik Sense Desktop:
  Returns the global content library and the app specific content library from the disk.
  
    */
  async getContentLibraries() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetContentLibraries",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qList"];
  }
  /**    Returns the content of a library.
  
   Global content library:
  In Qlik Sense Desktop, the content files are retrieved from:
  %userprofile%\Documents\Qlik\Sense\Content\Default
  In Qlik Sense Enterprise, the content files are retrieved from the Qlik Sense repository.
  
   App specific content library:
  The embedded files are returned.
  
      @param qName - Name of the content library.
  It corresponds to the property qContentLibraryListItem/qName returned by the GetContentLibraries method.
    */
  async getLibraryContent(qName) {
    const params = {};
    params.qName = qName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetLibraryContent",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qList"];
  }
  /**    Reloads the script that is set in an app and returns the path to the script log file.
  A log file is created per reload.
  
   Logs:
  When this method is called, audit activity logs are produced to track the user activity.
  In the case of errors, both audit activity logs and system services logs are produced.
  The log files are named as follows:
  | Audit activity log                                                                                                                      | System service log                                                                                                          |
  |-----------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------|
  | __AuditActivity_Engine.txt_ in Qlik Sense Enterprise  __AuditActivity_Engine.log_ in Qlik Sense Desktop | __Service_Engine.txt_ in Qlik Sense Enterprise  __Service_Engine.log_ in Qlik Sense Desktop |
  
   Where to find the log files:
  The location of the log files depends on whether you have installed Qlik Sense Enterprise or Qlik Sense Desktop.
  | Qlik Sense Enterprise                 | Qlik Sense Desktop                       |
  |---------------------------------------|------------------------------------------|
  | _%ProgramData%/Qlik/Sense/Log/Engine_ | _%UserProfile%/Documents/Qlik/Sense/Log_ |
  
   DoReloadExParams:
  | Name     | Description                                                                                                                                                                                                                                    | Type    |
  |----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------|
  | qMode    | Error handling mode  One of:  *   0: for default mode.*   1: for ABEND; the reload of the script ends if an error occurs.*   2: for ignore; the reload of the script continues even if an error is detected in the script. | Integer |
  | qPartial | Set to true for partial reload.  The default value is false.                                                                                                                                                                               | Boolean |
  | qDebug   | Set to true if debug breakpoints are to be honored. The execution of the script will be in debug mode.  The default value is false.                                                                                                        | Boolean |
  
   DoReloadExResult:
  | Name           | Description                                               | Type    |
  |----------------|-----------------------------------------------------------|---------|
  | qSuccess       | The operation is successful if _qSuccess_ is set to True. | Boolean |
  | qScriptLogFile | Path to the script log file.                              | String  |
  
  If the data load has successfully finished, no matter how the indexing behaves, true is returned. This happens even if there is a timeout, a memory limit is reached or any other error occurs during the indexing.
  
      @param qParams -
    */
  async doReloadEx(qParams) {
    const params = {};
    if (qParams !== void 0) {
      params.qParams = qParams;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DoReloadEx",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qResult"];
  }
  /**    Returns the number of entries on the back stack.
  
    */
  async backCount() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "BackCount",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Returns the number of entries on the Forward stack.
  
    */
  async forwardCount() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ForwardCount",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Applies a bookmark to reduce (slice) the data on. Returns a url and file size to the reduced application. Section Access is always applied.
  This API is only available on Sense Enterprise on Windows
  
      @param qOptions - BookmarkId used to reduced the app on and an expire time.
    */
  async exportReducedData({ qExpires = 3600, ...rest } = {}) {
    const params = {};
    params.qOptions = { qExpires, ...rest };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ExportReducedData",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qDownloadInfo"];
  }
  /**    Returns a set analysis expression from active selections or from a saved bookmark. Fields on the fly and Calculated dimensions will not be included in the generated expressions, instead a message indicating 'missing fields' will provided within the expression.
  |                       | BookmarkId empty                     | BookmarkId set                                     |
  |-----------------------|--------------------------------------|----------------------------------------------------|
  |StateName empty (or $) | Default selections state is returned.| Default state ($) in bookmark with id is returned. |
  |StateName set          | State selections is returned.        | State in bookmark with id is returned.             |
  
      @param qStateName - Optional. The name of the state to get set analysis expression for. If left empty, the default state will be retrieved.
      @param qBookmarkId - Optional. The Id of the bookmark to get the set analysis expression for. If left empty, the current selection will be retrieved.
    */
  async getSetAnalysis(qStateName, qBookmarkId) {
    const params = {};
    if (qStateName !== void 0) {
      params.qStateName = qStateName;
    }
    if (qBookmarkId !== void 0) {
      params.qBookmarkId = qBookmarkId;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetSetAnalysis",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSetExpression"];
    return response;
  }
  /**    Sets values in script.
  
      @param qScript - Script content.
    */
  async setScript(qScript) {
    const params = {};
    params.qScript = qScript;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetScript",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Checks the syntax of a script.
  
   Example:
  "result": { "qErrors": [ { "qErrLen": 3, "qTabIx": 0, "qLineInTab": 0, "qColInLine": 0, "qTextPos": 0 }, { "qErrLen": 5, "qTabIx": 0, "qLineInTab": 0, "qColInLine": 1, "qTextPos": 4, "qSecondaryFailure": true } ] }
  The first area is the primary error area, the second area is the secondary error area. The second area is optional and is shown only if qSecondaryFailure is set to true. The second area ends when the next statement in the script begins.
  The list of syntax errors in the script.
  If there are no errors, the engine returns:
  If there are errors, the engine returns the following properties in the response:
  | Name              | Description                                                      | Type    |
  |-------------------|------------------------------------------------------------------|---------|
  | qErrLen           | Length of the word where the error is located.                   | Integer |
  | qTabIx            | Number of the faulty section.                                    | Integer |
  | qLineInTab        | Line number in the section where the error is located.           | Integer |
  | qColInLine        | Position of the erroneous text from the beginning of the line.   | Integer |
  | qTextPos          | Position of the erroneous text from the beginning of the script. | Integer |
  | qSecondaryFailure | The default value is false.                                      | Boolean |
  
    */
  async checkScriptSyntax() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CheckScriptSyntax",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qErrors"];
    return response.map((r) => r);
  }
  /**    Retrieves the variables that are tagged as favorite.
  
    */
  async getFavoriteVariables() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetFavoriteVariables",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qNames"];
    return response;
  }
  /**    Set some variables as favorite.
  
      @param qNames - Variables to set as favorite.
    */
  async setFavoriteVariables(qNames) {
    const params = {};
    params.qNames = qNames;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetFavoriteVariables",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Gets the content of a file.
  
      @param qPath - ["lib://CONNECTION_NAME\\\<the name of the file you want to use>.txt"]
  OR
  ["lib://Connection_Name\\\<Folder under your connection>\\\<the name of the file you want to use>.txt"]
  [ ] should be used when the first variable contains a lib reference.
    */
  async getIncludeFileContent(qPath) {
    const params = {};
    params.qPath = qPath;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetIncludeFileContent",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qContent"];
    return response;
  }
  /**    Creates a connection.
  A connection indicates from which data source the data should be taken.
  
      @param qConnection - Information about the connection.
    */
  async createConnection(qConnection) {
    const params = {};
    params.qConnection = qConnection;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateConnection",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qConnectionId"];
    return response;
  }
  /**    Updates a connection.
  The identifier of a connection cannot be updated. qType cannot be modified with the ModifyConnection method.
  
      @param qConnectionId - Identifier of the connection.
      @param qConnection - Information about the connection.
  Properties that can be updated.
      @param qOverrideCredentials - Set this parameter to true to override the user name and password.
    */
  async modifyConnection(qConnectionId, qConnection, qOverrideCredentials) {
    const params = {};
    params.qConnectionId = qConnectionId;
    params.qConnection = qConnection;
    if (qOverrideCredentials !== void 0) {
      params.qOverrideCredentials = qOverrideCredentials;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ModifyConnection",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Deletes a connection.
  In Qlik Sense Enterprise, there is an additional file connection named AttachedFiles . The AttachedFiles connection can only be removed by the administrator of the system.
  
      @param qConnectionId - Identifier of the connection to remove.
    */
  async deleteConnection(qConnectionId) {
    const params = {};
    params.qConnectionId = qConnectionId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DeleteConnection",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Retrieves a connection and returns:
  
  • The creation time of the connection.
  
  • The identifier of the connection.
  
  • The type of the connection.
  
  • The name of the connection.
  
  • The connection string.
  
      @param qConnectionId - Identifier of the connection.
    */
  async getConnection(qConnectionId) {
    const params = {};
    params.qConnectionId = qConnectionId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetConnection",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qConnection"];
  }
  /**    Lists the connections in an app.
  In Qlik Sense Enterprise, there is an additional file connection named AttachedFiles . This connection is stored in the Qlik Sense repository.
  
    */
  async getConnections() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetConnections",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qConnections"];
    return response.map((r) => r);
  }
  /**    Gives information about an ODBC, OLEDB or CUSTOM connection. See Outputs for more details.
  
      @param qConnectionId - Name of the connection.
    */
  async getDatabaseInfo(qConnectionId) {
    const params = {};
    params.qConnectionId = qConnectionId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetDatabaseInfo",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qInfo"];
  }
  /**    Lists the databases inside a ODBC, OLEDB or CUSTOM data source.
  
      @param qConnectionId - Identifier of the connection.
    */
  async getDatabases(qConnectionId) {
    const params = {};
    params.qConnectionId = qConnectionId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetDatabases",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qDatabases"];
    return response.map((r) => r);
  }
  /**    Lists the owners of a database for a ODBC, OLEDB or CUSTOM connection.
  
      @param qConnectionId - Identifier of the connection.
      @param qDatabase - Name of the database.
    */
  async getDatabaseOwners(qConnectionId, qDatabase) {
    const params = {};
    params.qConnectionId = qConnectionId;
    if (qDatabase !== void 0) {
      params.qDatabase = qDatabase;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetDatabaseOwners",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qOwners"];
    return response.map((r) => r);
  }
  /**    Lists the tables inside a database for a ODBC, OLEDB or CUSTOM connection.
  
      @param qConnectionId - Identifier of the connection.
      @param qDatabase - Name of the database.
  If qDatabase is not set then qOwner must be set.
      @param qOwner - Owner of the database.
  If qOwner is not set then qDatabase must be set.
    */
  async getDatabaseTables(qConnectionId, qDatabase, qOwner) {
    const params = {};
    params.qConnectionId = qConnectionId;
    if (qDatabase !== void 0) {
      params.qDatabase = qDatabase;
    }
    if (qOwner !== void 0) {
      params.qOwner = qOwner;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetDatabaseTables",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qTables"];
    return response.map((r) => r);
  }
  /**    Lists the fields inside a table of a database for a ODBC, OLEDB or CUSTOM connection.
  
      @param qConnectionId - Identifier of the connection.
      @param qTable - Name of the table.
      @param qDatabase - Name of the database.
  If qDatabase is not set then qOwner must be set.
      @param qOwner - Owner of the database.
  If qOwner is not set then qDatabase must be set.
    */
  async getDatabaseTableFields(qConnectionId, qTable, qDatabase, qOwner) {
    const params = {};
    params.qConnectionId = qConnectionId;
    params.qTable = qTable;
    if (qDatabase !== void 0) {
      params.qDatabase = qDatabase;
    }
    if (qOwner !== void 0) {
      params.qOwner = qOwner;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetDatabaseTableFields",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qFields"];
    return response.map((r) => r);
  }
  /**    Retrieves the values of the specified table of a database for a ODBC, OLEDB or CUSTOM connection.
  
      @param qConnectionId - Identifier of the connection.
      @param qTable - Name of the table.
      @param qDatabase - Name of the database.
  If qDatabase is not set then qOwner must be set.
      @param qOwner - Owner of the database.
  If qOwner is not set then qDatabase must be set.
      @param qConditions -
    */
  async getDatabaseTablePreview(qConnectionId, qTable, qDatabase, qOwner, qConditions) {
    const params = {};
    params.qConnectionId = qConnectionId;
    params.qTable = qTable;
    if (qDatabase !== void 0) {
      params.qDatabase = qDatabase;
    }
    if (qOwner !== void 0) {
      params.qOwner = qOwner;
    }
    if (qConditions !== void 0) {
      params.qConditions = qConditions;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetDatabaseTablePreview",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"];
  }
  /**    Lists the items for a folder connection.
  
      @param qConnectionId - Identifier of the connection.
      @param qRelativePath - Relative path of the connection.
    */
  async getFolderItemsForConnection(qConnectionId, qRelativePath) {
    const params = {};
    params.qConnectionId = qConnectionId;
    if (qRelativePath !== void 0) {
      params.qRelativePath = qRelativePath;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetFolderItemsForConnection",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qFolderItems"];
    return response.map((r) => r);
  }
  /**    Guesses the data format for a given file.
  Recognized file formats are:
  
  • CSV for Delimited
  
  • FIX for Fixed Record
  
  • DIF for Data Interchange Format
  
  • EXCEL_BIFF for Microsoft Excel (XLS)
  
  • EXCEL_OOXML for Microsoft Excel (XLSX)
  
  • HTML for HTML
  
  • QVD for QVD file
  
  • XML for XML
  
  • QVX for QVX file
  
  • JSON for JSON format
  
  • KML for KML file
  
  • PARQUET for PARQUET file
  
   FileType:
  Recognized file formats are:
  
  • CSV for Delimited
  
  • FIX for Fixed Record
  
  • DIF for Data Interchange Format
  
  • EXCEL_BIFF for Microsoft Excel (XLS)
  
  • EXCEL_OOXML for Microsoft Excel (XLSX)
  
  • HTML for HTML
  
  • QVD for QVD file
  
  • XML for XML
  
  • QVX for QVX file
  
  • JSON for JSON format
  
  • KML for KML file
  
  • PARQUET for PARQUET file
  
      @param qConnectionId - Identifier of the connection file.
      @param qRelativePath - Path of the connection file.
    */
  async guessFileType(qConnectionId, qRelativePath) {
    const params = {};
    params.qConnectionId = qConnectionId;
    if (qRelativePath !== void 0) {
      params.qRelativePath = qRelativePath;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GuessFileType",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qDataFormat"];
  }
  /**    Lists the tables for a folder connection.
  
   FileType:
  Recognized file formats are:
  
  • CSV for Delimited
  
  • FIX for Fixed Record
  
  • DIF for Data Interchange Format
  
  • EXCEL_BIFF for Microsoft Excel (XLS)
  
  • EXCEL_OOXML for Microsoft Excel (XLSX)
  
  • HTML for HTML
  
  • QVD for QVD file
  
  • XML for XML
  
  • QVX for QVX file
  
  • JSON for JSON format
  
  • KML for KML file
  
  • PARQUET for PARQUET file
  
      @param qConnectionId - Identifier of the connection.
      @param qDataFormat - Type of the file.
      @param qRelativePath - Path of the connection file.
    */
  async getFileTables(qConnectionId, qDataFormat, qRelativePath) {
    const params = {};
    params.qConnectionId = qConnectionId;
    params.qDataFormat = qDataFormat;
    if (qRelativePath !== void 0) {
      params.qRelativePath = qRelativePath;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetFileTables",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qTables"];
    return response.map((r) => r);
  }
  /**    Lists the fields of a table for a folder connection.
  
   FileType:
  Recognized file formats are:
  
  • CSV for Delimited
  
  • FIX for Fixed Record
  
  • DIF for Data Interchange Format
  
  • EXCEL_BIFF for Microsoft Excel (XLS)
  
  • EXCEL_OOXML for Microsoft Excel (XLSX)
  
  • HTML for HTML
  
  • QVD for QVD file
  
  • XML for XML
  
  • QVX for QVX file
  
  • JSON for JSON format
  
  • KML for KML file
  
  • PARQUET for PARQUET file
  
      @param qConnectionId - Identifier of the connection.
      @param qDataFormat - Type of the file.
      @param qTable - Name of the table.
  This parameter must be set for XLS , XLSX , HTML  _ and _XML files.
      @param qRelativePath - Path of the connection file.
    */
  async getFileTableFields(qConnectionId, qDataFormat, qTable, qRelativePath) {
    const params = {};
    params.qConnectionId = qConnectionId;
    params.qDataFormat = qDataFormat;
    params.qTable = qTable;
    if (qRelativePath !== void 0) {
      params.qRelativePath = qRelativePath;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetFileTableFields",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"];
  }
  /**    Lists the values in a table for a folder connection.
  
   FileType:
  Recognized file formats are:
  
  • CSV for Delimited
  
  • FIX for Fixed Record
  
  • DIF for Data Interchange Format
  
  • EXCEL_BIFF for Microsoft Excel (XLS)
  
  • EXCEL_OOXML for Microsoft Excel (XLSX)
  
  • HTML for HTML
  
  • QVD for QVD file
  
  • XML for XML
  
  • QVX for QVX file
  
  • JSON for JSON format
  
  • KML for KML file
  
  • PARQUET for PARQUET file
  
      @param qConnectionId - Identifier of the connection.
      @param qDataFormat - Type of the file.
      @param qTable - Name of the table.
  This parameter must be set for XLS , XLSX , HTML  _ and _XML files.
      @param qRelativePath - Path of the connection file.
    */
  async getFileTablePreview(qConnectionId, qDataFormat, qTable, qRelativePath) {
    const params = {};
    params.qConnectionId = qConnectionId;
    params.qDataFormat = qDataFormat;
    params.qTable = qTable;
    if (qRelativePath !== void 0) {
      params.qRelativePath = qRelativePath;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetFileTablePreview",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"];
  }
  /**    Lists the tables and fields of a JSON or XML file for a folder connection.
  
      @param qConnectionId - Identifier of the connection.
      @param qDataFormat - Type of the file.
      @param qRelativePath - Path of the connection file.
    */
  async getFileTablesEx(qConnectionId, qDataFormat, qRelativePath) {
    const params = {};
    params.qConnectionId = qConnectionId;
    params.qDataFormat = qDataFormat;
    if (qRelativePath !== void 0) {
      params.qRelativePath = qRelativePath;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetFileTablesEx",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qTables"];
    return response.map((r) => r);
  }
  /**    Sends a generic command to a custom connector.
  For more information on the commands that can be sent to a custom connector, see the QVX SDK help.
  
      @param qProvider - Connector file name.
  Command to be executed by the connector.
      @param qCommand - One of:
  
  • JsonRequest
  
  • GetCustomCaption
  
  • IsConnected
  
  • DisableQlikViewSelectButton
  
  • HaveStarField
      @param qMethod - Method name to be used within the command.
  The available methods depend on the chosen connector.
      @param qParameters - Parameters of the command.
  No parameters are required.
      @param qAppendConnection - Name of the connection.
    */
  async sendGenericCommandToCustomConnector(qProvider, qCommand, qMethod, qParameters, qAppendConnection) {
    const params = {};
    params.qProvider = qProvider;
    params.qCommand = qCommand;
    params.qMethod = qMethod;
    params.qParameters = qParameters;
    params.qAppendConnection = qAppendConnection;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SendGenericCommandToCustomConnector",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qResult"];
    return response;
  }
  /**    Returns search terms suggestions.
  
      @param qTerms - Terms to search for.
      @param qOptions - Information about the search combinations.
    */
  async searchSuggest(qTerms, { qCharEncoding = "CHAR_ENCODING_UTF8", qContext = "CONTEXT_LOCKED_FIELDS_ONLY", ...rest } = {}) {
    const params = {};
    params.qTerms = qTerms;
    params.qOptions = { qCharEncoding, qContext, ...rest };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SearchSuggest",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qResult"];
  }
  /**    Returns the search matches for one or more search terms.
  The search results depend on the search context.
  SearchCombinationOptions
  
   SearchMatchCombinations:
  | Name                     | Description                   | Type                              |
  |--------------------------|-------------------------------|-----------------------------------|
  | qSearchMatchCombinations | Array of search combinations. | Array of _SearchMatchCombination_ |
      @deprecated
      @param qTerms - List of terms to search for.
      @param qOptions - Information about the search fields and the search context.
      @param qPage - Array of pages to retrieve.
    */
  async searchAssociations(qTerms, { qCharEncoding = "CHAR_ENCODING_UTF8", qContext = "CONTEXT_LOCKED_FIELDS_ONLY", ...rest } = {}, { qMaxNbrFieldMatches = -1, ...rest2 } = {}) {
    const params = {};
    params.qTerms = qTerms;
    params.qOptions = { qCharEncoding, qContext, ...rest };
    params.qPage = { qMaxNbrFieldMatches, ...rest2 };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SearchAssociations",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qResults"];
  }
  /**    Selects all search hits for a specified group.
  The results depend on the search context.
  SearchCombinationOptions.
  
      @param qTerms - List of terms to search for.
      @param qMatchIx - Index (value of qId ) of the search result to select.
      @param qSoftLock - This parameter is deprecated and should not be set.
      @param qOptions - Information about the search fields and the search context.
    */
  async selectAssociations(qTerms, qMatchIx, qSoftLock, { qCharEncoding = "CHAR_ENCODING_UTF8", qContext = "CONTEXT_LOCKED_FIELDS_ONLY", ...rest } = {}) {
    const params = {};
    params.qTerms = qTerms;
    params.qMatchIx = qMatchIx;
    params.qOptions = { qCharEncoding, qContext, ...rest };
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectAssociations",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Returns the search matches for one or more search terms.
  Search results are organized in search groups. The type of search group indicates where the search matches come from (from data for example).
  Each search group contains search results that correspond to a combination of search terms.
  For example, if the search terms are organic , pasta , and America , the possible combination of search groups are:
  
  • organic
  
  • pasta
  
  • America
  
  • organic, pasta, America
  
  • organic, pasta
  
  • organic, America
  
  • pasta, America
  
  For every search group, there are one or more search group items. Each subgroup item contains results that correspond to an item type (for example a field).
  For every search group item, there are one or several search matches. The position of the match in each search result is given.
  
      @param qTerms - Terms to search for.
      @param qOptions - Information about the search combinations.
      @param qPage - Array of pages to retrieve.
    */
  async searchResults(qTerms, { qCharEncoding = "CHAR_ENCODING_UTF8", qContext = "CONTEXT_LOCKED_FIELDS_ONLY", ...rest } = {}, { qMaxNbrFieldMatches = -1, ...rest2 } = {}) {
    const params = {};
    params.qTerms = qTerms;
    params.qOptions = { qCharEncoding, qContext, ...rest };
    params.qPage = { qMaxNbrFieldMatches, ...rest2 };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SearchResults",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qResult"];
  }
  /**    Returns the generic objects corresponding to one or more search terms. The search is performed within the title, subtitle, footnote and type. In addition, associated dimension values are also searched in. For example, if the country “Japan” is selected and the object contains the dimension City, the object will appear in the results for “Osaka” but not for “Johannesburg”. The generic objects with the following types will never appear in the results: slideitem , sheet , story , slide , masterobject , snapshot , LoadModel , appprops and searchhistory .
  
      @param qTerms - Terms to search for.
      @param qOptions - Information about attributes.
      @param qPage - Array of pages to retrieve.
    */
  async searchObjects(qTerms, { qCharEncoding = "CHAR_ENCODING_UTF8", ...rest } = {}, { qMaxNbrFieldMatches = -1, ...rest2 } = {}) {
    const params = {};
    params.qTerms = qTerms;
    params.qOptions = { qCharEncoding, ...rest };
    params.qPage = { qMaxNbrFieldMatches, ...rest2 };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SearchObjects",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qResult"];
  }
  /**    Get sample values from either a column in a table or from a field.
  Supports wildcard matches in tables or field names:
  - '*' for zero or more characters.
  - '?' for one character.
  
      @param qFieldsOrColumnsWithWildcards - Pairs of table (optionally) and field names. Support wildcard matches.
      @param qMaxNumberOfValues - Max number of sample values returned. Depending on the column or field size the number of returned samples can be less than MaxNumberOfValues. If MaxNumberOfValues is negative all sample values are returned.
      @param qRandSeed - Optional. Sets the random number seed. Should only be set for test purposes.
    */
  async getFieldAndColumnSamples(qFieldsOrColumnsWithWildcards, qMaxNumberOfValues, qRandSeed) {
    const params = {};
    params.qFieldsOrColumnsWithWildcards = qFieldsOrColumnsWithWildcards;
    params.qMaxNumberOfValues = qMaxNumberOfValues;
    if (qRandSeed !== void 0) {
      params.qRandSeed = qRandSeed;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetFieldAndColumnSamples",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qResult"];
    return response.map((r) => r);
  }
  /**    Gets script and script meta-data.
  
    */
  async getScriptEx() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetScriptEx",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qScript"];
  }
  /**
  
      @param qListDef -
    */
  async getVariables({
    qData: { tags = "/tags", ...restQData } = { tags: "/tags" },
    qShowConfig = true,
    qShowReserved = true,
    qType = "variable",
    ...rest
  } = {}) {
    const params = {};
    params.qListDef = {
      qData: { tags, ...restQData },
      qShowConfig,
      qShowReserved,
      qType,
      ...rest
    };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetVariables",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qList"];
    return response.map((r) => r);
  }
  /**    Expands the expression.
  
      @param qExpression - The expression string to expand.
    */
  async expandExpression(qExpression) {
    const params = {};
    params.qExpression = qExpression;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ExpandExpression",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qExpandedExpression"];
    return response;
  }
  /**    Removes a transient variable.
  
  qSuccess is set to true if the operation is successful.
  
      @param qId - Identifier of the variable.
    */
  async destroySessionVariableById(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DestroySessionVariableById",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Removes a transient variable.
  
  qSuccess is set to true if the operation is successful.
  
      @param qName - Name of the variable.
    */
  async destroySessionVariableByName(qName) {
    const params = {};
    params.qName = qName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DestroySessionVariableByName",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Creates a bookmark with softpatches.
    @experimental
    @param qObjectIdsToPatch - Add softpatches for this objects if available. If empty all softpatches are added to the bookmark.
    @param qProp - Properties for the object.
  */
  async createBookmarkEx(qObjectIdsToPatch, { creationDate = (/* @__PURE__ */ new Date()).toISOString(), ...rest } = {}) {
    const params = {};
    params.qProp = { creationDate, ...rest };
    params.qProp.qInfo = { qType: "bookmark" };
    if (qObjectIdsToPatch !== void 0) {
      params.qObjectIdsToPatch = qObjectIdsToPatch;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateBookmarkEx",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericBookmark(response, this.session, this.auth);
    return obj;
  }
  /**    Save a copy of an app with a different name.
  Can be used to save a session app as an ordinary app.
  
      @param qNewAppName - <Name of the saved app>
    */
  async saveAs(qNewAppName) {
    const params = {};
    params.qNewAppName = qNewAppName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SaveAs",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qNewAppId"];
    return response;
  }
  /**    Store current selection state temporarily.
  The temporary selection state will be stored for 30min by default if TTL parameter is not present or positive.
  StoreTempSelectionState method is only supported in SaaS Editions of Qlik Sense.
  
      @param qTTLOfTempState - Time to live in seconds for stored selection state
    */
  async storeTempSelectionState(qTTLOfTempState) {
    const params = {};
    if (qTTLOfTempState !== void 0) {
      params.qTTLOfTempState = qTTLOfTempState;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "StoreTempSelectionState",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"];
  }
  /**    Restore a temporary selection state identified by Id.
  RestoreTempSelectionState method is only supported in SaaS Editions of Qlik Sense.
  
      @param qId - Identifier of the temporary selection state
    */
  async restoreTempSelectionState(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "RestoreTempSelectionState",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Change the owner of a session app.
  Can be used by a privileged user when creating a session app to be consumed by another user.
  Only useful in environments where it is possible to reconnect to a session app, currently only in cloud deployments.
      @experimental
      @param qNewOwnerId - Identifier of the new app owner.
    */
  async changeSessionAppOwner(qNewOwnerId) {
    const params = {};
    params.qNewOwnerId = qNewOwnerId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ChangeSessionAppOwner",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Add a session app to a space.
  Can be used by a privileged user when creating a session app to be consumed by other users.
  Only useful in environments where it is possible to reconnect to a session app, currently only in cloud deployments.
      @experimental
      @param qSpaceId - Identifier of the new space.
    */
  async changeSessionAppSpace(qSpaceId) {
    const params = {};
    params.qSpaceId = qSpaceId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ChangeSessionAppSpace",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Returns profile data for a given table.
    @experimental
    @param qTableName - Name of the table
  */
  async getTableProfileData(qTableName) {
    const params = {};
    params.qTableName = qTableName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetTableProfileData",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qProfiling"];
  }
  /**    Returns the handle of a measure with a label.
  If multiple measures has the same label the first is returned.
  
      @param qLabel - is the label of the measure to be returned.
    */
  async getMeasureWithLabel(qLabel) {
    const params = {};
    params.qLabel = qLabel;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetMeasureWithLabel",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericMeasure(response, this.session, this.auth);
    return obj;
  }
  /**
    @experimental
    @param qOptions -
    @param qTerms -
    @param qPage -
  */
  async searchValues(qOptions, qTerms, { qMaxNbrFieldMatches = -1, ...rest2 } = {}) {
    const params = {};
    params.qOptions = qOptions;
    params.qTerms = qTerms;
    params.qPage = { qMaxNbrFieldMatches, ...rest2 };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SearchValues",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qResult"];
  }
  /**    Retrives any fields from an expression.
  
      @param qExpr - Expression to get fields from.
    */
  async getFieldsFromExpression(qExpr) {
    const params = {};
    params.qExpr = qExpr;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetFieldsFromExpression",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qFieldNames"];
    return response;
  }
  /**    Returns a list of resource ids (QRI) for fields that belongs to the datamodel.
  Key fields (that belongs to multiple tables), returns one resource identifier per table.
  GetFieldsResourceIds method is only supported in SaaS Editions of Qlik Sense.
  
      @param qFieldNames - List of fields names that resource ids should be returned from.
    */
  async getFieldsResourceIds(qFieldNames) {
    const params = {};
    params.qFieldNames = qFieldNames;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetFieldsResourceIds",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qFields"];
    return response.map((r) => r);
  }
  /**    Gets the current Backus-Naur Form (BNF) grammar of the Qlik chart expressions supported within a given App.
      @experimental
  
    */
  async getExpressionBNF() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetExpressionBNF",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"];
  }
  /**    Gets a string hash calculated from the current Backus-Naur Form (BNF) grammar  of the Qlik chart expressions supported within a given App.
      @experimental
  
    */
  async getExpressionBNFHash() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetExpressionBNFHash",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qBnfHash"];
    return response;
  }
  /**    Prohibit binary load of this app.
  An app with prohibit binary load set cannot be loaded binary. For the setting to have effect a save is required.
  
      @param qProhibit - True or false.
    */
  async setProhibitBinaryLoad(qProhibit) {
    const params = {};
    params.qProhibit = qProhibit;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetProhibitBinaryLoad",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Transform current app into an instance of the targeted mode
  
      @param qDstParameters - Attributes that should be set in the new app.
    */
  async transformApp(qDstParameters) {
    const params = {};
    params.qDstParameters = qDstParameters;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "TransformApp",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qResult"];
  }
  /**    Create temporary bookmark
  CreateTemporaryBookmark method is only supported in SaaS Editions of Qlik Sense.
      @experimental
      @param qOptions - Options for the temporary bookmark
      @param qObjectIdsToPatch - Add softpatches for this objects if available. If empty all softpatches are added to the bookmark. This is ignored if IncludePatches is false.
    */
  async createTemporaryBookmark(qOptions, qObjectIdsToPatch) {
    const params = {};
    params.qOptions = qOptions;
    if (qObjectIdsToPatch !== void 0) {
      params.qObjectIdsToPatch = qObjectIdsToPatch;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateTemporaryBookmark",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"];
  }
  /**    Apply temporary bookmark identified by Id.
  ApplyTemporaryBookmark method is only supported in SaaS Editions of Qlik Sense.
      @experimental
      @param qId - Identifier of the temporary selection state
    */
  async applyTemporaryBookmark(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ApplyTemporaryBookmark",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Gets script meta-data.
      @experimental
  
    */
  async getScriptMeta() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetScriptMeta",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qMeta"];
  }
  /**    Replace a bookmark. Optional inparams to change the original bookmarks properties, original are kept if left out.
    @experimental
    @param qId - Identifier of the bookmark.
    @param qIgnorePatches - Set to true to exclude patches from the bookmark. Default is false.
    @param qObjectIdsToPatch - Add softpatches for this objects if available. If empty all softpatches are added to the bookmark. Ignored if IgnorePatches is set to true.
  */
  async replaceBookmark(qId, qIgnorePatches, qObjectIdsToPatch) {
    const params = {};
    params.qId = qId;
    if (qIgnorePatches !== void 0) {
      params.qIgnorePatches = qIgnorePatches;
    }
    if (qObjectIdsToPatch !== void 0) {
      params.qObjectIdsToPatch = qObjectIdsToPatch;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ReplaceBookmark",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qReturn"];
  }
  /**    Commits the current script version so that any future changes will be part of a new version.
     @experimental
     @param qCommitMessage - Name of the version.
  Only applicable to QCS.
   */
  async commitScript(qCommitMessage) {
    const params = {};
    if (qCommitMessage !== void 0) {
      params.qCommitMessage = qCommitMessage;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CommitScript",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**
  
      @param qProp -
    */
  async createAppPropertiesObject({
    chartAnimations = true,
    qStateName = "$",
    theme = "horizon",
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      chartAnimations,
      qStateName,
      theme,
      ...rest
    };
    params.qProp.qInfo = { qType: "appprops" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /**
  
      @param qProp -
    */
  async createBookmarkObject({ creationDate = (/* @__PURE__ */ new Date()).toISOString(), ...rest } = {}) {
    const params = {};
    params.qProp = { creationDate, ...rest };
    params.qProp.qInfo = { qType: "bookmark" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /**
  
      @param qProp -
    */
  async createDimensionObject({ qDim: { coloring: { baseColor: { index = 6, ...restQDimColoringBaseColor } = { index: 6 }, ...restQDimColoring } = { baseColor: { index: 6 } }, ...restQDim } = { coloring: { baseColor: { index: 6 } } }, ...rest } = {}) {
    const params = {};
    params.qProp = { qDim: { coloring: { baseColor: { index, ...restQDimColoringBaseColor }, ...restQDimColoring }, ...restQDim }, ...rest };
    params.qProp.qInfo = { qType: "dimension" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /**
  
      @param qProp -
    */
  async createMasterobject({
    masterVersion = 0.95,
    qStateName = "$",
    showTitles = true,
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      masterVersion,
      qStateName,
      showTitles,
      ...rest
    };
    params.qProp.qInfo = { qType: "masterobject" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /**
  
      @param qProp -
    */
  async createMeasureObject({ qMeasure: { qNumFormat: { qType = "UNKNOWN", qnDec = 10, ...restQMeasureQNumFormat } = { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index = 6, ...restQMeasureColoringBaseColor } = { index: 6 }, gradient: { limitType = "percent", ...restQMeasureColoringGradient } = { limitType: "percent" }, ...restQMeasureColoring } = { baseColor: { index: 6 }, gradient: { limitType: "percent" } }, ...restQMeasure } = { qNumFormat: { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: 6 }, gradient: { limitType: "percent" } } }, ...rest } = {}) {
    const params = {};
    params.qProp = { qMeasure: { qNumFormat: { qType, qnDec, ...restQMeasureQNumFormat }, coloring: { baseColor: { index, ...restQMeasureColoringBaseColor }, gradient: { limitType, ...restQMeasureColoringGradient }, ...restQMeasureColoring }, ...restQMeasure }, ...rest };
    params.qProp.qInfo = { qType: "measure" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /**
  
      @param qProp -
    */
  async createSheet({
    columns = 24,
    gridResolution = "small",
    layoutOptions: { mobileLayout = "LIST", ...restLayoutOptions } = { mobileLayout: "LIST" },
    qChildListDef: { qData: { title = "/title", ...restQChildListDefQData } = { title: "/title" }, ...restQChildListDef } = { qData: { title: "/title" } },
    qStateName = "$",
    rank = 1,
    rows = 12,
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      columns,
      gridResolution,
      layoutOptions: { mobileLayout, ...restLayoutOptions },
      qChildListDef: { qData: { title, ...restQChildListDefQData }, ...restQChildListDef },
      qStateName,
      rank,
      rows,
      ...rest
    };
    params.qProp.qInfo = { qType: "sheet" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /**
  
      @param qProp -
    */
  async createVariableObject({ qNumberPresentation: { qType = "UNKNOWN", qnDec = 10, ...restQNumberPresentation } = { qType: "UNKNOWN", qnDec: 10 }, ...rest } = {}) {
    const params = {};
    params.qProp = { qNumberPresentation: { qType, qnDec, ...restQNumberPresentation }, ...rest };
    params.qProp.qInfo = { qType: "variable" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /**
    @param qProp - AppPropertiesList
    */
  async getAppPropertiesObject({
    qAppObjectListDef: {
      qData: {
        chartAnimations = "/chartAnimations",
        disableCellNavMenu = "/disableCellNavMenu",
        rtl = "/rtl",
        sheetLogoPosition = "/sheetLogoPosition",
        sheetLogoThumbnail = "/sheetLogoThumbnail",
        sheetTitleBgColor = "/sheetTitleBgColor",
        sheetTitleColor = "/sheetTitleColor",
        sheetTitleGradientColor = "/sheetTitleGradientColor",
        theme = "/theme",
        ...restQAppObjectListDefQData
      } = {
        chartAnimations: "/chartAnimations",
        disableCellNavMenu: "/disableCellNavMenu",
        rtl: "/rtl",
        sheetLogoPosition: "/sheetLogoPosition",
        sheetLogoThumbnail: "/sheetLogoThumbnail",
        sheetTitleBgColor: "/sheetTitleBgColor",
        sheetTitleColor: "/sheetTitleColor",
        sheetTitleGradientColor: "/sheetTitleGradientColor",
        theme: "/theme"
      },
      qType = "appprops",
      ...restQAppObjectListDef
    } = {
      qData: {
        chartAnimations: "/chartAnimations",
        disableCellNavMenu: "/disableCellNavMenu",
        rtl: "/rtl",
        sheetLogoPosition: "/sheetLogoPosition",
        sheetLogoThumbnail: "/sheetLogoThumbnail",
        sheetTitleBgColor: "/sheetTitleBgColor",
        sheetTitleColor: "/sheetTitleColor",
        sheetTitleGradientColor: "/sheetTitleGradientColor",
        theme: "/theme"
      },
      qType: "appprops"
    },
    qStateName = "$",
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      qAppObjectListDef: {
        qData: {
          chartAnimations,
          disableCellNavMenu,
          rtl,
          sheetLogoPosition,
          sheetLogoThumbnail,
          sheetTitleBgColor,
          sheetTitleColor,
          sheetTitleGradientColor,
          theme,
          ...restQAppObjectListDefQData
        },
        qType,
        ...restQAppObjectListDef
      },
      qStateName,
      ...rest
    };
    params.qProp.qInfo = { qType: "AppPropsList" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const sessionObjectRawResponse = await this.session.send({
      method: "CreateSessionObject",
      handle: this.qHandle || -1,
      params
    });
    const response = sessionObjectRawResponse["result"]["qReturn"];
    return new GenericObject(response, this.session, this.auth);
  }
  /**
    @param qProp - AppPropertiesList
    */
  async getAppPropertiesObjectLayout({
    qAppObjectListDef: {
      qData: {
        chartAnimations = "/chartAnimations",
        disableCellNavMenu = "/disableCellNavMenu",
        rtl = "/rtl",
        sheetLogoPosition = "/sheetLogoPosition",
        sheetLogoThumbnail = "/sheetLogoThumbnail",
        sheetTitleBgColor = "/sheetTitleBgColor",
        sheetTitleColor = "/sheetTitleColor",
        sheetTitleGradientColor = "/sheetTitleGradientColor",
        theme = "/theme",
        ...restQAppObjectListDefQData
      } = {
        chartAnimations: "/chartAnimations",
        disableCellNavMenu: "/disableCellNavMenu",
        rtl: "/rtl",
        sheetLogoPosition: "/sheetLogoPosition",
        sheetLogoThumbnail: "/sheetLogoThumbnail",
        sheetTitleBgColor: "/sheetTitleBgColor",
        sheetTitleColor: "/sheetTitleColor",
        sheetTitleGradientColor: "/sheetTitleGradientColor",
        theme: "/theme"
      },
      qType = "appprops",
      ...restQAppObjectListDef
    } = {
      qData: {
        chartAnimations: "/chartAnimations",
        disableCellNavMenu: "/disableCellNavMenu",
        rtl: "/rtl",
        sheetLogoPosition: "/sheetLogoPosition",
        sheetLogoThumbnail: "/sheetLogoThumbnail",
        sheetTitleBgColor: "/sheetTitleBgColor",
        sheetTitleColor: "/sheetTitleColor",
        sheetTitleGradientColor: "/sheetTitleGradientColor",
        theme: "/theme"
      },
      qType: "appprops"
    },
    qStateName = "$",
    ...rest
  } = {}) {
    const obj = await this.getAppPropertiesObject({
      qAppObjectListDef: {
        qData: {
          chartAnimations,
          disableCellNavMenu,
          rtl,
          sheetLogoPosition,
          sheetLogoThumbnail,
          sheetTitleBgColor,
          sheetTitleColor,
          sheetTitleGradientColor,
          theme,
          ...restQAppObjectListDefQData
        },
        qType,
        ...restQAppObjectListDef
      },
      qStateName,
      ...rest
    });
    const layout = await obj.getLayout();
    return layout.qAppObjectList.qItems;
  }
  /**
    @param qProp - BookmarkList
    */
  async getBookmarksListObject({
    qBookmarkListDef: {
      qData: {
        creationDate = "/creationDate",
        description = "/qMetaDef/description",
        selectionFields = "/selectionFields",
        sheetId = "/sheetId",
        title = "/qMetaDef/title",
        ...restQBookmarkListDefQData
      } = {
        creationDate: "/creationDate",
        description: "/qMetaDef/description",
        selectionFields: "/selectionFields",
        sheetId: "/sheetId",
        title: "/qMetaDef/title"
      },
      qType = "bookmark",
      ...restQBookmarkListDef
    } = {
      qData: {
        creationDate: "/creationDate",
        description: "/qMetaDef/description",
        selectionFields: "/selectionFields",
        sheetId: "/sheetId",
        title: "/qMetaDef/title"
      },
      qType: "bookmark"
    },
    qStateName = "$",
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      qBookmarkListDef: {
        qData: {
          creationDate,
          description,
          selectionFields,
          sheetId,
          title,
          ...restQBookmarkListDefQData
        },
        qType,
        ...restQBookmarkListDef
      },
      qStateName,
      ...rest
    };
    params.qProp.qInfo = { qType: "BookmarkList" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const sessionObjectRawResponse = await this.session.send({
      method: "CreateSessionObject",
      handle: this.qHandle || -1,
      params
    });
    const response = sessionObjectRawResponse["result"]["qReturn"];
    return new GenericObject(response, this.session, this.auth);
  }
  /**
    @param qProp - BookmarkList
    */
  async getBookmarksList({
    qBookmarkListDef: {
      qData: {
        creationDate = "/creationDate",
        description = "/qMetaDef/description",
        selectionFields = "/selectionFields",
        sheetId = "/sheetId",
        title = "/qMetaDef/title",
        ...restQBookmarkListDefQData
      } = {
        creationDate: "/creationDate",
        description: "/qMetaDef/description",
        selectionFields: "/selectionFields",
        sheetId: "/sheetId",
        title: "/qMetaDef/title"
      },
      qType = "bookmark",
      ...restQBookmarkListDef
    } = {
      qData: {
        creationDate: "/creationDate",
        description: "/qMetaDef/description",
        selectionFields: "/selectionFields",
        sheetId: "/sheetId",
        title: "/qMetaDef/title"
      },
      qType: "bookmark"
    },
    qStateName = "$",
    ...rest
  } = {}) {
    const obj = await this.getBookmarksListObject({
      qBookmarkListDef: {
        qData: {
          creationDate,
          description,
          selectionFields,
          sheetId,
          title,
          ...restQBookmarkListDefQData
        },
        qType,
        ...restQBookmarkListDef
      },
      qStateName,
      ...rest
    });
    const layout = await obj.getLayout();
    return layout.qBookmarkList.qItems;
  }
  /**
    @param qProp - GenericCurrentSelectionsProperties
    */
  async getCurrentSelectionsObject({
    qSelectionObjectDef: { qStateName = "$", ...restQSelectionObjectDef } = { qStateName: "$" },
    qStateName: qStateName2 = "$",
    qType = "CurrentSelection",
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      qSelectionObjectDef: { qStateName, ...restQSelectionObjectDef },
      qStateName: qStateName2,
      qType,
      ...rest
    };
    params.qProp.qInfo = { qType: "CurrentSelections" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const sessionObjectRawResponse = await this.session.send({
      method: "CreateSessionObject",
      handle: this.qHandle || -1,
      params
    });
    const response = sessionObjectRawResponse["result"]["qReturn"];
    return new GenericObject(response, this.session, this.auth);
  }
  /**
    @param qProp - GenericCurrentSelectionsProperties
    */
  async getCurrentSelections({
    qSelectionObjectDef: { qStateName = "$", ...restQSelectionObjectDef } = { qStateName: "$" },
    qStateName: qStateName2 = "$",
    qType = "CurrentSelection",
    ...rest
  } = {}) {
    const obj = await this.getCurrentSelectionsObject({
      qSelectionObjectDef: { qStateName, ...restQSelectionObjectDef },
      qStateName: qStateName2,
      qType,
      ...rest
    });
    const layout = await obj.getLayout();
    return layout.qSelectionObject;
  }
  /**
    @param qProp - DimensionList
    */
  async getDimensionsObject({
    qDimensionListDef: {
      qData: {
        grouping = "/qDim/grouping",
        info = "/qDimInfos",
        labelExpression = "/qDim/labelExpression",
        tags = "/qMetaDef/tags",
        title = "/qMetaDef/title",
        ...restQDimensionListDefQData
      } = {
        grouping: "/qDim/grouping",
        info: "/qDimInfos",
        labelExpression: "/qDim/labelExpression",
        tags: "/qMetaDef/tags",
        title: "/qMetaDef/title"
      },
      qType = "dimension",
      ...restQDimensionListDef
    } = {
      qData: {
        grouping: "/qDim/grouping",
        info: "/qDimInfos",
        labelExpression: "/qDim/labelExpression",
        tags: "/qMetaDef/tags",
        title: "/qMetaDef/title"
      },
      qType: "dimension"
    },
    qStateName = "$",
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      qDimensionListDef: {
        qData: {
          grouping,
          info,
          labelExpression,
          tags,
          title,
          ...restQDimensionListDefQData
        },
        qType,
        ...restQDimensionListDef
      },
      qStateName,
      ...rest
    };
    params.qProp.qInfo = { qType: "DimensionList" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const sessionObjectRawResponse = await this.session.send({
      method: "CreateSessionObject",
      handle: this.qHandle || -1,
      params
    });
    const response = sessionObjectRawResponse["result"]["qReturn"];
    return new GenericObject(response, this.session, this.auth);
  }
  /**
    @param qProp - DimensionList
    */
  async getDimensions({
    qDimensionListDef: {
      qData: {
        grouping = "/qDim/grouping",
        info = "/qDimInfos",
        labelExpression = "/qDim/labelExpression",
        tags = "/qMetaDef/tags",
        title = "/qMetaDef/title",
        ...restQDimensionListDefQData
      } = {
        grouping: "/qDim/grouping",
        info: "/qDimInfos",
        labelExpression: "/qDim/labelExpression",
        tags: "/qMetaDef/tags",
        title: "/qMetaDef/title"
      },
      qType = "dimension",
      ...restQDimensionListDef
    } = {
      qData: {
        grouping: "/qDim/grouping",
        info: "/qDimInfos",
        labelExpression: "/qDim/labelExpression",
        tags: "/qMetaDef/tags",
        title: "/qMetaDef/title"
      },
      qType: "dimension"
    },
    qStateName = "$",
    ...rest
  } = {}) {
    const obj = await this.getDimensionsObject({
      qDimensionListDef: {
        qData: {
          grouping,
          info,
          labelExpression,
          tags,
          title,
          ...restQDimensionListDefQData
        },
        qType,
        ...restQDimensionListDef
      },
      qStateName,
      ...rest
    });
    const layout = await obj.getLayout();
    return layout.qDimensionList.qItems;
  }
  /**
    @param qProp - FieldList
    */
  async getFieldsObject({
    qFieldListDef: {
      qShowDerivedFields = true,
      qShowSemantic = true,
      qShowSrcTables = true,
      ...restQFieldListDef
    } = { qShowDerivedFields: true, qShowSemantic: true, qShowSrcTables: true },
    qStateName = "$",
    qType = "FieldList",
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      qFieldListDef: {
        qShowDerivedFields,
        qShowSemantic,
        qShowSrcTables,
        ...restQFieldListDef
      },
      qStateName,
      qType,
      ...rest
    };
    params.qProp.qInfo = { qType: "FieldList" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const sessionObjectRawResponse = await this.session.send({
      method: "CreateSessionObject",
      handle: this.qHandle || -1,
      params
    });
    const response = sessionObjectRawResponse["result"]["qReturn"];
    return new GenericObject(response, this.session, this.auth);
  }
  /**
    @param qProp - FieldList
    */
  async getFields({
    qFieldListDef: {
      qShowDerivedFields = true,
      qShowSemantic = true,
      qShowSrcTables = true,
      ...restQFieldListDef
    } = { qShowDerivedFields: true, qShowSemantic: true, qShowSrcTables: true },
    qStateName = "$",
    qType = "FieldList",
    ...rest
  } = {}) {
    const obj = await this.getFieldsObject({
      qFieldListDef: {
        qShowDerivedFields,
        qShowSemantic,
        qShowSrcTables,
        ...restQFieldListDef
      },
      qStateName,
      qType,
      ...rest
    });
    const layout = await obj.getLayout();
    return layout.qFieldList.qItems;
  }
  /**
    @param qProp - MasterobjectList
    */
  async getMasterobjectsObject({
    qAppObjectListDef: {
      qData: {
        labelExpression = "/labelExpression",
        name = "/qMetaDef/title",
        tags = "/qMetaDef/tags",
        visualization = "/visualization",
        ...restQAppObjectListDefQData
      } = {
        labelExpression: "/labelExpression",
        name: "/qMetaDef/title",
        tags: "/qMetaDef/tags",
        visualization: "/visualization"
      },
      qType = "masterobject",
      ...restQAppObjectListDef
    } = {
      qData: {
        labelExpression: "/labelExpression",
        name: "/qMetaDef/title",
        tags: "/qMetaDef/tags",
        visualization: "/visualization"
      },
      qType: "masterobject"
    },
    qStateName = "$",
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      qAppObjectListDef: {
        qData: {
          labelExpression,
          name,
          tags,
          visualization,
          ...restQAppObjectListDefQData
        },
        qType,
        ...restQAppObjectListDef
      },
      qStateName,
      ...rest
    };
    params.qProp.qInfo = { qType: "MasterObjectList" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const sessionObjectRawResponse = await this.session.send({
      method: "CreateSessionObject",
      handle: this.qHandle || -1,
      params
    });
    const response = sessionObjectRawResponse["result"]["qReturn"];
    return new GenericObject(response, this.session, this.auth);
  }
  /**
    @param qProp - MasterobjectList
    */
  async getMasterobjects({
    qAppObjectListDef: {
      qData: {
        labelExpression = "/labelExpression",
        name = "/qMetaDef/title",
        tags = "/qMetaDef/tags",
        visualization = "/visualization",
        ...restQAppObjectListDefQData
      } = {
        labelExpression: "/labelExpression",
        name: "/qMetaDef/title",
        tags: "/qMetaDef/tags",
        visualization: "/visualization"
      },
      qType = "masterobject",
      ...restQAppObjectListDef
    } = {
      qData: {
        labelExpression: "/labelExpression",
        name: "/qMetaDef/title",
        tags: "/qMetaDef/tags",
        visualization: "/visualization"
      },
      qType: "masterobject"
    },
    qStateName = "$",
    ...rest
  } = {}) {
    const obj = await this.getMasterobjectsObject({
      qAppObjectListDef: {
        qData: {
          labelExpression,
          name,
          tags,
          visualization,
          ...restQAppObjectListDefQData
        },
        qType,
        ...restQAppObjectListDef
      },
      qStateName,
      ...rest
    });
    const layout = await obj.getLayout();
    return layout.qAppObjectList.qItems;
  }
  /**
    @param qProp - MeasureList
    */
  async getMeasuresObject({
    qMeasureListDef: {
      qData: {
        labelExpression = "/qMeasure/qLabelExpression",
        tags = "/qMetaDef/tags",
        title = "/qMetaDef/title",
        ...restQMeasureListDefQData
      } = { labelExpression: "/qMeasure/qLabelExpression", tags: "/qMetaDef/tags", title: "/qMetaDef/title" },
      qType = "measure",
      ...restQMeasureListDef
    } = { qData: { labelExpression: "/qMeasure/qLabelExpression", tags: "/qMetaDef/tags", title: "/qMetaDef/title" }, qType: "measure" },
    qStateName = "$",
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      qMeasureListDef: {
        qData: {
          labelExpression,
          tags,
          title,
          ...restQMeasureListDefQData
        },
        qType,
        ...restQMeasureListDef
      },
      qStateName,
      ...rest
    };
    params.qProp.qInfo = { qType: "MeasureList" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const sessionObjectRawResponse = await this.session.send({
      method: "CreateSessionObject",
      handle: this.qHandle || -1,
      params
    });
    const response = sessionObjectRawResponse["result"]["qReturn"];
    return new GenericObject(response, this.session, this.auth);
  }
  /**
    @param qProp - MeasureList
    */
  async getMeasures({
    qMeasureListDef: {
      qData: {
        labelExpression = "/qMeasure/qLabelExpression",
        tags = "/qMetaDef/tags",
        title = "/qMetaDef/title",
        ...restQMeasureListDefQData
      } = { labelExpression: "/qMeasure/qLabelExpression", tags: "/qMetaDef/tags", title: "/qMetaDef/title" },
      qType = "measure",
      ...restQMeasureListDef
    } = { qData: { labelExpression: "/qMeasure/qLabelExpression", tags: "/qMetaDef/tags", title: "/qMetaDef/title" }, qType: "measure" },
    qStateName = "$",
    ...rest
  } = {}) {
    const obj = await this.getMeasuresObject({
      qMeasureListDef: {
        qData: {
          labelExpression,
          tags,
          title,
          ...restQMeasureListDefQData
        },
        qType,
        ...restQMeasureListDef
      },
      qStateName,
      ...rest
    });
    const layout = await obj.getLayout();
    return layout.qMeasureList.qItems;
  }
  /**
    @param qProp - SheetList
    */
  async getSheetsObject({
    qAppObjectListDef: {
      qData: {
        cells = "/cells",
        columns = "/columns",
        description = "/qMetaDef/description",
        descriptionExpression = "/qMetaDef/descriptionExpression",
        labelExpression = "/labelExpression",
        rank = "/rank",
        rows = "/rows",
        showCondition = "/showCondition",
        thumbnail = "/qMetaDef/thumbnail",
        title = "/qMetaDef/title",
        ...restQAppObjectListDefQData
      } = {
        cells: "/cells",
        columns: "/columns",
        description: "/qMetaDef/description",
        descriptionExpression: "/qMetaDef/descriptionExpression",
        labelExpression: "/labelExpression",
        rank: "/rank",
        rows: "/rows",
        showCondition: "/showCondition",
        thumbnail: "/qMetaDef/thumbnail",
        title: "/qMetaDef/title"
      },
      qType = "sheet",
      ...restQAppObjectListDef
    } = {
      qData: {
        cells: "/cells",
        columns: "/columns",
        description: "/qMetaDef/description",
        descriptionExpression: "/qMetaDef/descriptionExpression",
        labelExpression: "/labelExpression",
        rank: "/rank",
        rows: "/rows",
        showCondition: "/showCondition",
        thumbnail: "/qMetaDef/thumbnail",
        title: "/qMetaDef/title"
      },
      qType: "sheet"
    },
    qStateName = "$",
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      qAppObjectListDef: {
        qData: {
          cells,
          columns,
          description,
          descriptionExpression,
          labelExpression,
          rank,
          rows,
          showCondition,
          thumbnail,
          title,
          ...restQAppObjectListDefQData
        },
        qType,
        ...restQAppObjectListDef
      },
      qStateName,
      ...rest
    };
    params.qProp.qInfo = { qType: "SheetList" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const sessionObjectRawResponse = await this.session.send({
      method: "CreateSessionObject",
      handle: this.qHandle || -1,
      params
    });
    const response = sessionObjectRawResponse["result"]["qReturn"];
    return new GenericObject(response, this.session, this.auth);
  }
  /**
    @param qProp - SheetList
    */
  async getSheets({
    qAppObjectListDef: {
      qData: {
        cells = "/cells",
        columns = "/columns",
        description = "/qMetaDef/description",
        descriptionExpression = "/qMetaDef/descriptionExpression",
        labelExpression = "/labelExpression",
        rank = "/rank",
        rows = "/rows",
        showCondition = "/showCondition",
        thumbnail = "/qMetaDef/thumbnail",
        title = "/qMetaDef/title",
        ...restQAppObjectListDefQData
      } = {
        cells: "/cells",
        columns: "/columns",
        description: "/qMetaDef/description",
        descriptionExpression: "/qMetaDef/descriptionExpression",
        labelExpression: "/labelExpression",
        rank: "/rank",
        rows: "/rows",
        showCondition: "/showCondition",
        thumbnail: "/qMetaDef/thumbnail",
        title: "/qMetaDef/title"
      },
      qType = "sheet",
      ...restQAppObjectListDef
    } = {
      qData: {
        cells: "/cells",
        columns: "/columns",
        description: "/qMetaDef/description",
        descriptionExpression: "/qMetaDef/descriptionExpression",
        labelExpression: "/labelExpression",
        rank: "/rank",
        rows: "/rows",
        showCondition: "/showCondition",
        thumbnail: "/qMetaDef/thumbnail",
        title: "/qMetaDef/title"
      },
      qType: "sheet"
    },
    qStateName = "$",
    ...rest
  } = {}) {
    const obj = await this.getSheetsObject({
      qAppObjectListDef: {
        qData: {
          cells,
          columns,
          description,
          descriptionExpression,
          labelExpression,
          rank,
          rows,
          showCondition,
          thumbnail,
          title,
          ...restQAppObjectListDefQData
        },
        qType,
        ...restQAppObjectListDef
      },
      qStateName,
      ...rest
    });
    const layout = await obj.getLayout();
    return layout.qAppObjectList.qItems;
  }
  /**
    @param qProp - VariableList
    */
  async getVariablesListObject({
    qStateName = "$",
    qVariableListDef: {
      qData: { tags = "/tags", ...restQVariableListDefQData } = { tags: "/tags" },
      qShowConfig = true,
      qShowReserved = true,
      qType = "variable",
      ...restQVariableListDef
    } = {
      qData: { tags: "/tags" },
      qShowConfig: true,
      qShowReserved: true,
      qType: "variable"
    },
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      qStateName,
      qVariableListDef: {
        qData: { tags, ...restQVariableListDefQData },
        qShowConfig,
        qShowReserved,
        qType,
        ...restQVariableListDef
      },
      ...rest
    };
    params.qProp.qInfo = { qType: "VariableList" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const sessionObjectRawResponse = await this.session.send({
      method: "CreateSessionObject",
      handle: this.qHandle || -1,
      params
    });
    const response = sessionObjectRawResponse["result"]["qReturn"];
    return new GenericObject(response, this.session, this.auth);
  }
  /**
    @param qProp - VariableList
    */
  async getVariablesList({
    qStateName = "$",
    qVariableListDef: {
      qData: { tags = "/tags", ...restQVariableListDefQData } = { tags: "/tags" },
      qShowConfig = true,
      qShowReserved = true,
      qType = "variable",
      ...restQVariableListDef
    } = {
      qData: { tags: "/tags" },
      qShowConfig: true,
      qShowReserved: true,
      qType: "variable"
    },
    ...rest
  } = {}) {
    const obj = await this.getVariablesListObject({
      qStateName,
      qVariableListDef: {
        qData: { tags, ...restQVariableListDefQData },
        qShowConfig,
        qShowReserved,
        qType,
        ...restQVariableListDef
      },
      ...rest
    });
    const layout = await obj.getLayout();
    return layout.qVariableList.qItems;
  }
  /**    Returns the type of the app object and the corresponding handle.
  
      @param qId - Identifier of the object to retrieve.
    */
  async getMasterobject(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /**    Returns the type of the app object and the corresponding handle.
  
      @param qId - Identifier of the object to retrieve.
    */
  async getSheet(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /** Establishes the websocket against the configured URL. Eventually resolved with
  * the QIX global interface when the connection has been established.
  *
  * @param appConfig.delta - Set to false to disable the use of the bandwidth-reducing delta protocol.
  * @example
  * ```js
  * await app.open();
  * const script = 'Load RecNo() as N autogenerate(100);';
  * await app.setScript(script);
  * await app.doReload();
  * ```
  */
  async open(sessionConfig = { delta: true }) {
    this.session = await this.auth.rpc(this?.attributes.id, { delta: sessionConfig.delta });
    this.global = new Global({ qType: "global", qHandle: -1 }, this.session, this.auth);
    await this.session.open();
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const app = await this.session.send({
      method: "OpenDoc",
      handle: -1,
      params: [this.attributes.id]
    });
    this.qHandle = app.result.qReturn.qHandle;
    this.qGenericId = app.result.qReturn.qGenericId;
    this.qType = app.result.qReturn.qType;
    this.id = this.qGenericId;
    this.handle = this.qHandle;
    this.type = this.qType;
    this.genericType = app.result?.qReturn?.qGenericType;
    return this.session;
  }
  /** Closes the websocket and cleans up internal caches, also triggers the closed
  * event on all generated APIs. Eventually resolved when the websocket has been closed.
  *
  * @example
  * ```js
  * await app.close();
  * ```
  */
  async close() {
    return this.session.close();
  }
  on(event, listener) {
    if (!this.session.eventListeners) {
      this.session.eventListeners = {
        [this.qHandle]: {
          [event]: [listener]
        }
      };
    } else {
      if (!this.session.eventListeners[this.qHandle]) {
        this.session.eventListeners[this.qHandle] = {};
      }
      if (this.session.eventListeners[this.qHandle][event]) {
        this.session.eventListeners[this.qHandle][event].push(listener);
      } else {
        this.session.eventListeners[this.qHandle][event] = [listener];
      }
    }
  }
  once(event, listener) {
    let called = false;
    this.on(event, (...args) => {
      if (!called) {
        called = true;
        listener(...args);
      }
    });
  }
}
class Field {
  constructor({
    qGenericId,
    qGenericType,
    qHandle,
    qType,
    ...rest
  }, session, auth) {
    this.auth = auth;
    this.session = session;
    this.qGenericId = qGenericId;
    this.qGenericType = qGenericType;
    this.qHandle = qHandle;
    this.qType = qType;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
  /**    Retrieves the number of distinct values in a field.
  
    */
  async getCardinal() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetCardinal",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Returns the AND mode status of a field.
  
    */
  async getAndMode() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetAndMode",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Selects some values in a field, by entering the values to select.
  
      @param qFieldValues - List of the values to select.
      @param qToggleMode - The default value is false.
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
    */
  async selectValues(qFieldValues, qToggleMode, qSoftLock) {
    const params = {};
    params.qFieldValues = qFieldValues;
    if (qToggleMode !== void 0) {
      params.qToggleMode = qToggleMode;
    }
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectValues",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Selects field values matching a search string.
  
      @param qMatch - String to search for.
  Can contain wild cards or numeric search criteria.
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
      @param qExcludedValuesMode - Include excluded values in search.
    */
  async select(qMatch, qSoftLock, qExcludedValuesMode) {
    const params = {};
    params.qMatch = qMatch;
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (qExcludedValuesMode !== void 0) {
      params.qExcludedValuesMode = qExcludedValuesMode;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Select",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Toggle selects field values matching a search string.
  
      @param qMatch - String to search for.
  Can contain wild cards or numeric search criteria.
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
      @param qExcludedValuesMode - Include excluded values in search.
    */
  async toggleSelect(qMatch, qSoftLock, qExcludedValuesMode) {
    const params = {};
    params.qMatch = qMatch;
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (qExcludedValuesMode !== void 0) {
      params.qExcludedValuesMode = qExcludedValuesMode;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ToggleSelect",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Maintains the selections in the current field while clearing the selections in the other fields.
  
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
    */
  async clearAllButThis(qSoftLock) {
    const params = {};
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ClearAllButThis",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Selects all possible values in a specific field.
  
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
    */
  async selectPossible(qSoftLock) {
    const params = {};
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectPossible",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Inverts the current selections.
  
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
    */
  async selectExcluded(qSoftLock) {
    const params = {};
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectExcluded",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Selects all values of a field. Excluded values are also selected.
  
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
    */
  async selectAll(qSoftLock) {
    const params = {};
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectAll",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Locks all selected values of a specific field.
  
    */
  async lock() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Lock",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Unlocks all selected values of a specific field if the target (or handle ) is a field.
  
    */
  async unlock() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Unlock",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Gets the properties of a field.
  
  The property OneAndOnlyOne is set to true if one and only value has been selected in the field prior setting the property.
  
    */
  async getNxProperties() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetNxProperties",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qProperties"];
  }
  /**    Sets some properties to a field.
  
      @param qProperties - Information about the properties of the field.
    */
  async setNxProperties(qProperties) {
    const params = {};
    params.qProperties = qProperties;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetNxProperties",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Sets a field in the AND mode.
  
      @param qAndMode - Specifies if the AND mode applies to the field.
  Set this parameter to true to enter the AND mode.
    */
  async setAndMode(qAndMode) {
    const params = {};
    params.qAndMode = qAndMode;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetAndMode",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Selects all alternatives values in a specific field.
  In a field that contains at least one selected value, the values that are neither selected nor excluded are alternatives values.
  
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
    */
  async selectAlternative(qSoftLock) {
    const params = {};
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectAlternative",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Selects some values in a field, by entering the element numbers related to the values to select.
  
      @param qValues - Indexes (or element numbers) of the values to select.
      @param qToggleMode - Set to true to keep any selections present in the list object.
  If this parameter is set to false, selections made before accepting the list object search become alternative.
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
    */
  async lowLevelSelect(qValues, qToggleMode, qSoftLock) {
    const params = {};
    params.qValues = qValues;
    params.qToggleMode = qToggleMode;
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "LowLevelSelect",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Clears the selections in a specific field.
  
    */
  async clear() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Clear",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  on(event, listener) {
    if (!this.session.eventListeners) {
      this.session.eventListeners = {
        [this.qHandle]: {
          [event]: [listener]
        }
      };
    } else {
      if (!this.session.eventListeners[this.qHandle]) {
        this.session.eventListeners[this.qHandle] = {};
      }
      if (this.session.eventListeners[this.qHandle][event]) {
        this.session.eventListeners[this.qHandle][event].push(listener);
      } else {
        this.session.eventListeners[this.qHandle][event] = [listener];
      }
    }
  }
  once(event, listener) {
    let called = false;
    this.on(event, (...args) => {
      if (!called) {
        called = true;
        listener(...args);
      }
    });
  }
}
class GenericBookmark {
  constructor({
    qGenericId,
    qGenericType,
    qHandle,
    qType,
    ...rest
  }, session, auth) {
    this.auth = auth;
    this.session = session;
    this.qGenericId = qGenericId;
    this.qGenericType = qGenericType;
    this.qHandle = qHandle;
    this.qType = qType;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
  /**    Retrieves the values of a field.
  
   Fieldvalue:
  | Name       | Description                                                                                  | Type    |
  |------------|----------------------------------------------------------------------------------------------|---------|
  | qText      | Text related to the field value.                                                             | String  |
  | qIsNumeric | Is set to true if the value is a numeric.  Default is false.                             | Boolean |
  | qNumber    | Numeric value of the field.  This parameter is displayed if _qIsNumeric_ is set to true. | Double  |
  
      @param qField - Name of the field.
      @param qGetExcludedValues - If set to true, only excluded values are returned.
      @param qDataPage - Range of returned values.
    */
  async getFieldValues(qField, qGetExcludedValues, qDataPage) {
    const params = {};
    params.qField = qField;
    params.qGetExcludedValues = qGetExcludedValues;
    params.qDataPage = qDataPage;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetFieldValues",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qFieldValues"];
    return response.map((r) => r);
  }
  /**    Evaluates an object and displays its properties including the dynamic properties.
  If the member delta is set to true in the request object, only the delta is evaluated.
  
    */
  async getLayout() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetLayout",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qLayout"];
  }
  /**    Applies a patch to the properties of an object. Allows an update to some of the properties. It should not be possible to patch "/qInfo/qId",
  and it will be forbidden in the near future.
  Applying a patch takes less time than resetting all the properties.
  
      @param qPatches - Array of patches.
    */
  async applyPatches(qPatches) {
    const params = {};
    params.qPatches = qPatches;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ApplyPatches",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Sets some properties for a bookmark.
  
      @param qProp - Information about the bookmark.
    */
  async setProperties({ creationDate = (/* @__PURE__ */ new Date()).toISOString(), ...rest } = {}) {
    const params = {};
    params.qProp = { creationDate, ...rest };
    params.qProp.qInfo = { qType: "bookmark" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetProperties",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Shows the properties of an object.
  If the member delta is set to true in the request object, only the delta is retrieved.
  The following is always returned in the output:
  
    */
  async getProperties() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetProperties",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qProp"];
  }
  /**    Returns:
  
  • The type of the object.
  
  • The identifier of the object.
  
    */
  async getInfo() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetInfo",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qInfo"];
  }
  /**    Applies a bookmark.
  
  The operation is successful if qSuccess is set to true.
  
    */
  async apply() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Apply",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Applies a bookmark and verify result dataset against originally selected values.
  
  The operation is successful if qApplySuccess is set to true. qWarnings lists state and field with unmatching values
      @experimental
  
    */
  async applyAndVerify() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ApplyAndVerify",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qResult"];
  }
  /**    Publishes a bookmark.
  This operation is not applicable for Qlik Sense Desktop.
  
    */
  async publish() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Publish",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Unpublishes a bookmark.
  This operation is not applicable for Qlik Sense Desktop.
  
    */
  async unPublish() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "UnPublish",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Adds the generic bookmark to the list of approved objects
  This operation is possible only in Qlik Sense Enterprise.
  
    */
  async approve() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Approve",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Removes the generic bookmark from the list of approved objects
  This operation is possible only in Qlik Sense Enterprise.
  
    */
  async unApprove() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "UnApprove",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  on(event, listener) {
    if (!this.session.eventListeners) {
      this.session.eventListeners = {
        [this.qHandle]: {
          [event]: [listener]
        }
      };
    } else {
      if (!this.session.eventListeners[this.qHandle]) {
        this.session.eventListeners[this.qHandle] = {};
      }
      if (this.session.eventListeners[this.qHandle][event]) {
        this.session.eventListeners[this.qHandle][event].push(listener);
      } else {
        this.session.eventListeners[this.qHandle][event] = [listener];
      }
    }
  }
  once(event, listener) {
    let called = false;
    this.on(event, (...args) => {
      if (!called) {
        called = true;
        listener(...args);
      }
    });
  }
}
class GenericDimension {
  constructor({
    qGenericId,
    qGenericType,
    qHandle,
    qType,
    ...rest
  }, session, auth) {
    this.auth = auth;
    this.session = session;
    this.qGenericId = qGenericId;
    this.qGenericType = qGenericType;
    this.qHandle = qHandle;
    this.qType = qType;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
  /**    Evaluates a dimension and displays its properties, including the dynamic properties.
  
    */
  async getLayout() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetLayout",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qLayout"];
  }
  /**    Applies a patch to the properties of an object. Allows an update to some of the properties. It should not be possible to patch "/qInfo/qId",
  and it will be forbidden in the near future.
  Applying a patch takes less time than resetting all the properties.
  
      @param qPatches - Array of patches.
    */
  async applyPatches(qPatches) {
    const params = {};
    params.qPatches = qPatches;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ApplyPatches",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Sets some properties for a dimension.
  
      @param qProp - Information about the dimension.
    */
  async setProperties({ qDim: { coloring: { baseColor: { index = 6, ...restQDimColoringBaseColor } = { index: 6 }, ...restQDimColoring } = { baseColor: { index: 6 } }, ...restQDim } = { coloring: { baseColor: { index: 6 } } }, ...rest } = {}) {
    const params = {};
    params.qProp = { qDim: { coloring: { baseColor: { index, ...restQDimColoringBaseColor }, ...restQDimColoring }, ...restQDim }, ...rest };
    params.qProp.qInfo = { qType: "dimension" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetProperties",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Shows the properties of an object.
  Returns the identifier and the definition of the dimension.
  If the member delta is set to true in the request object, only the delta is retrieved.
  
    */
  async getProperties() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetProperties",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qProp"];
  }
  /**    Returns the type and identifier of the object.
  
    */
  async getInfo() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetInfo",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qInfo"];
  }
  /**    Returns the definition of a dimension.
  
  The definition of the dimension is returned.
  
    */
  async getDimension() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetDimension",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qDim"];
  }
  /**    Lists the linked objects to a generic object, a dimension or a measure.
  
    */
  async getLinkedObjects() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetLinkedObjects",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qItems"];
    return response.map((r) => r);
  }
  /**    Publishes a dimension.
  This operation is not applicable for Qlik Sense Desktop.
  
    */
  async publish() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Publish",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Unpublishes a dimension.
  This operation is not applicable for Qlik Sense Desktop.
  
    */
  async unPublish() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "UnPublish",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Adds the generic dimension to the list of approved objects
  This operation is possible only in Qlik Sense Enterprise.
  
    */
  async approve() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Approve",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Removes the generic dimension from the list of approved objects
  This operation is possible only in Qlik Sense Enterprise.
  
    */
  async unApprove() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "UnApprove",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  on(event, listener) {
    if (!this.session.eventListeners) {
      this.session.eventListeners = {
        [this.qHandle]: {
          [event]: [listener]
        }
      };
    } else {
      if (!this.session.eventListeners[this.qHandle]) {
        this.session.eventListeners[this.qHandle] = {};
      }
      if (this.session.eventListeners[this.qHandle][event]) {
        this.session.eventListeners[this.qHandle][event].push(listener);
      } else {
        this.session.eventListeners[this.qHandle][event] = [listener];
      }
    }
  }
  once(event, listener) {
    let called = false;
    this.on(event, (...args) => {
      if (!called) {
        called = true;
        listener(...args);
      }
    });
  }
}
class GenericMeasure {
  constructor({
    qGenericId,
    qGenericType,
    qHandle,
    qType,
    ...rest
  }, session, auth) {
    this.auth = auth;
    this.session = session;
    this.qGenericId = qGenericId;
    this.qGenericType = qGenericType;
    this.qHandle = qHandle;
    this.qType = qType;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
  /**    Evaluates a measure and displays its properties, including the dynamic properties.
  
    */
  async getLayout() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetLayout",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qLayout"];
  }
  /**    Applies a patch to the properties of an object. Allows an update to some of the properties. It should not be possible to patch "/qInfo/qId",
  and it will be forbidden in the near future.
  Applying a patch takes less time than resetting all the properties.
  
      @param qPatches - Array of patches.
    */
  async applyPatches(qPatches) {
    const params = {};
    params.qPatches = qPatches;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ApplyPatches",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Sets some properties for a measure.
  
      @param qProp - Information about the measure.
    */
  async setProperties({ qMeasure: { qNumFormat: { qType = "UNKNOWN", qnDec = 10, ...restQMeasureQNumFormat } = { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index = 6, ...restQMeasureColoringBaseColor } = { index: 6 }, gradient: { limitType = "percent", ...restQMeasureColoringGradient } = { limitType: "percent" }, ...restQMeasureColoring } = { baseColor: { index: 6 }, gradient: { limitType: "percent" } }, ...restQMeasure } = { qNumFormat: { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: 6 }, gradient: { limitType: "percent" } } }, ...rest } = {}) {
    const params = {};
    params.qProp = { qMeasure: { qNumFormat: { qType, qnDec, ...restQMeasureQNumFormat }, coloring: { baseColor: { index, ...restQMeasureColoringBaseColor }, gradient: { limitType, ...restQMeasureColoringGradient }, ...restQMeasureColoring }, ...restQMeasure }, ...rest };
    params.qProp.qInfo = { qType: "measure" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetProperties",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Shows the properties of an object.
  Returns the identifier and the definition of the measure.
  If the member delta is set to true in the request object, only the delta is retrieved.
  The following is always returned in the output:
  
    */
  async getProperties() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetProperties",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qProp"];
  }
  /**    Returns the type and identifier of the object.
  
    */
  async getInfo() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetInfo",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qInfo"];
  }
  /**    Returns the definition of a measure.
  
    */
  async getMeasure() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetMeasure",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qMeasure"];
  }
  /**    Lists the linked objects to a generic object, a dimension or a measure.
  
    */
  async getLinkedObjects() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetLinkedObjects",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qItems"];
    return response.map((r) => r);
  }
  /**    Publishes a measure.
  This operation is not applicable for Qlik Sense Desktop.
  
    */
  async publish() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Publish",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Unpublishes a measure.
  This operation is not applicable for Qlik Sense Desktop.
  
    */
  async unPublish() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "UnPublish",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Adds the generic measure to the list of approved objects
  This operation is possible only in Qlik Sense Enterprise.
  
    */
  async approve() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Approve",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Removes the generic measure from the list of approved objects
  This operation is possible only in Qlik Sense Enterprise.
  
    */
  async unApprove() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "UnApprove",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  on(event, listener) {
    if (!this.session.eventListeners) {
      this.session.eventListeners = {
        [this.qHandle]: {
          [event]: [listener]
        }
      };
    } else {
      if (!this.session.eventListeners[this.qHandle]) {
        this.session.eventListeners[this.qHandle] = {};
      }
      if (this.session.eventListeners[this.qHandle][event]) {
        this.session.eventListeners[this.qHandle][event].push(listener);
      } else {
        this.session.eventListeners[this.qHandle][event] = [listener];
      }
    }
  }
  once(event, listener) {
    let called = false;
    this.on(event, (...args) => {
      if (!called) {
        called = true;
        listener(...args);
      }
    });
  }
}
class GenericObject {
  constructor({
    qGenericId,
    qGenericType,
    qHandle,
    qType,
    ...rest
  }, session, auth) {
    this.auth = auth;
    this.session = session;
    this.qGenericId = qGenericId;
    this.qGenericType = qGenericType;
    this.qHandle = qHandle;
    this.qType = qType;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
  /**    Evaluates an object and displays its properties including the dynamic properties.
  If the member delta is set to true in the request object, only the delta is evaluated. A GetLayout call on a generic object, returns up to one level down in the hierarchy.
  
   Example::
  A is a generic object and is the parent of the objects B and C. B is the parent of the objects D and E.
  
  A GetLayout call on A returns information on the objects A, B and C.
  A GetLayout call on B returns information on the objects B, D and E.
  A  GetLayout call on C returns information on the object C.
  
  In addition to the parameters displayed above, the GetLayout method can return other properties according to what is defined in the generic object.
  For example, if qHyperCubeDef is defined in the generic object, the GetLayout method returns the properties described in HyperCube.
  
    */
  async getLayout() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetLayout",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qLayout"];
  }
  /**    Retrieves the values of a list object.
  A data set is returned.
  
      @param qPath - Path to the definition of the object to be selected.
  For example, /qListObjectDef .
      @param qPages - Array of pages you are interested in.
    */
  async getListObjectData(qPath, qPages) {
    const params = {};
    params.qPath = qPath;
    params.qPages = qPages;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetListObjectData",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qDataPages"];
    return response.map((r) => r);
  }
  /**    Retrieves the calculated data for a chart, a table, or a scatter plot. It is possible to retrieve specific pages of data.
  This method works for a hypercube in DATA_MODE_STRAIGHT.
  A data set is returned.
  
      @param qPath - Path to the definition of the object to be selected.
  For example, /qHyperCubeDef .
      @param qPages - Array of pages to retrieve.
    */
  async getHyperCubeData(qPath, qPages) {
    const params = {};
    params.qPath = qPath;
    params.qPages = qPages;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetHyperCubeData",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qDataPages"];
    return response.map((r) => r);
  }
  /**    Reduces the data of a bar chart, a line chart or a scatter plot chart and retrieves them.
  The reduction is dependent on the zoom factor (parameter qZoomFactor ) and on the reduction mode.
  This method can be used to create mini charts.
  
   Bar chart or line chart data reduction:
  For the data reduction to happen, the following conditions must be fulfilled:
  
  • The values cannot fit in the defined page (parameter qPages ).
  
  • The zoom factor is not 0 (parameter qZoomFactor ).
  
  • The reduction mode must be set to D1.
  
  The reduction algorithm keeps the shape of the visualizations and works whatever the number of dimensions in the chart. The global profile of the chart is reduced, and not only a specific dimension. A visualization that has been reduced contains fewer values but its shape is the same. Data of all types can be reduced. Therefore it is hard to relate the values before and after a reduction especially when reducing string values.
  
   Example:
  If you have a chart with 1 million data, and you have set the zoom factor to 5, the GetHyperCubeReducedData method reduces the chart and retrieves 200 000 data.
  
   Scatter plot chart data reduction:
  The reduction mode must be set to C.
  This reduction mechanism follows the 2D K-Means algorithm. Data are reduced into a number of clusters. Each data is assigned to a specific centroid.
  The number of centroids can be defined in the parameter qZoomFactor.
  
   Scatter plot chart resolution reduction:
  The reduction mode must be set to S.
  The resolution is reduced according to the zoom factor (parameter qZoomFactor ).
  
   Example:
  If you have a scatter plot chart and the zoom factor is set to 2, the scatter plot chart resolution is reduced by 4.
  
      @param qPath - Path to the definition of the object to be selected.
  For example, /qHyperCubeDef .
      @param qPages - Array of pages.
      @param qZoomFactor - Defines the zoom factor.
  If set to -1, the engine decides of the zoom factor.
  
  • If the reduction mode is D1 or S , the zoom factor is 2ⁿ. If the zoom factor is 5, the data are reduced by a factor 32.
  
  • If the reduction mode is C , the zoom factor defines the number of centroids.
      @param qReductionMode - Defines the reduction mode.
  
  One of:
  
  • N or DATA_REDUCTION_NONE
  
  • D1 or DATA_REDUCTION_ONEDIM
  
  • S or DATA_REDUCTION_SCATTERED
  
  • C or DATA_REDUCTION_CLUSTERED
  
  • ST or DATA_REDUCTION_STACKED
    */
  async getHyperCubeReducedData(qPath, qPages, qZoomFactor, qReductionMode) {
    const params = {};
    params.qPath = qPath;
    params.qPages = qPages;
    params.qZoomFactor = qZoomFactor;
    params.qReductionMode = qReductionMode;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetHyperCubeReducedData",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qDataPages"];
    return response.map((r) => r);
  }
  /**    Retrieves the values of a pivot table. It is possible to retrieve specific pages of data.
  This method works for a hypercube in DATA_MODE_PIVOT.
  
      @param qPath - Path to the definition of the object to be selected.
  For example, /qHyperCubeDef .
      @param qPages - Array of pages to retrieve.
    */
  async getHyperCubePivotData(qPath, qPages) {
    const params = {};
    params.qPath = qPath;
    params.qPages = qPages;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetHyperCubePivotData",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qDataPages"];
    return response.map((r) => r);
  }
  /**    Retrieves the values of a stacked pivot table. It is possible to retrieve specific pages of data.
  This method works for a hypercube in DATA_MODE_PIVOT_STACK.
  
      @param qPath - Path to the definition of the object to be selected.
  For example, /qHyperCubeDef .
      @param qPages - Array of pages to retrieve.
      @param qMaxNbrCells - Maximum number of cells at outer level.
  The default value is 10 000.
    */
  async getHyperCubeStackData(qPath, qPages, qMaxNbrCells) {
    const params = {};
    params.qPath = qPath;
    params.qPages = qPages;
    if (qMaxNbrCells !== void 0) {
      params.qMaxNbrCells = qMaxNbrCells;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetHyperCubeStackData",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qDataPages"];
    return response.map((r) => r);
  }
  /**    Retrieves and packs compressed hypercube and axis data. It is possible to retrieve specific pages of data.
  Binning is done on the time stamp data as well as the date. This means that you can zoom in to a level of granularity as low as seconds.
  
      @param qPath - Path to the definition of the object.
  For example, /qHyperCubeDef .
      @param qReverseSort - If set to true the returned data pages are reverse sorted.
  Optional.
      @param qOptions - Defines the data to return.
    */
  async getHyperCubeContinuousData(qPath, qReverseSort, { qMaxNumberLines = -1, ...rest } = {}) {
    const params = {};
    params.qPath = qPath;
    params.qOptions = { qMaxNumberLines, ...rest };
    if (qReverseSort !== void 0) {
      params.qReverseSort = qReverseSort;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetHyperCubeContinuousData",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"];
  }
  /**    Retrieves data for nodes in a tree structure. It is possible to retrieve specific pages of data.
  This method works for a treedata object or a hypercube in DATA_MODE_TREE.
  
      @param qPath - Path to the definition of the object to be selected.
      @param qNodeOptions - Specifies all the paging filters needed to define the tree to be fetched. If left out the complete tree is returned.
    */
  async getHyperCubeTreeData(qPath, { qTreeLevels: { qDepth = -1, ...restQTreeLevels } = { qDepth: -1 }, ...rest } = {}) {
    const params = {};
    params.qPath = qPath;
    params.qNodeOptions = { qTreeLevels: { qDepth, ...restQTreeLevels }, ...rest };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetHyperCubeTreeData",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qNodes"];
    return response.map((r) => r);
  }
  /**    This method supports data binning.
  When a generic object with two or three measures and one dimension contains a lot of data, groups of points (for example, cells) can be rendered instead of points.
  A zone of interest can be refined (for zooming in) up to a maximum refinement level (set in the qQueryLevel parameter) or coarsened (for zoom out).
  The grid of cells is adaptive (not static), meaning that it adapts to different length scales.
  The GetHyperCubeBinnedData method gives information about the adaptive grid and the values of the generic object.
  The number of points in a cell and the coordinates (expressed in the measure range) of each cell are returned.
  Dimension values and measure values are rendered at point level (highest detailed level).
  The generic object should contain two or three measures and one dimension. When the refinement is high, the first two measures are represented on the x-axis and on the y-axis, while the third measure is visualized as color or point size.
  
   Adaptive Grid:
  More details about the properties of the adaptive grid are given in this paragraph.
  When the refinement is not the highest (cells are rendered), information about the adaptive grid is returned through several arrays.
  The first array contains the following properties:
  | Name        | Description                                       | Type                                                                                                                                                                                                             |
  |-------------|---------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
  | qNum        | Maximum number of points that a cell can contain. | String                                                                                                                                                                                                           |
  | qElemNumber | Is set to 0.                                      | Boolean                                                                                                                                                                                                          |
  | qState      | The default value is L.                           | One of:*   L for Locked*   S for Selected*   O for Optional*   D for Deselected*   A for Alternative*   X for eXcluded*   XS for eXcluded Selected*   XL for eXcluded Locked |
  
  The next arrays give the coordinates of each cell in the page.
  Each array contains the following properties:
  | Name        | Description                                                                                                                                                                                                                                                                                                     | Type                                                                                                                                                                                                             |
  |-------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
  | qText       | Coordinates of a cell in the measure range.  “qText”: “\[\[, , , \], \[, , , \], .... \[, , , \]\]  Where:  , _,  and  are the coordinates of the cell in the measure range. | String                                                                                                                                                                                                           |
  | qNum        | Number of points in the cell.                                                                                                                                                                                                                                                                                   | Double precision floating point                                                                                                                                                                                  |
  | qElemNumber | Unique identifier for each cell, calculated by the engine during the construction of the grid.  This element number is not stored in the database and can have a positive or a negative value.                                                                                                              | Integer                                                                                                                                                                                                          |
  | qState      | The default value is L.                                                                                                                                                                                                                                                                                         | One of:*   L for Locked*   S for Selected*   O for Optional*   D for Deselected*   A for Alternative*   X for eXcluded*   XS for eXcluded Selected*   XL for eXcluded Locked |
  
  Cells are represented as rectangles.
  
   Dimension values and measures values:
  More details about the properties, when dimension and measure values are returned, are given in this paragraph.
  When the refinement is high, points are rendered (not cells) and dimension and measure values for each cell are returned.
  The first array is empty because no information on the adaptive grid is needed.
  The next arrays bring information about the dimension and the measure values.
  | Name        | Description                                                                                                                                                                                        | Type                                                                                                                                                                                                             |
  |-------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
  | qText       | Text value of the dimension or the measure.                                                                                                                                                        | String                                                                                                                                                                                                           |
  | qNum        | Numerical value of the dimension or the measure.  Is set to 0 if the value is only text.                                                                                                       | Double precision floating point                                                                                                                                                                                  |
  | qElemNumber | Unique identifier for each cell, calculated by the engine during the construction of the grid.  This element number is not stored in the database and can have a positive or a negative value. | Integer                                                                                                                                                                                                          |
  | qState      | The default value is L.                                                                                                                                                                            | One of:*   L for Locked*   S for Selected*   O for Optional*   D for Deselected*   A for Alternative*   X for eXcluded*   XS for eXcluded Selected*   XL for eXcluded Locked |
  
      @param qPath - Path to the definition of the object.
  For example, /qHyperCubeDef .
      @param qPages - Array of pages to retrieve.
  Since the generic object contains two measures and one dimension, qWidth should be set to 3.
  If the value of a measure is Null, the value cannot be rendered. Therefore, the number of elements rendered in a page can be less than the number defined in the property qHeight .
      @param qViewport - Defines the canvas and the zoom level.
  This parameter is not yet used and is optional.
      @param qDataRanges - Range of the data to render.
  This range applies to the measure values.
  The lowest and highest values of a measure can be retrieved by using the GetLayout method (in /qHyperCube/qMeasureInfo ).
      @param qMaxNbrCells - Maximum number of cells in the grid.
      @param qQueryLevel - Level of details. The higher the level, the more detailed information you get (zoom-in).
  When the number of points to render falls below a certain threshold, the values are no longer rendered as cells but as points.
  The query level should be no greater than 20.
      @param qBinningMethod - Selects the algorithm.
  The default value is 0.
  One of:
  
  • 0: Adaptive grid
  
  • 1: Hexagonal grid
  
  • 2: Uniform grid
    */
  async getHyperCubeBinnedData(qPath, qPages, qViewport, qDataRanges, qMaxNbrCells, qQueryLevel, qBinningMethod) {
    const params = {};
    params.qPath = qPath;
    params.qPages = qPages;
    params.qViewport = qViewport;
    params.qDataRanges = qDataRanges;
    params.qMaxNbrCells = qMaxNbrCells;
    params.qQueryLevel = qQueryLevel;
    params.qBinningMethod = qBinningMethod;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetHyperCubeBinnedData",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qDataPages"];
    return response.map((r) => r);
  }
  /**    Applies a patch to the properties of an object. Allows an update to some of the properties.
  It is possible to apply a patch to the properties of a generic object, that is not persistent. Such a patch is called a soft patch.
  In that case, the result of the operation on the properties (add, remove or delete) is not shown when doing GetProperties , and only a GetLayout call shows the result of the operation.
  Properties that are not persistent are called soft properties. Once the engine session is over, soft properties are cleared. It should not be possible to patch "/qInfo/qId",
  and it will be forbidden in the near future.
  Soft properties apply only to generic objects.
  
      @param qPatches - Array of patches.
      @param qSoftPatch - If set to true, it means that the properties to be applied are not persistent. The patch is a soft patch.
  The default value is false.
    */
  async applyPatches(qPatches, qSoftPatch) {
    const params = {};
    params.qPatches = qPatches;
    if (qSoftPatch !== void 0) {
      params.qSoftPatch = qSoftPatch;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ApplyPatches",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Clears the soft properties of a generic object.
  For more information on how to add soft properties to a generic object, see ApplyPatches Method.
  
    */
  async clearSoftPatches() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ClearSoftPatches",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Sets some properties for a generic object.
  The properties depends on the generic object type, see properties genericobject-property.html.
  
      @param qProp - Information about the generic object.
    */
  async setProperties({
    qBookmarkListDef: { qType = "bookmark", ...restQBookmarkListDef } = { qType: "bookmark" },
    qHyperCubeDef: {
      qMaxStackedCells = 5e3,
      qMode = "DATA_MODE_STRAIGHT",
      qNoOfLeftDims = -1,
      qPseudoDimPos = -1,
      ...restQHyperCubeDef
    } = {
      qMaxStackedCells: 5e3,
      qMode: "DATA_MODE_STRAIGHT",
      qNoOfLeftDims: -1,
      qPseudoDimPos: -1
    },
    qListObjectDef: { qFrequencyMode = "NX_FREQUENCY_NONE", ...restQListObjectDef } = { qFrequencyMode: "NX_FREQUENCY_NONE" },
    qNxLibraryDimensionDef: { coloring: { baseColor: { index = 6, ...restQNxLibraryDimensionDefColoringBaseColor } = { index: 6 }, ...restQNxLibraryDimensionDefColoring } = { baseColor: { index: 6 } }, ...restQNxLibraryDimensionDef } = { coloring: { baseColor: { index: 6 } } },
    qNxLibraryMeasureDef: { qNumFormat: { qType: qType2 = "UNKNOWN", qnDec = 10, ...restQNxLibraryMeasureDefQNumFormat } = { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: index2 = 6, ...restQNxLibraryMeasureDefColoringBaseColor } = { index: 6 }, gradient: { limitType = "percent", ...restQNxLibraryMeasureDefColoringGradient } = { limitType: "percent" }, ...restQNxLibraryMeasureDefColoring } = { baseColor: { index: 6 }, gradient: { limitType: "percent" } }, ...restQNxLibraryMeasureDef } = { qNumFormat: { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: 6 }, gradient: { limitType: "percent" } } },
    qVariableListDef: {
      qData: { tags = "/tags", ...restQVariableListDefQData } = { tags: "/tags" },
      qShowConfig = true,
      qShowReserved = true,
      qType: qType3 = "variable",
      ...restQVariableListDef
    } = {
      qData: { tags: "/tags" },
      qShowConfig: true,
      qShowReserved: true,
      qType: "variable"
    },
    ...rest
  } = {}) {
    const params = {};
    params.qProp = {
      qBookmarkListDef: { qType, ...restQBookmarkListDef },
      qHyperCubeDef: {
        qMaxStackedCells,
        qMode,
        qNoOfLeftDims,
        qPseudoDimPos,
        ...restQHyperCubeDef
      },
      qListObjectDef: { qFrequencyMode, ...restQListObjectDef },
      qNxLibraryDimensionDef: { coloring: { baseColor: { index, ...restQNxLibraryDimensionDefColoringBaseColor }, ...restQNxLibraryDimensionDefColoring }, ...restQNxLibraryDimensionDef },
      qNxLibraryMeasureDef: { qNumFormat: { qType: qType2, qnDec, ...restQNxLibraryMeasureDefQNumFormat }, coloring: { baseColor: { index: index2, ...restQNxLibraryMeasureDefColoringBaseColor }, gradient: { limitType, ...restQNxLibraryMeasureDefColoringGradient }, ...restQNxLibraryMeasureDefColoring }, ...restQNxLibraryMeasureDef },
      qVariableListDef: {
        qData: { tags, ...restQVariableListDefQData },
        qShowConfig,
        qShowReserved,
        qType: qType3,
        ...restQVariableListDef
      },
      ...rest
    };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetProperties",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Returns the identifier, the type and the properties of the object.
  Because it is not mandatory to set all properties when you define an object, the GetProperties method may show properties that were not set. In that case, default values are given.
  If the object contains some soft properties, the soft properties are not returned by the GetProperties method. Use the GetEffectiveProperties method instead.
  If the object is linked to another object, the properties of the linking object are not returned by the GetProperties method. Use the GetEffectiveProperties method instead.
  The properties depends on the generic object type, see properties genericobject-layout.html.
  If the member delta is set to true in the request object, only the delta is retrieved.
  
    */
  async getProperties() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetProperties",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qProp"];
  }
  /**    Returns the identifier, the type and the properties of the object.
  If the object contains some soft properties, the soft properties are returned.
  If the object is linked to another object, the properties of the linking object are returned.
  
    */
  async getEffectiveProperties() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetEffectiveProperties",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qProp"];
  }
  /**    Sets the properties of:
  
  • A generic object.
  
  • The children of the generic object.
  
  • The bookmarks/embedded snapshots of the generic object.
  
  If the SetFullPropertyTree method is asked to set some properties to a child that does not exist, it creates the child.  The type of an object cannot be updated.
  
      @param qPropEntry - Information about the generic object entry.
    */
  async setFullPropertyTree({
    qEmbeddedSnapshotRef: {
      qClassicBookmark: {
        qApplyInputFieldValues = true,
        qIncludeSelectionState = true,
        qShow: { qAlways = true, ...restQEmbeddedSnapshotRefQClassicBookmarkQShow } = { qAlways: true },
        ...restQEmbeddedSnapshotRefQClassicBookmark
      } = { qApplyInputFieldValues: true, qIncludeSelectionState: true, qShow: { qAlways: true } },
      qProperties: { creationDate = (/* @__PURE__ */ new Date()).toISOString(), ...restQEmbeddedSnapshotRefQProperties } = { creationDate: (/* @__PURE__ */ new Date()).toISOString() },
      ...restQEmbeddedSnapshotRef
    } = { qClassicBookmark: { qApplyInputFieldValues: true, qIncludeSelectionState: true, qShow: { qAlways: true } }, qProperties: { creationDate: (/* @__PURE__ */ new Date()).toISOString() } },
    qProperty: {
      qBookmarkListDef: { qType = "bookmark", ...restQPropertyQBookmarkListDef } = { qType: "bookmark" },
      qHyperCubeDef: {
        qMaxStackedCells = 5e3,
        qMode = "DATA_MODE_STRAIGHT",
        qNoOfLeftDims = -1,
        qPseudoDimPos = -1,
        ...restQPropertyQHyperCubeDef
      } = {
        qMaxStackedCells: 5e3,
        qMode: "DATA_MODE_STRAIGHT",
        qNoOfLeftDims: -1,
        qPseudoDimPos: -1
      },
      qListObjectDef: { qFrequencyMode = "NX_FREQUENCY_NONE", ...restQPropertyQListObjectDef } = { qFrequencyMode: "NX_FREQUENCY_NONE" },
      qNxLibraryDimensionDef: { coloring: { baseColor: { index = 6, ...restQPropertyQNxLibraryDimensionDefColoringBaseColor } = { index: 6 }, ...restQPropertyQNxLibraryDimensionDefColoring } = { baseColor: { index: 6 } }, ...restQPropertyQNxLibraryDimensionDef } = { coloring: { baseColor: { index: 6 } } },
      qNxLibraryMeasureDef: { qNumFormat: { qType: qType2 = "UNKNOWN", qnDec = 10, ...restQPropertyQNxLibraryMeasureDefQNumFormat } = { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: index2 = 6, ...restQPropertyQNxLibraryMeasureDefColoringBaseColor } = { index: 6 }, gradient: { limitType = "percent", ...restQPropertyQNxLibraryMeasureDefColoringGradient } = { limitType: "percent" }, ...restQPropertyQNxLibraryMeasureDefColoring } = { baseColor: { index: 6 }, gradient: { limitType: "percent" } }, ...restQPropertyQNxLibraryMeasureDef } = { qNumFormat: { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: 6 }, gradient: { limitType: "percent" } } },
      qVariableListDef: {
        qData: { tags = "/tags", ...restQPropertyQVariableListDefQData } = { tags: "/tags" },
        qShowConfig = true,
        qShowReserved = true,
        qType: qType3 = "variable",
        ...restQPropertyQVariableListDef
      } = {
        qData: { tags: "/tags" },
        qShowConfig: true,
        qShowReserved: true,
        qType: "variable"
      },
      ...restQProperty
    } = {
      qBookmarkListDef: { qType: "bookmark" },
      qHyperCubeDef: {
        qMaxStackedCells: 5e3,
        qMode: "DATA_MODE_STRAIGHT",
        qNoOfLeftDims: -1,
        qPseudoDimPos: -1
      },
      qListObjectDef: { qFrequencyMode: "NX_FREQUENCY_NONE" },
      qNxLibraryDimensionDef: { coloring: { baseColor: { index: 6 } } },
      qNxLibraryMeasureDef: { qNumFormat: { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: 6 }, gradient: { limitType: "percent" } } },
      qVariableListDef: {
        qData: { tags: "/tags" },
        qShowConfig: true,
        qShowReserved: true,
        qType: "variable"
      }
    },
    ...rest
  } = {}) {
    const params = {};
    params.qPropEntry = {
      qEmbeddedSnapshotRef: {
        qClassicBookmark: {
          qApplyInputFieldValues,
          qIncludeSelectionState,
          qShow: { qAlways, ...restQEmbeddedSnapshotRefQClassicBookmarkQShow },
          ...restQEmbeddedSnapshotRefQClassicBookmark
        },
        qProperties: { creationDate, ...restQEmbeddedSnapshotRefQProperties },
        ...restQEmbeddedSnapshotRef
      },
      qProperty: {
        qBookmarkListDef: { qType, ...restQPropertyQBookmarkListDef },
        qHyperCubeDef: {
          qMaxStackedCells,
          qMode,
          qNoOfLeftDims,
          qPseudoDimPos,
          ...restQPropertyQHyperCubeDef
        },
        qListObjectDef: { qFrequencyMode, ...restQPropertyQListObjectDef },
        qNxLibraryDimensionDef: { coloring: { baseColor: { index, ...restQPropertyQNxLibraryDimensionDefColoringBaseColor }, ...restQPropertyQNxLibraryDimensionDefColoring }, ...restQPropertyQNxLibraryDimensionDef },
        qNxLibraryMeasureDef: { qNumFormat: { qType: qType2, qnDec, ...restQPropertyQNxLibraryMeasureDefQNumFormat }, coloring: { baseColor: { index: index2, ...restQPropertyQNxLibraryMeasureDefColoringBaseColor }, gradient: { limitType, ...restQPropertyQNxLibraryMeasureDefColoringGradient }, ...restQPropertyQNxLibraryMeasureDefColoring }, ...restQPropertyQNxLibraryMeasureDef },
        qVariableListDef: {
          qData: { tags, ...restQPropertyQVariableListDefQData },
          qShowConfig,
          qShowReserved,
          qType: qType3,
          ...restQPropertyQVariableListDef
        },
        ...restQProperty
      },
      ...rest
    };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetFullPropertyTree",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Gets the properties of:
  
  • A generic object.
  
  • The children of the generic object.
  
  • The bookmarks/embedded snapshots of the generic object.
  
    */
  async getFullPropertyTree() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetFullPropertyTree",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qPropEntry"];
  }
  /**    Returns the type and identifier of the object.
  
    */
  async getInfo() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetInfo",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qInfo"];
  }
  /**    Clears the selections in a dimension of a visualization.
  
      @param qPath - Path to the definition of the visualization.
  For example, /qListObjectDef .
      @param qColIndices - Array of dimension numbers or indexes. The selections are cleared in the specified dimensions.
  Dimension numbers/indexes start from 0.
  If this parameter is not set, all dimensions are cleared.
    */
  async clearSelections(qPath, qColIndices) {
    const params = {};
    params.qPath = qPath;
    if (qColIndices !== void 0) {
      params.qColIndices = qColIndices;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ClearSelections",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Exports the data of any generic object to an Excel file or a open XML file. If the object contains excluded values, those excluded values are not exported.
  This API has limited functionality and will not support CSV export from all types of objects. Consider using Excel export instead. Treemap and bar chart are not supported.
  ExportData method is not supported in SaaS Editions of Qlik Sense.
  
   Default limitations in number of rows and columns:
  The default maximum number of rows and columns in the Excel export file is:
  
  • 1048566 rows per sheet. For pivot tables: 1048566 column dimensions. 10 rows can be added after the export.
  
  • 16384 columns per sheet. If the number of columns exceeds the limit, the exported file is truncated and a warning message is sent.
  
   Default limitation in number of columns:
  The default maximum number of columns in the export file is:
  
  • 1000 to export to a CSV file
  
  The exported file is truncated if the number of cells exceeds the limit. A warning message with code 1000 is sent.
  There is an option to export only the possible values ( qExportState is P).
  
   Default limitation in size:
  If the exported file is larger than the maximum value, then an out-of-memory error with code 13000 is returned.
  
  Exported files are temporary and are available only for a certain time span and only to the user who created them.
  
      @param qFileType - Type of the file to export.
  
  One of:
  
  • CSV_C or EXPORT_CSV_C
  
  • CSV_T or EXPORT_CSV_T
  
  • OOXML or EXPORT_OOXML
  
  • PARQUET or EXPORT_PARQUET
      @param qPath - Path to the definition of the object to be exported.
  For example, /qHyperCubeDef .
  This parameter is mandatory if the file type is CSV_C or CSV_T .
      @param qFileName - Name of the exported file after download from browser.
  This parameter is optional and only used in Qlik Sense Desktop.
      @param qExportState - Defines the values to be exported.
  The default value is A.
  
  One of:
  
  • P or EXPORT_POSSIBLE
  
  • A or EXPORT_ALL
      @param qServeOnce - If the exported file should be served only once
  This parameter is optional and only used in Qlik Sense Enterprise (Windows)
  Default value: false
    */
  async exportData(qFileType, qPath, qFileName, qExportState, qServeOnce) {
    const params = {};
    params.qFileType = qFileType;
    if (qPath !== void 0) {
      params.qPath = qPath;
    }
    if (qFileName !== void 0) {
      params.qFileName = qFileName;
    }
    if (qExportState !== void 0) {
      params.qExportState = qExportState;
    }
    if (qServeOnce !== void 0) {
      params.qServeOnce = qServeOnce;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ExportData",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"];
  }
  /**    Makes single selections in dimensions.
  This method applies to list objects only.
  The member Change returns the handles of the objects that are updated following the selections.
  qSuccess is set to true if the selections are successful and is set to false in the following cases:
  
  • The object contains invalid fields (fields that are not in the data model).
  
  • The selection applies to a locked field.
  
  • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
  
      @param qPath - Path to the definition of the object to be selected.
  For example, /qListObjectDef .
      @param qValues - Element numbers to select.
  You can select multiple values; the separator is the comma.
      @param qToggleMode - Set to true to toggle.
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
    */
  async selectListObjectValues(qPath, qValues, qToggleMode, qSoftLock) {
    const params = {};
    params.qPath = qPath;
    params.qValues = qValues;
    params.qToggleMode = qToggleMode;
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectListObjectValues",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Selects all possible values of a list object.
  This method applies to list objects (objects with one dimension).
  The member Change returns the handles of the objects that are updated following the selections.
  qSuccess is set to true if the selections are successful and is set to false in the following cases:
  
  • The object contains invalid fields (fields that are not in the data model).
  
  • The selection applies to a locked field.
  
  • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
  
      @param qPath - Path to the definition of the object to be selected.
  For example, /qListObjectDef .
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
    */
  async selectListObjectPossible(qPath, qSoftLock) {
    const params = {};
    params.qPath = qPath;
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectListObjectPossible",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Inverts the current selections in a specific field.
  This method applies to list objects (objects with one dimension).
  The member Change returns the handles of the objects that are updated following the selections.
  qSuccess is set to true if the selections are successful and is set to false in the following cases:
  
  • The object contains some invalid fields (fields that are not in the data model).
  
  • The selection applies to a locked field.
  
  • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
  
      @param qPath - Path to the definition of the object to be selected.
  For example, /qListObjectDef .
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
    */
  async selectListObjectExcluded(qPath, qSoftLock) {
    const params = {};
    params.qPath = qPath;
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectListObjectExcluded",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Selects all alternative values in a specific field.
  This method applies to list objects (objects with one dimension). If a field contains at least one selected value, the values that are neither selected nor excluded are alternatives values.
  The member Change returns the handles of the objects that are updated following the selections.
  qSuccess is set to true if the selections are successful and is set to false in the following cases:
  
  • The object contains some invalid fields (fields that are not in the data model).
  
  • The selection applies to a locked field.
  
  • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
  
      @param qPath - Path to the definition of the object to be selected.
  For example, /qListObjectDef .
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
    */
  async selectListObjectAlternative(qPath, qSoftLock) {
    const params = {};
    params.qPath = qPath;
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectListObjectAlternative",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Selects all values of a field.
  This method applies to list objects (objects with one dimension).
  The member Change returns the handles of the objects that are updated following the selections.
  qSuccess is set to true if the selections are successful and is set to false in the following cases:
  
  • The object contains some invalid fields (fields that are not in the data model).
  
  • The selection applies to a locked field.
  
  • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
  
      @param qPath - Path to the definition of the object to be selected.
  For example, /qListObjectDef .
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
    */
  async selectListObjectAll(qPath, qSoftLock) {
    const params = {};
    params.qPath = qPath;
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectListObjectAll",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    The following is returned in the output:
  The operation is successful if qSuccess is set to true.
  
      @param qPath - Path to the definition of the object.
  For example, /qHyperCubeDef .
      @param qRanges - Selects ranges in a hypercube in (Ranges[N].Min,Ranges[N].Max) intervals.
  If either Ranges[N].MinInclEq or Ranges[N].MaxInclEq, or both flags are set to true then Min and Max values will be selected.
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
    */
  async selectListObjectContinuousRange(qPath, qRanges, qSoftLock) {
    const params = {};
    params.qPath = qPath;
    params.qRanges = qRanges;
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectListObjectContinuousRange",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Searches for a string in a list object.
  This method applies to list objects (objects with one dimension). The search results can be displayed using the GetLayout Method.
  
  The operation is successful if qSuccess is set to true.
  
      @param qPath - Path to the definition of the list object.
  For example, /qListObjectDef .
      @param qMatch - Search string.
  Wild card characters are allowed. The search is not case sensitive.
  Examples:
  
  • `P*U*`: retrieves only values that start with P and contain U
  
  • `P U S`: retrieves values that start with P, U or S
    */
  async searchListObjectFor(qPath, qMatch) {
    const params = {};
    params.qPath = qPath;
    params.qMatch = qMatch;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SearchListObjectFor",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Aborts the results of a search in a list object.
  This method applies to list objects (objects with one dimension).  After an abort on a list object search, the GetLayout Method does not return any more search results but it does return the values in the field.
  
      @param qPath - Path to the definition of the list object.
  For example, /qListObjectDef .
    */
  async abortListObjectSearch(qPath) {
    const params = {};
    params.qPath = qPath;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "AbortListObjectSearch",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Accept the results of a search in a list object. The search results become selected in the field.
  This method applies to list objects (objects with one dimension). The search results are displayed using the GetLayout Method.
  
      @param qPath - Path to the definition of the list object.
  For example, /qListObjectDef .
      @param qToggleMode - Set to true to keep any selections present in the list object.
  If this parameter is set to false, selections made before accepting the list object search become alternative.
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
    */
  async acceptListObjectSearch(qPath, qToggleMode, qSoftLock) {
    const params = {};
    params.qPath = qPath;
    params.qToggleMode = qToggleMode;
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "AcceptListObjectSearch",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Expands the left dimensions of a pivot table. This method applies only to pivot tables that are not always fully expanded.
  In the definition of the hypercube (in HyperCubeDef ), the parameter qAlwaysFullyExpanded must be set to false.
  
      @param qPath - Path to the definition of the object to be expanded.
  For example, /qHyperCubeDef .
      @param qRow - Row index in the data matrix to expand.
  Indexing starts from 0.
      @param qCol - Column index. The index is based on the left dimension indexes.
  Indexing starts from 0.
      @param qAll - If set to true, it expands all cells.
  Parameters qRow and qCol are not used if qAll is set to true, but they need to be set (for example to 0).
    */
  async expandLeft(qPath, qRow, qCol, qAll) {
    const params = {};
    params.qPath = qPath;
    params.qRow = qRow;
    params.qCol = qCol;
    params.qAll = qAll;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ExpandLeft",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Expands the top dimensions of a pivot table. This method applies only to pivot tables that are not always fully expanded.
  In the definition of the hypercube (in HyperCubeDef ), the parameter qAlwaysFullyExpanded must be set to false.
  
      @param qPath - Path to the definition of the object to be expanded.
  For example, /qHyperCubeDef .
      @param qRow - Row index. The index is based on the top dimension indexes.
  Indexing starts from 0.
      @param qCol - Column index in the data matrix.
  Indexing starts from 0.
      @param qAll - If set to true, it expands all cells.
  Parameters qRow and qCol are not used if qAll is set to true, but they need to be set (for example to 0).
    */
  async expandTop(qPath, qRow, qCol, qAll) {
    const params = {};
    params.qPath = qPath;
    params.qRow = qRow;
    params.qCol = qCol;
    params.qAll = qAll;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ExpandTop",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Collapses the left dimensions of a pivot table. This method applies only to pivot tables that are not always fully expanded.
  In the definition of the hypercube (in HyperCubeDef ), the parameter qAlwaysFullyExpanded must be set to false.
  
      @param qPath - Path to the definition of the object to be collapsed.
  For example, /qHyperCubeDef .
      @param qRow - Row index in the data matrix.
  Indexing starts from 0.
      @param qCol - Column index. The index is based on the left dimension indexes.
  Indexing starts from 0.
      @param qAll - If set to true, it collapses all cells.
  Parameters qRow and qCol are not used if qAll is set to true, but they need to be set (for example to 0).
    */
  async collapseLeft(qPath, qRow, qCol, qAll) {
    const params = {};
    params.qPath = qPath;
    params.qRow = qRow;
    params.qCol = qCol;
    params.qAll = qAll;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CollapseLeft",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Collapses the top dimensions of a pivot table. This method applies only to pivot tables that are not always fully expanded.
  In the definition of the hypercube (in HyperCubeDef ), the parameter qAlwaysFullyExpanded must be set to false.
  
      @param qPath - Path to the definition of the object to be collapsed
  For example, /qHyperCubeDef .
      @param qRow - Row index. The index is based on the top dimension indexes.
  Indexing starts from 0.
      @param qCol - Column index in the data matrix.
  Indexing starts from 0.
      @param qAll - If set to true, it collapses all cells.
  Parameters qRow and qCol are not used if qAll is set to true, but they need to be set (for example to 0).
    */
  async collapseTop(qPath, qRow, qCol, qAll) {
    const params = {};
    params.qPath = qPath;
    params.qRow = qRow;
    params.qCol = qCol;
    params.qAll = qAll;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CollapseTop",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    You can use the drillUp method with any object that contains a drill-down group as a dimension.
  This method allows you to move between different levels of information (from a detailed level to a less detailed level of information). You can go back to previous visualizations up to the highest level of the hierarchy.
  If you try to drill up more steps than there are available levels, the first level of the hierarchy is displayed.
  
      @param qPath - Path to the definition of the object to be selected.
  For example, /qHyperCubeDef .
      @param qDimNo - Dimension number or index starting from 0.
  The default value is 0.
      @param qNbrSteps - Number of steps you want to drill up.
  The default value is 0.
    */
  async drillUp(qPath, qDimNo, qNbrSteps) {
    const params = {};
    params.qPath = qPath;
    params.qDimNo = qDimNo;
    params.qNbrSteps = qNbrSteps;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DrillUp",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Locks the selected values of a generic object.
  
      @param qPath - Path to the definition of the object.
  For example, /qListObjectDef .
      @param qColIndices - Dimension numbers or dimension indexes where the lock should apply.
  Dimension numbers/indexes start from 0.
  If this parameter is not set, the selected values in all dimensions are locked.
    */
  async lock(qPath, qColIndices) {
    const params = {};
    params.qPath = qPath;
    if (qColIndices !== void 0) {
      params.qColIndices = qColIndices;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Lock",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Unlocks the selected values of a generic object if the target (or handle ) is a generic object
  
      @param qPath - Path to the definition of the object.
  For example, /qListObjectDef .
      @param qColIndices - Dimension numbers/indexes where the unlock should apply.
  Dimension numbers/indexes start from 0.
  If this parameter is not set, the locked values in all dimensions are unlocked.
    */
  async unlock(qPath, qColIndices) {
    const params = {};
    params.qPath = qPath;
    if (qColIndices !== void 0) {
      params.qColIndices = qColIndices;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Unlock",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Selects some values in one dimension.
  The values are identified by their element numbers.
  This method applies to charts, tables and scatter plots.
  The member Change returns the handles of the objects that are updated following the selections.
  qSuccess is set to true if the selections are successful and is set to false in the following cases:
  
  • The object contains some invalid fields (fields that are not in the data model).
  
  • The selection applies to a locked field.
  
  • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
  
      @param qPath - Path to the definition of the object to be selected.
  For example, /qHyperCubeDef .
      @param qDimNo - Dimension number or index to select.
  Dimension numbers/index start from 0.
      @param qValues - Element numbers of the field to select.
  You can select multiple elements; the separator is the comma.
      @param qToggleMode - Set to true to toggle.
    */
  async selectHyperCubeValues(qPath, qDimNo, qValues, qToggleMode) {
    const params = {};
    params.qPath = qPath;
    params.qDimNo = qDimNo;
    params.qValues = qValues;
    params.qToggleMode = qToggleMode;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectHyperCubeValues",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Makes selections in multiple dimensions and measures.
   This method applies to hypercubes, such as bar charts, tables and scatter plots.
  The member Change returns the handles of the objects that are updated following the selections.
  qSuccess is set to true if the selections are successful and is set to false in the following cases:
  
  • The object contains some invalid fields (fields that are not in the data model).
  
  • The selection applies to a locked field.
  
  • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
  
      @param qPath - Path to the definition of the object to be selected.
  For example, /qHyperCubeDef .
      @param qRowIndices - Array of row indexes to select, starting from 0.
  If the array is empty [ ] , all rows are selected.
      @param qColIndices - Indexes of the columns to select, starting from 0.
  A column corresponds to a dimension in the order they are added to the hypercube.
  If a column is hidden it is ignored, qColIndex n refers to the n:th visible column (starting from zero).
  Example:
  If the hypercube has two dimensions:
  
  • [0] selects the first column (i.e the first dimension).
  
  • [1] selects the second column (i.e the second dimension).
  
  If the array is empty [ ] , all columns are selected.
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
      @param qDeselectOnlyOneSelected - Set this parameter to true to unselect the last single selected value. There must be only one selected value in the field.
  The default value is false.
    */
  async selectHyperCubeCells(qPath, qRowIndices, qColIndices, qSoftLock, qDeselectOnlyOneSelected) {
    const params = {};
    params.qPath = qPath;
    params.qRowIndices = qRowIndices;
    params.qColIndices = qColIndices;
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (qDeselectOnlyOneSelected !== void 0) {
      params.qDeselectOnlyOneSelected = qDeselectOnlyOneSelected;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectHyperCubeCells",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    This method only applies to hypercubes that are not represented as straight tables. The parameter qMode in HyperCubeDef must be set either to P  or K .
  
   Pivot table:
  Makes selections in the top or left dimension cells of a pivot table or in the data matrix. Only expanded dimensions can be selected.
  
   Stacked table:
  Makes selections in the left dimension cells of a stacked table or in the data matrix.
  There is no top dimensions in a stacked table. A stacked table can only contain one measure.
  
   Example of a pivot table:
  
  In the representation above:
  |                                        |                                                                                     |
  |----------------------------------------|-------------------------------------------------------------------------------------|
  | Sum(OrderTotal)  Count(OrderTotal) | Are pseudo dimensions.                                                              |
  | CategoryName                           | Is a left dimension.  _Beverages_ , _Condiments_ ... are left dimension values. |
  | ProductName                            | Is a top dimension.  _Chef Anton's Cajun Seasoning_ is a top dimension value.   |
  | Numeric values                         | Are calculated values in the data matrix.  _626291,832_ is a calculated value.  |
  
  The member Change returns the handles of the objects that are updated following the selections.
  qSuccess is set to true if the selections are successful and is set to false in the following cases:
  
  • The object contains some invalid fields (fields that are not in the data model).
  
  • The selection applies to a locked field.
  
  • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
  
      @param qPath - Path to the definition of the object.
  For example, /qHyperCubeDef .
      @param qSelections - Information about the selections to perform.
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
      @param qDeselectOnlyOneSelected - Set this parameter to true to unselect the last single selected value. There must be only one selected value in the field.
  The default value is false.
    */
  async selectPivotCells(qPath, qSelections, qSoftLock, qDeselectOnlyOneSelected) {
    const params = {};
    params.qPath = qPath;
    params.qSelections = qSelections;
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (qDeselectOnlyOneSelected !== void 0) {
      params.qDeselectOnlyOneSelected = qDeselectOnlyOneSelected;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectPivotCells",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Makes range selections in measures.
   This method applies to hypercubes. For example, bar charts, tables and scatter plots.
  The member Change returns the handles of the objects that are updated following the selections.
  qSuccess is set to true if the selections are successful and is set to false in the following cases:
  
  • The object contains some invalid fields (fields that are not in the data model).
  
  • The selection applies to a locked field.
  
  • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
  
      @param qPath - Path to the definition of the object to be selected.
  For example, /qHyperCubeDef .
      @param qRanges - Ranges of selections.
      @param qColumnsToSelect - Indicates which dimensions to select.
  The dimensions numbering starts at 0 (first dimension is 0).
  If the array is empty, all dimensions are selected.
      @param qOrMode - Applies to hypercubes with multiple measures.
  If set to true, it means that at least one of the measures must be in the range of selections for the group of measures to be selected.
  If set to false, it means that all measures must be in the range of selections for the group of measures to be selected.
  The default value is false.
      @param qDeselectOnlyOneSelected - Set this parameter to true to unselect the last single selected value. There must be only one selected value in the field.
  The default value is false.
    */
  async rangeSelectHyperCubeValues(qPath, qRanges, qColumnsToSelect, qOrMode, qDeselectOnlyOneSelected) {
    const params = {};
    params.qPath = qPath;
    params.qRanges = qRanges;
    if (qColumnsToSelect !== void 0) {
      params.qColumnsToSelect = qColumnsToSelect;
    }
    if (qOrMode !== void 0) {
      params.qOrMode = qOrMode;
    }
    if (qDeselectOnlyOneSelected !== void 0) {
      params.qDeselectOnlyOneSelected = qDeselectOnlyOneSelected;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "RangeSelectHyperCubeValues",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Makes multiple range selections in measures.
   This method applies to hypercubes. For example, bar charts, tables and scatter plots.
  The member Change returns the handles of the objects that are updated following the selections.
  qSuccess is set to true if the selections are successful and is set to false in the following cases:
  
  • The object contains some invalid fields (fields that are not in the data model).
  
  • The selection applies to a locked field.
  
  • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
  
      @param qPath - Path to the definition of the object to be selected.
  For example, /qHyperCubeDef .
      @param qRanges - Ranges of selections.
      @param qOrMode - Applies to hypercubes with multiple measures.
  If set to true, it means that at least one of the measures must be in the range of selections for the group of measures to be selected.
  If set to false, it means that all measures must be in the range of selections for the group of measures to be selected.
  The default value is false.
      @param qDeselectOnlyOneSelected - Set this parameter to true to unselect the last single selected value. There must be only one selected value in the field.
  The default value is false.
    */
  async multiRangeSelectHyperCubeValues(qPath, qRanges, qOrMode, qDeselectOnlyOneSelected) {
    const params = {};
    params.qPath = qPath;
    params.qRanges = qRanges;
    if (qOrMode !== void 0) {
      params.qOrMode = qOrMode;
    }
    if (qDeselectOnlyOneSelected !== void 0) {
      params.qDeselectOnlyOneSelected = qDeselectOnlyOneSelected;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "MultiRangeSelectHyperCubeValues",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**
  
      @param qPath -
      @param qRanges -
      @param qOrMode -
      @param qDeselectOnlyOneSelected -
    */
  async multiRangeSelectTreeDataValues(qPath, qRanges, qOrMode, qDeselectOnlyOneSelected) {
    const params = {};
    params.qPath = qPath;
    params.qRanges = qRanges;
    if (qOrMode !== void 0) {
      params.qOrMode = qOrMode;
    }
    if (qDeselectOnlyOneSelected !== void 0) {
      params.qDeselectOnlyOneSelected = qDeselectOnlyOneSelected;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "MultiRangeSelectTreeDataValues",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    The following is returned in the output:
  The operation is successful if qSuccess is set to true.
  
      @param qPath - Path to the definition of the object.
  For example, /qHyperCubeDef .
      @param qRanges - Selects ranges in a hypercube in (Ranges[N].Min,Ranges[N].Max) intervals.
  If either Ranges[N].MinInclEq or Ranges[N].MaxInclEq, or both flags are set to true then Min and Max values will be selected.
      @param qSoftLock - Set to true to ignore locks; in that case, locked fields can be selected.
  The default value is false.
    */
  async selectHyperCubeContinuousRange(qPath, qRanges, qSoftLock) {
    const params = {};
    params.qPath = qPath;
    params.qRanges = qRanges;
    if (qSoftLock !== void 0) {
      params.qSoftLock = qSoftLock;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SelectHyperCubeContinuousRange",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Returns the type of the object and the corresponding handle.
  
      @param qId - Identifier of the object.
    */
  async getChild(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetChild",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /**    Returns the type of the object and the corresponding handle to the parent object in the hiearchy.
  
    */
  async getParent() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetParent",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /**    Returns the identifier and the type for each child in an app object. If the child contains extra properties in qInfos , these properties are returned.
  
  Full dynamic properties are optional and are returned if they exist in the definition of the object.
  
    */
  async getChildInfos() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetChildInfos",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qInfos"];
    return response.map((r) => r);
  }
  /**    Creates a generic object that is a child of another generic object.
  It is possible to update the properties of the child's parent at the same time that the child is created. Both operations are performed by the same call. It is possible to create a child that is linked to another generic object. The two objects have the same properties.
  
      @param qProp - Information about the child.
  It is possible to create a child that is linked to another object.
      @param qPropForThis - Identifier of the parent's object.
  Should be set to update the properties of the parent's object at the same time the child is created.
    */
  async createChild({
    qBookmarkListDef: { qType = "bookmark", ...restQBookmarkListDef } = { qType: "bookmark" },
    qHyperCubeDef: {
      qMaxStackedCells = 5e3,
      qMode = "DATA_MODE_STRAIGHT",
      qNoOfLeftDims = -1,
      qPseudoDimPos = -1,
      ...restQHyperCubeDef
    } = {
      qMaxStackedCells: 5e3,
      qMode: "DATA_MODE_STRAIGHT",
      qNoOfLeftDims: -1,
      qPseudoDimPos: -1
    },
    qListObjectDef: { qFrequencyMode = "NX_FREQUENCY_NONE", ...restQListObjectDef } = { qFrequencyMode: "NX_FREQUENCY_NONE" },
    qNxLibraryDimensionDef: { coloring: { baseColor: { index = 6, ...restQNxLibraryDimensionDefColoringBaseColor } = { index: 6 }, ...restQNxLibraryDimensionDefColoring } = { baseColor: { index: 6 } }, ...restQNxLibraryDimensionDef } = { coloring: { baseColor: { index: 6 } } },
    qNxLibraryMeasureDef: { qNumFormat: { qType: qType2 = "UNKNOWN", qnDec = 10, ...restQNxLibraryMeasureDefQNumFormat } = { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: index2 = 6, ...restQNxLibraryMeasureDefColoringBaseColor } = { index: 6 }, gradient: { limitType = "percent", ...restQNxLibraryMeasureDefColoringGradient } = { limitType: "percent" }, ...restQNxLibraryMeasureDefColoring } = { baseColor: { index: 6 }, gradient: { limitType: "percent" } }, ...restQNxLibraryMeasureDef } = { qNumFormat: { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: 6 }, gradient: { limitType: "percent" } } },
    qVariableListDef: {
      qData: { tags = "/tags", ...restQVariableListDefQData } = { tags: "/tags" },
      qShowConfig = true,
      qShowReserved = true,
      qType: qType3 = "variable",
      ...restQVariableListDef
    } = {
      qData: { tags: "/tags" },
      qShowConfig: true,
      qShowReserved: true,
      qType: "variable"
    },
    ...rest
  } = {}, {
    qBookmarkListDef: { qType: qType4 = "bookmark", ...rest2QBookmarkListDef } = { qType: "bookmark" },
    qHyperCubeDef: {
      qMaxStackedCells: qMaxStackedCells2 = 5e3,
      qMode: qMode2 = "DATA_MODE_STRAIGHT",
      qNoOfLeftDims: qNoOfLeftDims2 = -1,
      qPseudoDimPos: qPseudoDimPos2 = -1,
      ...rest2QHyperCubeDef
    } = {
      qMaxStackedCells: 5e3,
      qMode: "DATA_MODE_STRAIGHT",
      qNoOfLeftDims: -1,
      qPseudoDimPos: -1
    },
    qListObjectDef: { qFrequencyMode: qFrequencyMode2 = "NX_FREQUENCY_NONE", ...rest2QListObjectDef } = { qFrequencyMode: "NX_FREQUENCY_NONE" },
    qNxLibraryDimensionDef: { coloring: { baseColor: { index: index3 = 6, ...rest2QNxLibraryDimensionDefColoringBaseColor } = { index: 6 }, ...rest2QNxLibraryDimensionDefColoring } = { baseColor: { index: 6 } }, ...rest2QNxLibraryDimensionDef } = { coloring: { baseColor: { index: 6 } } },
    qNxLibraryMeasureDef: { qNumFormat: { qType: qType5 = "UNKNOWN", qnDec: qnDec2 = 10, ...rest2QNxLibraryMeasureDefQNumFormat } = { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: index4 = 6, ...rest2QNxLibraryMeasureDefColoringBaseColor } = { index: 6 }, gradient: { limitType: limitType2 = "percent", ...rest2QNxLibraryMeasureDefColoringGradient } = { limitType: "percent" }, ...rest2QNxLibraryMeasureDefColoring } = { baseColor: { index: 6 }, gradient: { limitType: "percent" } }, ...rest2QNxLibraryMeasureDef } = { qNumFormat: { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: 6 }, gradient: { limitType: "percent" } } },
    qVariableListDef: {
      qData: { tags: tags2 = "/tags", ...rest2QVariableListDefQData } = { tags: "/tags" },
      qShowConfig: qShowConfig2 = true,
      qShowReserved: qShowReserved2 = true,
      qType: qType6 = "variable",
      ...rest2QVariableListDef
    } = {
      qData: { tags: "/tags" },
      qShowConfig: true,
      qShowReserved: true,
      qType: "variable"
    },
    ...rest2
  } = {}) {
    const params = {};
    params.qProp = {
      qBookmarkListDef: { qType, ...restQBookmarkListDef },
      qHyperCubeDef: {
        qMaxStackedCells,
        qMode,
        qNoOfLeftDims,
        qPseudoDimPos,
        ...restQHyperCubeDef
      },
      qListObjectDef: { qFrequencyMode, ...restQListObjectDef },
      qNxLibraryDimensionDef: { coloring: { baseColor: { index, ...restQNxLibraryDimensionDefColoringBaseColor }, ...restQNxLibraryDimensionDefColoring }, ...restQNxLibraryDimensionDef },
      qNxLibraryMeasureDef: { qNumFormat: { qType: qType2, qnDec, ...restQNxLibraryMeasureDefQNumFormat }, coloring: { baseColor: { index: index2, ...restQNxLibraryMeasureDefColoringBaseColor }, gradient: { limitType, ...restQNxLibraryMeasureDefColoringGradient }, ...restQNxLibraryMeasureDefColoring }, ...restQNxLibraryMeasureDef },
      qVariableListDef: {
        qData: { tags, ...restQVariableListDefQData },
        qShowConfig,
        qShowReserved,
        qType: qType3,
        ...restQVariableListDef
      },
      ...rest
    };
    params.qPropForThis = {
      qBookmarkListDef: { qType: qType4, ...rest2QBookmarkListDef },
      qHyperCubeDef: {
        qMaxStackedCells: qMaxStackedCells2,
        qMode: qMode2,
        qNoOfLeftDims: qNoOfLeftDims2,
        qPseudoDimPos: qPseudoDimPos2,
        ...rest2QHyperCubeDef
      },
      qListObjectDef: { qFrequencyMode: qFrequencyMode2, ...rest2QListObjectDef },
      qNxLibraryDimensionDef: { coloring: { baseColor: { index: index3, ...rest2QNxLibraryDimensionDefColoringBaseColor }, ...rest2QNxLibraryDimensionDefColoring }, ...rest2QNxLibraryDimensionDef },
      qNxLibraryMeasureDef: { qNumFormat: { qType: qType5, qnDec: qnDec2, ...rest2QNxLibraryMeasureDefQNumFormat }, coloring: { baseColor: { index: index4, ...rest2QNxLibraryMeasureDefColoringBaseColor }, gradient: { limitType: limitType2, ...rest2QNxLibraryMeasureDefColoringGradient }, ...rest2QNxLibraryMeasureDefColoring }, ...rest2QNxLibraryMeasureDef },
      qVariableListDef: {
        qData: { tags: tags2, ...rest2QVariableListDefQData },
        qShowConfig: qShowConfig2,
        qShowReserved: qShowReserved2,
        qType: qType6,
        ...rest2QVariableListDef
      },
      ...rest2
    };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CreateChild",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /**    Removes a child object.
  It is possible to update the properties of the child's parent at the same time that the child is removed. Both operations are performed by the same call. Removing a linked object, invalidate the linking object.
  
  The operation is successful if qSuccess is set to true.
  
      @param qId - Identifier of the child to remove.
      @param qPropForThis - Identifier of the parent's object and property to update.
  Should be set to update the properties of the parent's object at the same time the child is created.
    */
  async destroyChild(qId, {
    qBookmarkListDef: { qType = "bookmark", ...restQBookmarkListDef } = { qType: "bookmark" },
    qHyperCubeDef: {
      qMaxStackedCells = 5e3,
      qMode = "DATA_MODE_STRAIGHT",
      qNoOfLeftDims = -1,
      qPseudoDimPos = -1,
      ...restQHyperCubeDef
    } = {
      qMaxStackedCells: 5e3,
      qMode: "DATA_MODE_STRAIGHT",
      qNoOfLeftDims: -1,
      qPseudoDimPos: -1
    },
    qListObjectDef: { qFrequencyMode = "NX_FREQUENCY_NONE", ...restQListObjectDef } = { qFrequencyMode: "NX_FREQUENCY_NONE" },
    qNxLibraryDimensionDef: { coloring: { baseColor: { index = 6, ...restQNxLibraryDimensionDefColoringBaseColor } = { index: 6 }, ...restQNxLibraryDimensionDefColoring } = { baseColor: { index: 6 } }, ...restQNxLibraryDimensionDef } = { coloring: { baseColor: { index: 6 } } },
    qNxLibraryMeasureDef: { qNumFormat: { qType: qType2 = "UNKNOWN", qnDec = 10, ...restQNxLibraryMeasureDefQNumFormat } = { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: index2 = 6, ...restQNxLibraryMeasureDefColoringBaseColor } = { index: 6 }, gradient: { limitType = "percent", ...restQNxLibraryMeasureDefColoringGradient } = { limitType: "percent" }, ...restQNxLibraryMeasureDefColoring } = { baseColor: { index: 6 }, gradient: { limitType: "percent" } }, ...restQNxLibraryMeasureDef } = { qNumFormat: { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: 6 }, gradient: { limitType: "percent" } } },
    qVariableListDef: {
      qData: { tags = "/tags", ...restQVariableListDefQData } = { tags: "/tags" },
      qShowConfig = true,
      qShowReserved = true,
      qType: qType3 = "variable",
      ...restQVariableListDef
    } = {
      qData: { tags: "/tags" },
      qShowConfig: true,
      qShowReserved: true,
      qType: "variable"
    },
    ...rest
  } = {}) {
    const params = {};
    params.qId = qId;
    params.qPropForThis = {
      qBookmarkListDef: { qType, ...restQBookmarkListDef },
      qHyperCubeDef: {
        qMaxStackedCells,
        qMode,
        qNoOfLeftDims,
        qPseudoDimPos,
        ...restQHyperCubeDef
      },
      qListObjectDef: { qFrequencyMode, ...restQListObjectDef },
      qNxLibraryDimensionDef: { coloring: { baseColor: { index, ...restQNxLibraryDimensionDefColoringBaseColor }, ...restQNxLibraryDimensionDefColoring }, ...restQNxLibraryDimensionDef },
      qNxLibraryMeasureDef: { qNumFormat: { qType: qType2, qnDec, ...restQNxLibraryMeasureDefQNumFormat }, coloring: { baseColor: { index: index2, ...restQNxLibraryMeasureDefColoringBaseColor }, gradient: { limitType, ...restQNxLibraryMeasureDefColoringGradient }, ...restQNxLibraryMeasureDefColoring }, ...restQNxLibraryMeasureDef },
      qVariableListDef: {
        qData: { tags, ...restQVariableListDefQData },
        qShowConfig,
        qShowReserved,
        qType: qType3,
        ...restQVariableListDef
      },
      ...rest
    };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DestroyChild",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Removes all children and all children to the children on an object.
  
      @param qPropForThis - Identifier of the parent's object and property to update.
  Should be set to update the properties of the parent's object at the same time the child is created.
    */
  async destroyAllChildren({
    qBookmarkListDef: { qType = "bookmark", ...restQBookmarkListDef } = { qType: "bookmark" },
    qHyperCubeDef: {
      qMaxStackedCells = 5e3,
      qMode = "DATA_MODE_STRAIGHT",
      qNoOfLeftDims = -1,
      qPseudoDimPos = -1,
      ...restQHyperCubeDef
    } = {
      qMaxStackedCells: 5e3,
      qMode: "DATA_MODE_STRAIGHT",
      qNoOfLeftDims: -1,
      qPseudoDimPos: -1
    },
    qListObjectDef: { qFrequencyMode = "NX_FREQUENCY_NONE", ...restQListObjectDef } = { qFrequencyMode: "NX_FREQUENCY_NONE" },
    qNxLibraryDimensionDef: { coloring: { baseColor: { index = 6, ...restQNxLibraryDimensionDefColoringBaseColor } = { index: 6 }, ...restQNxLibraryDimensionDefColoring } = { baseColor: { index: 6 } }, ...restQNxLibraryDimensionDef } = { coloring: { baseColor: { index: 6 } } },
    qNxLibraryMeasureDef: { qNumFormat: { qType: qType2 = "UNKNOWN", qnDec = 10, ...restQNxLibraryMeasureDefQNumFormat } = { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: index2 = 6, ...restQNxLibraryMeasureDefColoringBaseColor } = { index: 6 }, gradient: { limitType = "percent", ...restQNxLibraryMeasureDefColoringGradient } = { limitType: "percent" }, ...restQNxLibraryMeasureDefColoring } = { baseColor: { index: 6 }, gradient: { limitType: "percent" } }, ...restQNxLibraryMeasureDef } = { qNumFormat: { qType: "UNKNOWN", qnDec: 10 }, coloring: { baseColor: { index: 6 }, gradient: { limitType: "percent" } } },
    qVariableListDef: {
      qData: { tags = "/tags", ...restQVariableListDefQData } = { tags: "/tags" },
      qShowConfig = true,
      qShowReserved = true,
      qType: qType3 = "variable",
      ...restQVariableListDef
    } = {
      qData: { tags: "/tags" },
      qShowConfig: true,
      qShowReserved: true,
      qType: "variable"
    },
    ...rest
  } = {}) {
    const params = {};
    params.qPropForThis = {
      qBookmarkListDef: { qType, ...restQBookmarkListDef },
      qHyperCubeDef: {
        qMaxStackedCells,
        qMode,
        qNoOfLeftDims,
        qPseudoDimPos,
        ...restQHyperCubeDef
      },
      qListObjectDef: { qFrequencyMode, ...restQListObjectDef },
      qNxLibraryDimensionDef: { coloring: { baseColor: { index, ...restQNxLibraryDimensionDefColoringBaseColor }, ...restQNxLibraryDimensionDefColoring }, ...restQNxLibraryDimensionDef },
      qNxLibraryMeasureDef: { qNumFormat: { qType: qType2, qnDec, ...restQNxLibraryMeasureDefQNumFormat }, coloring: { baseColor: { index: index2, ...restQNxLibraryMeasureDefColoringBaseColor }, gradient: { limitType, ...restQNxLibraryMeasureDefColoringGradient }, ...restQNxLibraryMeasureDefColoring }, ...restQNxLibraryMeasureDef },
      qVariableListDef: {
        qData: { tags, ...restQVariableListDefQData },
        qShowConfig,
        qShowReserved,
        qType: qType3,
        ...restQVariableListDef
      },
      ...rest
    };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "DestroyAllChildren",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Sets the order of the children in a generic object.
  To change the order of the children in a generic object, the identifiers of all the children must be included in the list of the identifiers (in qIds ).
  
      @param qIds - List of the children identifiers.
    */
  async setChildArrayOrder(qIds) {
    const params = {};
    params.qIds = qIds;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetChildArrayOrder",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Lists the linked objects to a generic object, a dimension or a measure.
  
    */
  async getLinkedObjects() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetLinkedObjects",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qItems"];
    return response.map((r) => r);
  }
  /**    Copies the properties of a generic object and its children.
  The source object is specified by the parameter qFromId and the destination object is referenced by its handle.
  The identifier of the destination object is the same as before the copy takes place.
  
      @param qFromId - Identifier of the object to copy.
    */
  async copyFrom(qFromId) {
    const params = {};
    params.qFromId = qFromId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CopyFrom",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Begins the selection mode. The app enters the modal state. The specified object enters the selection mode and a modal window is opened. The selection mode can apply to only one object in an app at a time.
  When a visualization is in selection mode, selections can be made in this visualization. The visualization is not sorted until the selection mode is ended. Once the selection mode is ended and if the selections are accepted, the visualization is sorted according to the sort criteria. For more information about:
  
  • Ending the selection mode, see EndSelections Method.
  
  • The sort criteria, see ListObjectDef or HyperCubeDef.
  
   Example:
  A sheet contains a list object and a chart. If the list object is in selection mode then the chart cannot be in selection mode. No selection on the chart can be made until the list object exits the selection mode.
  
      @param qPaths - List of the paths to the definition of the objects to enter selection mode.
  For example, /qListObjectDef .
    */
  async beginSelections(qPaths) {
    const params = {};
    params.qPaths = qPaths;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "BeginSelections",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Ends the selection mode on a visualization. The selections are accepted or aborted when exiting the selection mode, depending on the qAccept parameter value.
  
      @param qAccept - Set this parameter to true to accept the selections before exiting the selection mode.
    */
  async endSelections(qAccept) {
    const params = {};
    params.qAccept = qAccept;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "EndSelections",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Resets all selections made in selection mode.
  
    */
  async resetMadeSelections() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ResetMadeSelections",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Adds a snapshot to a generic object.
  Only one snapshot can be embedded in a generic object. If you embed a snapshot in an object that already contains a snapshot, the new snapshot overwrites the previous one.
  
      @param qId - Identifier of the bookmark.
    */
  async embedSnapshotObject(qId) {
    const params = {};
    params.qId = qId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "EmbedSnapshotObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Returns the type of the object and the corresponding handle.
  
    */
  async getSnapshotObject() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetSnapshotObject",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new GenericObject(response, this.session, this.auth);
    return obj;
  }
  /**    Publishes a generic object.
  This operation is not applicable for Qlik Sense Desktop.
  
    */
  async publish() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Publish",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Unpublishes a generic object.
  This operation is not applicable for Qlik Sense Desktop.
  
    */
  async unPublish() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "UnPublish",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Adds the generic object to the list of approved objects
  This operation is possible only in Qlik Sense Enterprise.
  
    */
  async approve() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "Approve",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Removes the generic object from the list of approved objects
  This operation is possible only in Qlik Sense Enterprise.
  
    */
  async unApprove() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "UnApprove",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  on(event, listener) {
    if (!this.session.eventListeners) {
      this.session.eventListeners = {
        [this.qHandle]: {
          [event]: [listener]
        }
      };
    } else {
      if (!this.session.eventListeners[this.qHandle]) {
        this.session.eventListeners[this.qHandle] = {};
      }
      if (this.session.eventListeners[this.qHandle][event]) {
        this.session.eventListeners[this.qHandle][event].push(listener);
      } else {
        this.session.eventListeners[this.qHandle][event] = [listener];
      }
    }
  }
  once(event, listener) {
    let called = false;
    this.on(event, (...args) => {
      if (!called) {
        called = true;
        listener(...args);
      }
    });
  }
}
class GenericVariable {
  constructor({
    qGenericId,
    qGenericType,
    qHandle,
    qType,
    ...rest
  }, session, auth) {
    this.auth = auth;
    this.session = session;
    this.qGenericId = qGenericId;
    this.qGenericType = qGenericType;
    this.qHandle = qHandle;
    this.qType = qType;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
  /**    Evaluates an object and displays its properties including the dynamic properties.
  If the member delta is set to true in the request object, only the delta is evaluated.
  
    */
  async getLayout() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetLayout",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qLayout"];
  }
  /**    Applies a patch to the properties of a variable. Allows an update to some of the properties. It should not be possible to patch "/qInfo/qId",
  and it will be forbidden in the near future.
  Applying a patch takes less time than resetting all the properties.
  
      @param qPatches - Array of patches.
    */
  async applyPatches(qPatches) {
    const params = {};
    params.qPatches = qPatches;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ApplyPatches",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Sets some properties for a variable.
  The identifier of a variable cannot be modified. You cannot update the properties of a script-defined variable using the SetProperties method.
  
      @param qProp - Information about the variable.
    */
  async setProperties({ qNumberPresentation: { qType = "UNKNOWN", qnDec = 10, ...restQNumberPresentation } = { qType: "UNKNOWN", qnDec: 10 }, ...rest } = {}) {
    const params = {};
    params.qProp = { qNumberPresentation: { qType, qnDec, ...restQNumberPresentation }, ...rest };
    params.qProp.qInfo = { qType: "variable" };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetProperties",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Shows the properties of an object.
  If the member delta is set to true in the request, only the delta is retrieved.
  The following is always returned in the output:
  
    */
  async getProperties() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetProperties",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qProp"];
  }
  /**    Returns the type and identifier of the object.
  
    */
  async getInfo() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetInfo",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qInfo"];
  }
  /**    Sets a string value to a variable.
  These changes are not persistent. They only last the duration of the engine session.
  
      @param qVal - Value of the variable. The string can contain an expression.
    */
  async setStringValue(qVal) {
    const params = {};
    params.qVal = qVal;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetStringValue",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Sets a numerical value to a variable.
  These changes are not persistent. They only last the duration of the engine session.
  
      @param qVal - Value of the variable.
    */
  async setNumValue(qVal) {
    const params = {};
    params.qVal = qVal;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetNumValue",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Sets the value of a dual variable.
  These changes are not persistent. They only last the duration of the engine session.
  
      @param qText - String representation of a dual value. Set this parameter to "", if the string representation is to be Null.
      @param qNum - Numeric representation of a dual value.
    */
  async setDualValue(qText, qNum) {
    const params = {};
    params.qText = qText;
    params.qNum = qNum;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetDualValue",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Returns the raw value of a variable.
  
    */
  async getRawContent() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetRawContent",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  on(event, listener) {
    if (!this.session.eventListeners) {
      this.session.eventListeners = {
        [this.qHandle]: {
          [event]: [listener]
        }
      };
    } else {
      if (!this.session.eventListeners[this.qHandle]) {
        this.session.eventListeners[this.qHandle] = {};
      }
      if (this.session.eventListeners[this.qHandle][event]) {
        this.session.eventListeners[this.qHandle][event].push(listener);
      } else {
        this.session.eventListeners[this.qHandle][event] = [listener];
      }
    }
  }
  once(event, listener) {
    let called = false;
    this.on(event, (...args) => {
      if (!called) {
        called = true;
        listener(...args);
      }
    });
  }
}
class Global {
  constructor({
    qGenericId,
    qGenericType,
    qHandle,
    qType,
    ...rest
  }, session, auth) {
    this.auth = auth;
    this.session = session;
    this.qGenericId = qGenericId;
    this.qGenericType = qGenericType;
    this.qHandle = qHandle;
    this.qType = qType;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
  /**    Sets an abort flag on a specific request in the current engine session.
  
  • If an abort flag is set on a pending request, the request is aborted.
  
  • If an abort flag is set on an ongoing request, the engine checks to see if it is possible to abort the request.
  
      @param qRequestId - Identifier of request to abort.
    */
  async abortRequest(qRequestId) {
    const params = {};
    params.qRequestId = qRequestId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "AbortRequest",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Sets an abort flag on all pending and ongoing requests in the current engine session.
  
  • If an abort flag is set on a pending request, the request is aborted.
  
  • If an abort flag is set on an ongoing request, the engine checks to see if it is possible to abort the request.
  
    */
  async abortAll() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "AbortAll",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Gives information about the progress of the DoReload and DoSave calls.
  For more information on DoReload and DoSave, see the DoReload Method and DoSave Method.
  
      @param qRequestId - Identifier of the DoReload or DoSave request or 0.
  Complete information is returned if the identifier of the request is given.
  If the identifier is 0, less information is given. Progress messages and error messages are returned but information like when the request started and finished is not returned.
    */
  async getProgress(qRequestId) {
    const params = {};
    params.qRequestId = qRequestId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetProgress",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qProgressData"];
  }
  /**    Retrieves information on the user interaction that is requested by the engine.
  Engine can request user interactions only during script reload and when the reload is performed in debug mode ( qDebug is set to true when using the DoReload method ).
  When running reload in debug mode, the engine pauses the script execution to receive data about user interaction. The engine can pause:
  
  • Before executing a new script statement.
  
  • When an error occurs while executing the script.
  
  • When the script execution is finished.
  
  To know if the engine is paused and waits for a response to an interaction request, the GetProgress method should be used. The engine waits for a response if the property qUserInteractionWanted is set to true in the response of the GetProgress request.
  
      @param qRequestId - Identifier of the request.
  Corresponds to the identifier of the DoReload request.
    */
  async getInteract(qRequestId) {
    const params = {};
    params.qRequestId = qRequestId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetInteract",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"];
  }
  /**    Informs the engine that a user interaction (which was earlier requested by the engine) was performed and indicates to the engine what to do next.
  
      @param qRequestId - Identifier of the request.
  Corresponds to the identifier of the DoReload request.
      @param qDef - User response to the current interaction.
    */
  async interactDone(qRequestId, qDef) {
    const params = {};
    params.qRequestId = qRequestId;
    params.qDef = qDef;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "InteractDone",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Retrieves information about the authenticated user.
  
    */
  async getAuthenticatedUser() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetAuthenticatedUser",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Returns the handle of the current app.
  
    */
  async getActiveDoc() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetActiveDoc",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new Doc(response, this.session, this.auth);
    return obj;
  }
  /**    Indicates whether or not a user is able to create an app.
  
    */
  async allowCreateApp() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "AllowCreateApp",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Indicates whether the user is working in Qlik Sense Desktop.
  
    */
  async isDesktopMode() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "IsDesktopMode",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Cancels an ongoing request. The request is stopped.
  
      @param qRequestId - Identifier of the request to stop.
    */
  async cancelRequest(qRequestId) {
    const params = {};
    params.qRequestId = qRequestId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CancelRequest",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Shuts down the Qlik engine.
  This operation is possible only in Qlik Sense Desktop.
  
    */
  async shutdownProcess() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ShutdownProcess",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Replaces objects of a target app with the objects from a source app.
  The list of objects in the app to be replaced must be defined in qIds.
  The data model of the app cannot be updated.  This operation is possible only in Qlik Sense Enterprise.
  
  The operation is successful if qSuccess is set to true.
  
      @param qTargetAppId - Identifier (GUID) of the target app.
  The target app is the app to be replaced.
      @param qSrcAppID - Identifier (GUID) of the source app.
  The objects in the source app will replace the objects in the target app.
      @param qIds - QRS identifiers (GUID) of the objects in the target app to be replaced. Only QRS-approved GUIDs are applicable.
  An object that is QRS-approved, is for example an object that has been published (for example, not private anymore).
  If an object is private, it should not be included in this list.
  If the array of identifiers contains objects that are not present in the source app, the objects related to these identifiers are removed from the target app.
  If qIds is empty, no objects are deleted in the target app.
    */
  async replaceAppFromID(qTargetAppId, qSrcAppID, qIds) {
    const params = {};
    params.qTargetAppId = qTargetAppId;
    params.qSrcAppID = qSrcAppID;
    params.qIds = qIds;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ReplaceAppFromID",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qSuccess"];
    return response;
  }
  /**    Publishes an app to the supplied stream.
  
      @param qAppId - The Id of the app to publish.
      @param qName - The name of the app to publish.
      @param qStreamId - The stream Id of the app to publish.
    */
  async publishApp(qAppId, qName, qStreamId) {
    const params = {};
    params.qAppId = qAppId;
    params.qName = qName;
    params.qStreamId = qStreamId;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "PublishApp",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Indicates whether or not the user is working in personal mode (Qlik Sense Desktop).
      @deprecated
  
    */
  async isPersonalMode() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "IsPersonalMode",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Returns the unique identifier of the endpoint for the current user in the current app.
  This unique identifier can be used for logging purposes.
  
    */
  async getUniqueID() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetUniqueID",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qUniqueID"];
    return response;
  }
  /**    Opens an app and checks if the app needs to be migrated (if the app is deprecated).
  The OpenDoc method compares the version of the app with the version of Qlik Sense and migrates the app to the current version of Qlik Sense if necessary. Once the migration is done, the app is opened.
  If no migration is needed, the app is opened immediately.
  The following applies:
  
  • The app version is lower than 0.95: no migration is done. Apps older than the version 0.95 are not supported.
  
  • The app version is at least 0.95 and less than the Qlik Sense version: the app is migrated and then opened.
  
  • Qlik Sense and the app have the same version: the app is opened, no migration is needed.
  
  If the app is read-only, the app migration cannot occur. An error message is sent.
  
   Backups:
  In Qlik Sense Desktop, apps are automatically backed up before a migration.
  The backup files are located in %userprofile%\Documents\Qlik\Sense\AppsBackup\<Qlik Sense Desktop version>.
  In Qlik Sense Enterprise, no automatic back up is run. The back up should be done manually.
  
      @param qDocName - The GUID (in Qlik Sense Enterprise) or Name (in Qlik Sense Desktop) of the app to retrieve.
      @param qUserName - Name of the user that opens the app.
      @param qPassword - Password of the user.
      @param qSerial - Current Qlik Sense serial number.
      @param qNoData - Set this parameter to true to be able to open an app without loading its data.
  When this parameter is set to true, the objects in the app are present but contain no data. The script can be edited and reloaded.
  The default value is false.
    */
  async openDoc(qDocName, qUserName, qPassword, qSerial, qNoData) {
    const params = {};
    params.qDocName = qDocName;
    if (qUserName !== void 0) {
      params.qUserName = qUserName;
    }
    if (qPassword !== void 0) {
      params.qPassword = qPassword;
    }
    if (qSerial !== void 0) {
      params.qSerial = qSerial;
    }
    if (qNoData !== void 0) {
      params.qNoData = qNoData;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "OpenDoc",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    const obj = new Doc(response, this.session, this.auth);
    return obj;
  }
  /**    Returns the Qlik Sense version number.
      @deprecated
  
    */
  async productVersion() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ProductVersion",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Retrieves the meta data of an app.
  
      @param qAppID - Identifier of the app, as returned by the CreateApp method.
  One of:
  
  • Path and name of the app (Qlik Sense Desktop)
  
  • GUID (Qlik Sense Enterprise)
    */
  async getAppEntry(qAppID) {
    const params = {};
    params.qAppID = qAppID;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetAppEntry",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qEntry"];
  }
  /**    Configures the engine's behavior during a reload.
  The ConfigureReload method should be run before the DoReload method.
  
      @param qCancelOnScriptError - If set to true, the script execution is halted on error.
  Otherwise, the engine continues the script execution.
  This parameter is relevant only if the variable ErrorMode is set to 1.
      @param qUseErrorData - If set to true, any script execution error is returned in qErrorData by the GetProgress method.
      @param qInteractOnError - If set to true, the script execution is halted on error and the engine is waiting for an interaction to be performed. If the result from the interaction is 1 (qDef.qResult is 1), the engine continues the script execution otherwise the execution is halted.
  This parameter is relevant only if the variable ErrorMode is set to 1 and the script is run in debug mode (qDebug is set to true when calling the DoReload method).
    */
  async configureReload(qCancelOnScriptError, qUseErrorData, qInteractOnError) {
    const params = {};
    params.qCancelOnScriptError = qCancelOnScriptError;
    params.qUseErrorData = qUseErrorData;
    params.qInteractOnError = qInteractOnError;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ConfigureReload",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Cancels an ongoing reload. The reload of the app is stopped. The indexation can be canceled and true is still the return value of the reload task.
  
    */
  async cancelReload() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "CancelReload",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Gets the current Backus-Naur Form (BNF) grammar of the Qlik engine scripting language. The BNF rules define the syntax for the script statements and the script or chart functions.
  In the Qlik engine BNF grammar, a token is a string of one or more characters that is significant as a group. For example, a token could be a function name, a number, a letter, a parenthesis, and so on.
      @deprecated
      @param qBnfType - Returns a set of rules defining the syntax for:
  
  • The script statements and the script functions if qBnfType is set to S.
  
  • The chart functions if qBnfType is set to E.
  
  One of:
  
  • S or SCRIPT_TEXT_SCRIPT
  
  • E or SCRIPT_TEXT_EXPRESSION
    */
  async getBNF(qBnfType) {
    const params = {};
    params.qBnfType = qBnfType;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetBNF",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qBnfDefs"];
    return response.map((r) => r);
  }
  /**    Gets the list of all the script functions.
  
      @param qGroup - Name of the group.
  Default is all groups.
  
  One of:
  
  • ALL or FUNC_GROUP_ALL
  
  • U or FUNC_GROUP_UNKNOWN
  
  • NONE or FUNC_GROUP_NONE
  
  • AGGR or FUNC_GROUP_AGGR
  
  • NUM or FUNC_GROUP_NUMERIC
  
  • RNG or FUNC_GROUP_RANGE
  
  • EXP or FUNC_GROUP_EXPONENTIAL_AND_LOGARITHMIC
  
  • TRIG or FUNC_GROUP_TRIGONOMETRIC_AND_HYPERBOLIC
  
  • FIN or FUNC_GROUP_FINANCIAL
  
  • MATH or FUNC_GROUP_MATH_CONSTANT_AND_PARAM_FREE
  
  • COUNT or FUNC_GROUP_COUNTER
  
  • STR or FUNC_GROUP_STRING
  
  • MAPP or FUNC_GROUP_MAPPING
  
  • RCRD or FUNC_GROUP_INTER_RECORD
  
  • CND or FUNC_GROUP_CONDITIONAL
  
  • LOG or FUNC_GROUP_LOGICAL
  
  • NULL or FUNC_GROUP_NULL
  
  • SYS or FUNC_GROUP_SYSTEM
  
  • FILE or FUNC_GROUP_FILE
  
  • TBL or FUNC_GROUP_TABLE
  
  • DATE or FUNC_GROUP_DATE_AND_TIME
  
  • NUMI or FUNC_GROUP_NUMBER_INTERPRET
  
  • FRMT or FUNC_GROUP_FORMATTING
  
  • CLR or FUNC_GROUP_COLOR
  
  • RNK or FUNC_GROUP_RANKING
  
  • GEO or FUNC_GROUP_GEO
  
  • EXT or FUNC_GROUP_EXTERNAL
  
  • PROB or FUNC_GROUP_PROBABILITY
  
  • ARRAY or FUNC_GROUP_ARRAY
  
  • LEG or FUNC_GROUP_LEGACY
  
  • DB or FUNC_GROUP_DB_NATIVE
    */
  async getFunctions(qGroup) {
    const params = {};
    if (qGroup !== void 0) {
      params.qGroup = qGroup;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetFunctions",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qFunctions"];
    return response.map((r) => r);
  }
  /**    Returns the list of the ODBC connectors that are installed in the system.
  
    */
  async getOdbcDsns() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetOdbcDsns",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qOdbcDsns"];
    return response.map((r) => r);
  }
  /**    Returns the list of the OLEDB providers installed on the system.
  
    */
  async getOleDbProviders() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetOleDbProviders",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qOleDbProviders"];
    return response.map((r) => r);
  }
  /**    Lists the databases in a ODBC, OLEDB or CUSTOM data source.
  
      @param qConnection - Information about the connection.
    */
  async getDatabasesFromConnectionString(qConnection) {
    const params = {};
    params.qConnection = qConnection;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetDatabasesFromConnectionString",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qDatabases"];
    return response.map((r) => r);
  }
  /**    Checks if a connection string is valid.
  
      @param qConnection - Information about the connection.
    */
  async isValidConnectionString(qConnection) {
    const params = {};
    params.qConnection = qConnection;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "IsValidConnectionString",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Returns the folder where the apps are stored.
  This method applies only if running Qlik Sense Desktop.
  
    */
  async getDefaultAppFolder() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetDefaultAppFolder",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qPath"];
    return response;
  }
  /**    Lists the logical drives in the system.
  This method applies only if running Qlik Sense Desktop.
  
    */
  async getLogicalDriveStrings() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetLogicalDriveStrings",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qDrives"];
    return response.map((r) => r);
  }
  /**    Returns the files and folders located at a specified path.
  
      @param qPath - Absolute or relative path.
  Relative paths are relative to the default Apps folder.
  
  In Qlik Sense Enterprise:
  
  The list is generated by the QRS. The GetDocList method only returns documents the current user is allowed to access.
  
  In Qlik Sense Desktop:
  
  The apps are located in C:\\Users\<user name>\Documents\Qlik\Sense\Apps.
    */
  async getFolderItemsForPath(qPath) {
    const params = {};
    params.qPath = qPath;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetFolderItemsForPath",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qFolderItems"];
    return response.map((r) => r);
  }
  /**    Lists the supported code pages.
  
    */
  async getSupportedCodePages() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetSupportedCodePages",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qCodePages"];
    return response.map((r) => r);
  }
  /**    List the custom connectors available in the system.
  
      @param qReloadList - Sets if the list of custom connectors should be reloaded or not.
  If set to false, only the connectors that were returned the previous time are returned. If new connectors have been added since the last call to the GetCustomConnectors method was made, the new connectors are not returned.
  If set to true, the GetCustomConnectors method looks for new connectors in the file system.
  The default value is false.
    */
  async getCustomConnectors(qReloadList) {
    const params = {};
    if (qReloadList !== void 0) {
      params.qReloadList = qReloadList;
    }
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetCustomConnectors",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qConnectors"];
    return response.map((r) => r);
  }
  /**    Lists the streams.
      @deprecated
  
    */
  async getStreamList() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetStreamList",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qStreamList"];
    return response.map((r) => r);
  }
  /**    Returns the version number of the Qlik engine component.
  
    */
  async engineVersion() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "EngineVersion",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qVersion"];
  }
  /**    Gets the current Backus-Naur Form (BNF) grammar of the Qlik engine scripting language, as well as a string hash calculated from that grammar. The BNF rules define the syntax for the script statements and the script or chart functions. If the hash changes between subsequent calls to this method, this indicates that the BNF has changed.
  In the Qlik engine grammars, a token is a string of one or more characters that is significant as a group. For example, a token could be a function name, a number, a letter, a parenthesis, and so on.
  
      @param qBnfType - The type of grammar to return:
  
  • The script statements and the script functions if qBnfType is set to S.
  
  • The chart functions if qBnfType is set to E.
  
  One of:
  
  • S or SCRIPT_TEXT_SCRIPT
  
  • E or SCRIPT_TEXT_EXPRESSION
    */
  async getBaseBNF(qBnfType) {
    const params = {};
    params.qBnfType = qBnfType;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetBaseBNF",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"];
  }
  /**    Gets a string hash calculated from the current Backus-Naur Form (BNF) grammar of the Qlik engine scripting language. If the hash changes between subsequent calls to this method, this indicates that the BNF grammar has changed.
  
      @param qBnfType - The type of grammar to return:
  
  • The script statements and the script functions if qBnfType is set to S.
  
  • The chart functions if qBnfType is set to E.
  
  One of:
  
  • S or SCRIPT_TEXT_SCRIPT
  
  • E or SCRIPT_TEXT_EXPRESSION
    */
  async getBaseBNFHash(qBnfType) {
    const params = {};
    params.qBnfType = qBnfType;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetBaseBNFHash",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qBnfHash"];
    return response;
  }
  /**    Gets the current Backus-Naur Form (BNF) grammar of the Qlik engine scripting language, as well as a string hash calculated from that grammar. The BNF rules define the syntax for the script statements and the script or chart functions. If the hash changes between subsequent calls to this method, this indicates that the BNF has changed.
  In the Qlik engine grammars, a token is a string of one or more characters that is significant as a group. For example, a token could be a function name, a number, a letter, a parenthesis, and so on.
  
      @param qBnfType - The type of grammar to return:
  
  • S: returns the script statements and the script functions.
  
  • E: returns the chart functions.
  
  One of:
  
  • S or SCRIPT_TEXT_SCRIPT
  
  • E or SCRIPT_TEXT_EXPRESSION
    */
  async getBaseBNFString(qBnfType) {
    const params = {};
    params.qBnfType = qBnfType;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetBaseBNFString",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"];
  }
  /**    Save a copy of an app with a different name.
  Can be used to save a session app as an ordinary app.
      @deprecated
      @param qNewAppName - <Name of the saved app>
    */
  async saveAs(qNewAppName) {
    const params = {};
    params.qNewAppName = qNewAppName;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SaveAs",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qNewAppId"];
    return response;
  }
  on(event, listener) {
    if (!this.session.eventListeners) {
      this.session.eventListeners = {
        [this.qHandle]: {
          [event]: [listener]
        }
      };
    } else {
      if (!this.session.eventListeners[this.qHandle]) {
        this.session.eventListeners[this.qHandle] = {};
      }
      if (this.session.eventListeners[this.qHandle][event]) {
        this.session.eventListeners[this.qHandle][event].push(listener);
      } else {
        this.session.eventListeners[this.qHandle][event] = [listener];
      }
    }
  }
  once(event, listener) {
    let called = false;
    this.on(event, (...args) => {
      if (!called) {
        called = true;
        listener(...args);
      }
    });
  }
}
class Variable {
  constructor({
    qGenericId,
    qGenericType,
    qHandle,
    qType,
    ...rest
  }, session, auth) {
    this.auth = auth;
    this.session = session;
    this.qGenericId = qGenericId;
    this.qGenericType = qGenericType;
    this.qHandle = qHandle;
    this.qType = qType;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
  /**    Returns the calculated value of a variable.
      @deprecated
  
    */
  async getContent() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetContent",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qContent"];
  }
  /**    Returns the raw value of a variable.
      @deprecated
  
    */
  async getRawContent() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetRawContent",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Sets a value to a variable.
    @deprecated
    @param qContent - Value of the variable.
    @param qUpdateMRU - If set to true, the value is added to the Most Recently Used (MRU) list.
  */
  async setContent(qContent, qUpdateMRU) {
    const params = {};
    params.qContent = qContent;
    params.qUpdateMRU = qUpdateMRU;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetContent",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"]["qReturn"];
    return response;
  }
  /**    Sets the value of a dual variable overriding any input constraints.
      @deprecated
      @param qs - String representation of a dual value.
  Set this parameter to "", if the string representation is to be Null.
      @param qd - Numeric representation of a dual value.
    */
  async forceContent(qs, qd) {
    const params = {};
    params.qs = qs;
    params.qd = qd;
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "ForceContent",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  /**    Gets the properties of a variable.
      @deprecated
  
    */
  async getNxProperties() {
    const params = {};
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "GetNxProperties",
      handle: this.qHandle || -1,
      params
    });
    return rawResponse["result"]["qProperties"];
  }
  /**    Sets some properties to a variable.
    @deprecated
    @param qProperties - Information about the properties of the variable
  */
  async setNxProperties({ qNumberPresentation: { qType = "UNKNOWN", qnDec = 10, ...restQNumberPresentation } = { qType: "UNKNOWN", qnDec: 10 }, ...rest } = {}) {
    const params = {};
    params.qProperties = { qNumberPresentation: { qType, qnDec, ...restQNumberPresentation }, ...rest };
    if (!this.session) {
      throw new GenericError("Socket Not Connected");
    }
    const rawResponse = await this.session.send({
      method: "SetNxProperties",
      handle: this.qHandle || -1,
      params
    });
    const response = rawResponse["result"];
    return response;
  }
  on(event, listener) {
    if (!this.session.eventListeners) {
      this.session.eventListeners = {
        [this.qHandle]: {
          [event]: [listener]
        }
      };
    } else {
      if (!this.session.eventListeners[this.qHandle]) {
        this.session.eventListeners[this.qHandle] = {};
      }
      if (this.session.eventListeners[this.qHandle][event]) {
        this.session.eventListeners[this.qHandle][event].push(listener);
      } else {
        this.session.eventListeners[this.qHandle][event] = [listener];
      }
    }
  }
  once(event, listener) {
    let called = false;
    this.on(event, (...args) => {
      if (!called) {
        called = true;
        listener(...args);
      }
    });
  }
}
class Qix extends Global {
}
export {
  Doc,
  Field,
  GenericBookmark,
  GenericDimension,
  GenericMeasure,
  GenericObject,
  GenericVariable,
  Global,
  Qix,
  Variable
};

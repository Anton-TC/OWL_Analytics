import Auth from "../auth/auth.js";
import ListableResource from "../listable.js";
import { Doc } from "./Qix.js";
class Evaluation {
  constructor({
    appId,
    appItemId,
    appName,
    details,
    ended,
    events,
    id,
    metadata,
    result,
    sheetId,
    sheetTitle,
    started,
    status,
    tenantId,
    timestamp,
    version,
    ...rest
  }, auth) {
    this.auth = auth;
    this.appId = appId;
    this.appItemId = appItemId;
    this.appName = appName;
    if (details !== void 0 && details !== null) {
      this.details = details;
    }
    this.ended = ended;
    if (events !== void 0 && events !== null) {
      this.events = events;
    }
    this.id = id;
    if (metadata !== void 0 && metadata !== null) {
      this.metadata = metadata;
    }
    if (result !== void 0 && result !== null) {
      this.result = result;
    }
    this.sheetId = sheetId;
    this.sheetTitle = sheetTitle;
    this.started = started;
    this.status = status;
    this.tenantId = tenantId;
    this.timestamp = timestamp;
    this.version = version;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
  /**    Find and download an evaluation log by a specific evaluation id.
  
    Download a detailed XML log of a specific evaluation
  
    */
  async download() {
    const response = await this.auth.rest(
      "/apps/evaluations/{id}/actions/download".replace("{id}", this.id ?? ""),
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new Evaluation(responseJson, this.auth);
  }
}
class NxApp extends Doc {
  constructor({
    attributes,
    create,
    privileges,
    ...rest
  }, auth) {
    super({
      qGenericId: "",
      qGenericType: "",
      qHandle: 0,
      qType: ""
    });
    this.auth = auth;
    if (attributes !== void 0 && attributes !== null) {
      this.attributes = attributes;
    }
    if (create !== void 0 && create !== null) {
      this.create = create;
    }
    this.privileges = privileges;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
  /**    Copies a specific app.
  
      @param data - Attributes that should be set in the copy.
    */
  async createCopy(data) {
    const response = await this.auth.rest(
      "/apps/{appId}/copy".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "POST",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    return new NxApp(responseJson, this.auth);
  }
  /**    Retrieves the lineage for an app.
  Returns a JSON-formatted array of strings describing the lineage of the app.
  
    */
  async getDataLineages() {
    const response = await this.auth.rest(
      "/apps/{appId}/data/lineage".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "GET"
      }
    );
    return response.json();
  }
  /**    Retrieves the data model and reload statistics metadata of an app.
  An empty metadata structure is returned if the metadata is not available in the app.
  
    */
  async getDataMetadata() {
    const response = await this.auth.rest(
      "/apps/{appId}/data/metadata".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "GET"
      }
    );
    return response.json();
  }
  /**    Exports a specific app.
  
      @param NoData - The flag indicating if only object contents should be exported.
    */
  async export(queryParams = {}) {
    const response = await this.auth.rest(
      `${"/apps/{appId}/export".replace("{appId}", this.attributes?.id ?? "")}?${new URLSearchParams(Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => [k, v.toString()])).toString()}`,
      {
        method: "POST"
      }
    );
    return response.headers.get("Location");
  }
  /**
    Returns analysis recommendations in response to a natural language question, a set of fields and master items, or a set of fields and master items with an optional target analysis.
  
      @param accept-language - language specified as an ISO-639-1 code. Defaults to 'en' (English).
      @param data - Request payload can be of two types, using natural language query or consist of fields or master items and optional target analysis.
  In below examples, consider sales as a master item and product as field, so to get recommendations using sales and product,
  you can utilize below three approaches, also you can set language parameter in headers as part of accept-language.
  Examples:
  ```
  {
    "text": "show me sales by product"
  }
  ```
  ```
  {
    "fields": [
      {
        "name": "product"
      }
    ],
    "libItems": [
      {
        libId: "NwQfJ"
      }
    ]
  }
  ```
  ```
  {
    "fields": [
      {
        "name": "product"
      }
    ],
    "libItems": [
      {
        "libId": "NwQfJ"
      }
    ],
    "targetAnalysis": {
      "id": "rank-rank"
    }
  }
  ```
  
    */
  async recommend(data) {
    const response = await this.auth.rest(
      "/apps/{appId}/insight-analyses/actions/recommend".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "POST",
        body: JSON.stringify(data)
      }
    );
    return response.json();
  }
  /**
    Returns information about model used to make analysis recommendations. Lists all fields and master items in the logical model, along with an indication of the validity of the logical model if the default is not used.
  
    */
  async getInsightAnalysesModels() {
    const response = await this.auth.rest(
      "/apps/{appId}/insight-analyses/model".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new ListableResource(responseJson, this.auth, null);
  }
  /**
    Returns information about supported analyses for the app's data model. Lists available analysis types, along with minimum and maximum number of dimensions, measures, and fields.
  
      @param accept-language - language specified as an ISO-639-1 code. Defaults to 'en' (English).
    */
  async getInsightAnalyses() {
    const response = await this.auth.rest(
      "/apps/{appId}/insight-analyses".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new ListableResource(responseJson, this.auth, null);
  }
  /**    Deletes a media content file or complete directory.
  Returns OK if the bytes containing the media file (or the complete content of a directory) were successfully deleted, or error in case of failure or lack of permission.
  
      @param path - Path to file content.
    */
  async deleteMediaFile(path) {
    await this.auth.rest(
      "/apps/{appId}/media/files/{path}".replace("{appId}", this.attributes?.id ?? "").replace("{path}", path),
      {
        method: "DELETE"
      }
    );
  }
  /**    Gets media content from file.
  Returns a stream of bytes containing the media file content on success, or error if file is not found.
  
      @param path - Path to file content.
    */
  async getMediaFile(path) {
    const response = await this.auth.rest(
      "/apps/{appId}/media/files/{path}".replace("{appId}", this.attributes?.id ?? "").replace("{path}", path),
      {
        method: "GET"
      }
    );
    return response.arrayBuffer();
  }
  /**    Stores the media content file.
  Returns OK if the bytes containing the media file content were successfully stored, or error in case of failure, lack of permission or file already exists on the supplied path.
  
      @param path - Path to file content.
      @param data -
    */
  async setMediaFile(path, data) {
    await this.auth.rest(
      "/apps/{appId}/media/files/{path}".replace("{appId}", this.attributes?.id ?? "").replace("{path}", path),
      {
        method: "PUT",
        body: data
      }
    );
  }
  /**    Lists media content.
  Returns a JSON formatted array of strings describing the available media content or error if the optional path supplied is not found.
  
      @param path - The path to sub folder with static content relative to the root folder. Use empty path to access the root folder.
      @param show - Optional. List output can include files and folders in different ways:
  
  • Not recursive, default if show option is not supplied or incorrectly specified, results in output with files and empty directories for the path specified only.
  
  • Recursive(r), use ?show=r or ?show=recursive, results in a recursive output with files, all empty folders are excluded.
  
  • All(a), use ?show=a or ?show=all, results in a recursive output with files and empty directories.
    */
  async getMediaLists(path, queryParams = {}) {
    const response = await this.auth.rest(
      `${"/apps/{appId}/media/list/{path}".replace("{appId}", this.attributes?.id ?? "").replace("{path}", path)}?${new URLSearchParams(Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => [k, v.toString()])).toString()}`,
      {
        method: "GET"
      }
    );
    return response.json();
  }
  /**    Gets media content from file currently used as application thumbnail.
  Returns a stream of bytes containing the media file content on success, or error if file is not found.
  The image selected as thumbnail is only updated when application is saved.
  
    */
  async getMediaThumbnail() {
    const response = await this.auth.rest(
      "/apps/{appId}/media/thumbnail".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "GET"
      }
    );
    return response.arrayBuffer();
  }
  /**    Sets owner on an app object.
  
      @param objectId - Identifier of the object.
      @param data -
    */
  async changeOwner(objectId, data) {
    const response = await this.auth.rest(
      "/apps/{appId}/objects/{objectId}/actions/change-owner".replace("{appId}", this.attributes?.id ?? "").replace("{objectId}", objectId),
      {
        method: "POST",
        body: JSON.stringify(data)
      }
    );
    return response.json();
  }
  /**    Changes owner of the app.
  
      @param data -
    */
  async setOwner(data) {
    const response = await this.auth.rest(
      "/apps/{appId}/owner".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "PUT",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    Object.keys(responseJson).forEach((key) => {
      if (this[key]) {
        this[key] = responseJson[key];
      }
    });
    return this;
  }
  /**    Publishes a specific app to a managed space.
  
      @param data - Publish information for the app.
    */
  async publish(data) {
    const response = await this.auth.rest(
      "/apps/{appId}/publish".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "POST",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    return new NxApp(responseJson, this.auth);
  }
  /**    Republishes a published app to a managed space.
  
      @param data - Republish information for the app.
    */
  async setPublish(data) {
    const response = await this.auth.rest(
      "/apps/{appId}/publish".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "PUT",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    Object.keys(responseJson).forEach((key) => {
      if (this[key]) {
        this[key] = responseJson[key];
      }
    });
    return this;
  }
  /**    Retrieves the log of a specific reload.
  Returns the log as "text/plain; charset=UTF-8".
  
      @param reloadId - Identifier of the reload.
    */
  async getReloadsLog(reloadId) {
    const response = await this.auth.rest(
      "/apps/{appId}/reloads/logs/{reloadId}".replace("{appId}", this.attributes?.id ?? "").replace("{reloadId}", reloadId),
      {
        method: "GET"
      }
    );
    return response.arrayBuffer();
  }
  /**    Retrieves the metadata about all script logs stored for an app.
  Returns an array of ScriptLogMeta objects.
  
    */
  async getReloadsLogs() {
    const response = await this.auth.rest(
      "/apps/{appId}/reloads/logs".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "GET"
      }
    );
    return response.json();
  }
  /**    Deletes a specific version of the script for an app.
  Fails if the version to delete is the current version.
  
      @param version - Identifier of the script version
    */
  async deleteScript(version) {
    await this.auth.rest(
      "/apps/{appId}/scripts/{version}".replace("{appId}", this.attributes?.id ?? "").replace("{version}", version),
      {
        method: "DELETE"
      }
    );
  }
  /**    Retrieves a version of the script for an app.
  Returns the script text.
  
      @param version - Identifier of the script version, or 'current' for retrieving the current version.
    */
  async getScriptByVersion(version) {
    const response = await this.auth.rest(
      "/apps/{appId}/scripts/{version}".replace("{appId}", this.attributes?.id ?? "").replace("{version}", version),
      {
        method: "GET"
      }
    );
    return response.json();
  }
  /**    Updates a specific version of the script for an app.
  
      @param version - Identifier of the script version.
      @param data - Array of patches for the object ScriptVersion.
  Only /versionMessage can be modified using operations add, remove and replace.
    */
  async patchScript(version, data) {
    await this.auth.rest(
      "/apps/{appId}/scripts/{version}".replace("{appId}", this.attributes?.id ?? "").replace("{version}", version),
      {
        method: "PATCH",
        body: JSON.stringify(data)
      }
    );
  }
  /**    Retrieves the script history for an app.
  Returns information about the saved versions of the script.
  
      @param filter - A scim filter expression defining which script versions should be retrieved. Filterable fields are:
  
  • ScriptId
  
  • ModifiedTime
  
  • ModifierId
      @param limit - Maximum number of records to return from this request.
      @param page - Opaque definition of which page of the result set to return. Returned from a previous call using the same filter. Not yet supported.
    */
  async getScriptVersions(queryParams = {}) {
    const response = await this.auth.rest(
      `${"/apps/{appId}/scripts".replace("{appId}", this.attributes?.id ?? "")}?${new URLSearchParams(Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => [k, v.toString()])).toString()}`,
      {
        method: "GET"
      }
    );
    return response.json();
  }
  /**    Sets script for an app.
  
      @param data - The script to set.
    */
  async createScript(data) {
    await this.auth.rest(
      "/apps/{appId}/scripts".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "POST",
        body: JSON.stringify(data)
      }
    );
  }
  /**    Removes space from a specific app.
  
    */
  async deleteSpace() {
    const response = await this.auth.rest(
      "/apps/{appId}/space".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "DELETE"
      }
    );
    const responseJson = await response.json();
    Object.keys(responseJson).forEach((key) => {
      if (this[key]) {
        this[key] = responseJson[key];
      }
    });
    return this;
  }
  /**    Sets space on a specific app.
  
      @param data - New space.
    */
  async setSpace(data) {
    const response = await this.auth.rest(
      "/apps/{appId}/space".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "PUT",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    Object.keys(responseJson).forEach((key) => {
      if (this[key]) {
        this[key] = responseJson[key];
      }
    });
    return this;
  }
  /**    Deletes a specific app.
  
    */
  async delete() {
    await this.auth.rest(
      "/apps/{appId}".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "DELETE"
      }
    );
  }
  /**    Updates the information for a specific app.
  
      @param data - Attributes that user wants to set.
    */
  async set(data) {
    const response = await this.auth.rest(
      "/apps/{appId}".replace("{appId}", this.attributes?.id ?? ""),
      {
        method: "PUT",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    Object.keys(responseJson).forEach((key) => {
      if (this[key]) {
        this[key] = responseJson[key];
      }
    });
    return this;
  }
}
class Apps {
  constructor(config) {
    this.config = config instanceof Auth ? config.config : config;
    this.auth = config instanceof Auth ? config : new Auth(config);
  }
  /**    Accepts two evaluation ids and downloads a log, in XML format, denoting the differences between the two.
  
    Download a comparison log of two evaluations
  
      @param baseid - Id of the baseline evaluation
      @param comparisonid - Id of the comparison evaluation
    */
  async downloadAppsEvaluationsCompare(baseid, comparisonid) {
    const response = await this.auth.rest(
      "/apps/evaluations/{baseid}/actions/compare/{comparisonid}/actions/download".replace("{baseid}", baseid).replace("{comparisonid}", comparisonid),
      {
        method: "GET"
      }
    );
    return response.json();
  }
  /**    Accepts two evaluation ids and returns a comparison denoting the differences between the two.
  
    Compare two evaluations
  
      @param baseid - Id of the baseline evaluation
      @param comparisonid - Id of the comparison evaluation
      @param all - Get the full list of comparisons including non-significant diffs
      @param format - Specify output format, currently supported are 'json' and 'xml'
    */
  async compareAppsEvaluations(baseid, comparisonid, queryParams = {}) {
    const response = await this.auth.rest(
      `${"/apps/evaluations/{baseid}/actions/compare/{comparisonid}".replace("{baseid}", baseid).replace("{comparisonid}", comparisonid)}?${new URLSearchParams(Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => [k, v.toString()])).toString()}`,
      {
        method: "GET"
      }
    );
    return response.json();
  }
  /**    Find an evaluation by a specific id.
  
    Retrieve a specific evaluation
  
      @param id - Id of the desired evaluation.
      @param all - Get the full data of the evaluation
      @param format - Specify output format, currently supported are 'json' and 'xml'
    */
  async getEvaluation(id, queryParams = {}) {
    const response = await this.auth.rest(
      `${"/apps/evaluations/{id}".replace("{id}", id)}?${new URLSearchParams(Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => [k, v.toString()])).toString()}`,
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new Evaluation(responseJson, this.auth);
  }
  /**    Imports an app into the system.
  
      @param appId - The app ID of the target app when source is qvw file.
      @param fallbackName - The name of the target app when source does not have a specified name, applicable if source is qvw file.
      @param fileId - The file ID to be downloaded from Temporary Content Service (TCS) and used during import.
      @param mode - The import mode. In `new` mode (default), the source app will be imported as a new app.The `autoreplace` mode is an internal mode only and is not permitted for external use.
  
  One of:
  
  • NEW
  
  • AUTOREPLACE
      @param name - The name of the target app.
      @param NoData - If NoData is true, the data of the existing app will be kept as is, otherwise it will be replaced by the new incoming data.
      @param spaceId - The space ID of the target app.
      @param data - Path of the source app.
    */
  async importApp(data, queryParams = {}) {
    const response = await this.auth.rest(
      `/apps/import?${new URLSearchParams(Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => [k, v.toString()])).toString()}`,
      {
        method: "POST",
        body: data
      }
    );
    const responseJson = await response.json();
    return new NxApp(responseJson, this.auth);
  }
  /**    Gets the app privileges for the current user, such as create app and import app. Empty means that the current user has no app privileges.
  
    */
  async getPrivileges() {
    const response = await this.auth.rest(
      "/apps/privileges",
      {
        method: "GET"
      }
    );
    return response.json();
  }
  /**    Retrieves information for a specific app.
  
      @param appId - Identifier of the app.
    */
  async get(appId) {
    const response = await this.auth.rest(
      "/apps/{appId}".replace("{appId}", appId),
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new NxApp(responseJson, this.auth);
  }
  /**    Find all evaluations for an app GUID.
  Supports paging via next, prev which are sent in the response body
  
    Retrieve a list of all historic evaluations for an app GUID
  
      @param guid - The app guid.
      @param all - Get the full data of the evaluation
      @param fileMode - Add file transfer headers to response
      @param format - Specify output format, currently supported are 'json' and 'xml'
      @param limit - Number of results to return per page.
      @param next - The app evaluation id to get next page from
      @param prev - The app evaluation id to get previous page from
      @param sort - Property to sort list on
    */
  async getEvaluations(guid, queryParams = { limit: 20 }) {
    const response = await this.auth.rest(
      `${"/apps/{guid}/evaluations".replace("{guid}", guid)}?${new URLSearchParams(Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => [k, v.toString()])).toString()}`,
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new ListableResource(responseJson, this.auth, Evaluation, queryParams);
  }
  /**    Queue an app evaluation by its app guid.
  
    Queue an app evaluation
  
      @param guid - Guid of the app.
    */
  async createEvaluation(guid) {
    const response = await this.auth.rest(
      "/apps/{guid}/evaluations".replace("{guid}", guid),
      {
        method: "POST"
      }
    );
    const responseJson = await response.json();
    return new Evaluation(responseJson, this.auth);
  }
  /**    Creates a new app.
  
      @param data - Attributes that the user wants to set in new app.
    */
  async create(data) {
    const response = await this.auth.rest(
      "/apps",
      {
        method: "POST",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    return new NxApp(responseJson, this.auth);
  }
  /** Creates an empty session app
  * @param sessionAppId - a self generated 'app_id' prefixed with SessionApp_
  *
  * @example
  * ```js
  * const randomId = Math.random().toString(32).substring(3);
  * const appId = `SessionApp_${randomId}`;
  * const app = qlik.apps.createSessionApp(appId);
  * await app.open();
  * const script = `
  *   TempTable:
  *   Load
  *   RecNo() as Field1,
  *   Rand() as Field2,
  *   Rand() as Field3
  *   AutoGenerate 100
  *   `;
  * await app.setScript(script);
  * await app.doReload();
  * ```
  */
  createSessionApp(sessionAppId) {
    return new NxApp({ attributes: { id: sessionAppId }, create: [], privileges: [] }, this.auth);
  }
}
export {
  Apps,
  Evaluation,
  NxApp
};

import Auth from "../auth/auth.js";
import ListableResource from "../listable.js";
class DataFileUploadResponse {
  constructor({
    appId,
    createdDate,
    id,
    modifiedDate,
    name,
    ownerId,
    size,
    spaceId,
    ...rest
  }, auth) {
    this.auth = auth;
    this.appId = appId;
    this.createdDate = createdDate;
    this.id = id;
    this.modifiedDate = modifiedDate;
    this.name = name;
    this.ownerId = ownerId;
    this.size = size;
    this.spaceId = spaceId;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
  /**    This is primarily an admin type of operation.  In general, the owner of a data file is implicitly set as
  part of a data file upload.  For data files that reside in a personal space, changing the owner has the
  effect of moving the data file to the new owner's personal space.
    Change the owner of an existing data file.
  
      @param data - The request.
    */
  async changeOwner(data) {
    await this.auth.rest(
      "/data-files/{id}/actions/change-owner".replace("{id}", this.id ?? ""),
      {
        method: "POST",
        body: JSON.stringify(data)
      }
    );
  }
  /**    This is to allow for a separate admin type of operation that is more global in terms of access in cases
  where admin users may not explicitly have been granted full access to a given space within the declared
  space-level permissions.  If the space ID is set to null, then the datafile will end up residing in the
  personal space of the user who is the owner of the file.
    Change the space that an existing data file resides in.
  
      @param data - The request.
    */
  async changeSpace(data) {
    await this.auth.rest(
      "/data-files/{id}/actions/change-space".replace("{id}", this.id ?? ""),
      {
        method: "POST",
        body: JSON.stringify(data)
      }
    );
  }
  /**
    Delete the specified data file.
  
    */
  async delete() {
    await this.auth.rest(
      "/data-files/{id}".replace("{id}", this.id ?? ""),
      {
        method: "DELETE"
      }
    );
  }
  /**
    Re-upload an existing data file.
  
      @param File - IFormFile form multipart/form-data
      @param name - Name that will be given to the uploaded file.  If this name is different than the name used when the file
  was last POSTed or PUT, this will result in a rename of the file.  It should be noted that the '/' character
  in a data file name indicates a 'path' separator in a logical folder hierarchy for the name.  Names that
  contain '/'s should be used with the assumption that a logical 'folder hierarchy' is being defined for the
  full pathname of that file.  '/' is a significant character in the data file name, and may impact the
  behavior of future APIs that take this folder hierarchy into account.
      @param appId - If this file should be bound to the lifecycle of a specific app, this is the ID of this app.
      @param sourceId - If a SourceId is specified, this is the ID of the existing data file whose content should be copied into
  the specified data file.  That is, instead of the file content being specified in the Data element,
  it is effectively copied from an existing, previously uploaded file.
      @param connectionId - If present, this is the DataFiles connection that the upload should occur in the context of.  If absent,
  the default is that the upload will occur in the context of the MyDataFiles connection.  If the DataFiles
  connection is different from the one specified when the file was last POSTed or PUT, this will result in
  a logical move of this file into the new space.
      @param tempContentFileId - If a TempContentFileId is specified, this is the ID of a previously uploaded temporary content file whose
  content should be copied into the specified data file.  That is, instead of the file content being specified
  in the Data element, it is effectively copied from an existing, previously uploaded file.  The expectation
  is that this file was previously uploaded to the temporary content service, and the ID specified here is
  the one returned from the temp content upload request.
    */
  async set(File, name, appId, sourceId, connectionId, tempContentFileId) {
    const formData = new FormData();
    if (File !== void 0) {
      formData.append("File", new Blob([File], { type: "application/octet-stream" }));
    }
    const Json = {};
    if (name !== void 0) {
      Json["name"] = name;
    }
    if (appId !== void 0) {
      Json["appId"] = appId;
    }
    if (sourceId !== void 0) {
      Json["sourceId"] = sourceId;
    }
    if (connectionId !== void 0) {
      Json["connectionId"] = connectionId;
    }
    if (tempContentFileId !== void 0) {
      Json["tempContentFileId"] = tempContentFileId;
    }
    formData.append("Json", JSON.stringify(Json));
    const response = await this.auth.rest(
      "/data-files/{id}".replace("{id}", this.id ?? ""),
      {
        method: "PUT",
        body: formData
      }
    );
    const responseJson = await response.json();
    Object.keys(responseJson).forEach((key) => {
      if (this[key]) {
        this[key] = responseJson[key];
      }
    });
    return this;
  }
}
class DataFiles {
  constructor(config) {
    this.config = config instanceof Auth ? config.config : config;
    this.auth = config instanceof Auth ? config : new Auth(config);
  }
  /**    This is to allow for a separate admin type of operation that is more global in terms of access in cases
  where admin users may not explicitly have been granted full access to a given space within the declared
  space-level permissions.  If the space ID is set to null, then the data file will end up residing in the
  personal space of the user who is the owner of the file.
    Change the spaces that a set of existing data files reside in a a single batch.
  
      @param data - Specifies the list of data file change space operations in a single batch.
    */
  async changeSpace(data) {
    const response = await this.auth.rest(
      "/data-files/actions/change-space",
      {
        method: "POST",
        body: JSON.stringify(data)
      }
    );
    return response.json();
  }
  /**
    Delete the specified set of data files as a single batch.
  
      @param data - Specifies the list of data files to be deleted in a single batch.
    */
  async delete(data) {
    const response = await this.auth.rest(
      "/data-files/actions/delete",
      {
        method: "POST",
        body: JSON.stringify(data)
      }
    );
    return response.json();
  }
  /**
    Get the built-in connection used by the engine to load/write data files given a connection ID.
  
      @param id - The ID of the connection.
    */
  async getConnection(id) {
    const response = await this.auth.rest(
      "/data-files/connections/{id}".replace("{id}", id),
      {
        method: "GET"
      }
    );
    return response.json();
  }
  /**    The non-filtered list contains a set of hardcoded connections, along with one connection per team space that
  the given user has access to.
    Get the list of built-in connections used by the engine to load/write data files.
  
      @param appId - If present, get connections with connection strings that are scoped to the given app ID.
      @param limit - If present, the maximum number of data file connection records to return.
      @param name - If present, only return connections with the given name.
      @param page - If present, the cursor that starts the page of data that is returned.
      @param personal - If true, only return the connections that access data in a personal space.  Default is false.
      @param sort - The name of the field used to sort the result.  By default, the sort is ascending.  Putting a '+' prefix on
  the sort field name explicitly indicates ascending sort order.  A '-' prefix indicates a descending sort order.
      @param spaceId - If present, only return the connection that accesses data files in the specified space.
    */
  async getConnections(queryParams = { limit: 20 }) {
    const response = await this.auth.rest(
      `/data-files/connections?${new URLSearchParams(Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => [k, v.toString()])).toString()}`,
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new ListableResource(responseJson, this.auth, null, queryParams);
  }
  /**
    Get quota information for the calling user.
  
    */
  async getQuota() {
    const response = await this.auth.rest(
      "/data-files/quotas",
      {
        method: "GET"
      }
    );
    return response.json();
  }
  /**
    Get descriptive info for the specified data file.
  
      @param id - The ID of the data file.
    */
  async get(id) {
    const response = await this.auth.rest(
      "/data-files/{id}".replace("{id}", id),
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new DataFileUploadResponse(responseJson, this.auth);
  }
  /**
    Get descriptive info for the specified data files.
  
      @param allowInternalFiles - If set to false, do not return data files with internal extensions else return all the data files.
      @param appId - Only return files scoped to the specified app.  If this parameter is not specified, only files that are not
  scoped to any app are returned.  "*" implies all app-scoped files are returned.
      @param connectionId - Return files that reside in the space referenced by the specified DataFiles connection.  If this parameter
  is not specified, the user's personal space is implied.
      @param limit - If present, the maximum number of data files to return.
      @param name - Filter the list of files returned to the given file name.
      @param ownerId - If present, fetch the data files for the specified owner.  If a connectionId is specified in this case, the
  returned list is constrained to the specified space.  If connectionId is not specified, then all files owned
  by the specified user are returned regardless of the personal space that a given file resides in.
      @param page - If present, the cursor that starts the page of data that is returned.
      @param sort - The name of the field used to sort the result.  By default, the sort order is ascending.  Putting a '+' prefix on
  the sort field name explicitly indicates ascending sort order.  A '-' prefix indicates a descending sort order.
    */
  async getDataFiles(queryParams = { limit: 20 }) {
    const response = await this.auth.rest(
      `/data-files?${new URLSearchParams(Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => [k, v.toString()])).toString()}`,
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new ListableResource(responseJson, this.auth, DataFileUploadResponse, queryParams);
  }
  /**
    Upload a new data file.
  
      @param File - IFormFile form multipart/form-data
      @param name - Name that will be given to the uploaded file.  It should be noted that the '/' character
  in a data file name indicates a 'path' separator in a logical folder hierarchy for the name.  Names that
  contain '/'s should be used with the assumption that a logical 'folder hierarchy' is being defined for the
  full pathname of that file.  '/' is a significant character in the data file name, and may impact the
  behavior of future APIs which take this folder hierarchy into account.
      @param appId - If this file should be bound to the lifecycle of a specific app, this is the ID of this app.
      @param sourceId - If a SourceId is specified, this is the ID of the existing data file whose content should be copied into
  the specified data file.  That is, instead of the file content being specified in the Data element,
  it is effectively copied from an existing, previously uploaded file.
      @param connectionId - If present, this is the DataFiles connection that the upload should occur in the context of.  If absent,
  the default is that the upload will occur in the context of the MyDataFiles connection.  If the DataFiles
  connection is different from the one specified when the file was last POSTed or PUT, this will result in
  a logical move of this file into the new space.
      @param tempContentFileId - If a TempContentFileId is specified, this is the ID of a previously uploaded temporary content file whose
  content should be copied into the specified data file.  That is, instead of the file content being specified
  in the Data element, it is effectively copied from an existing, previously uploaded file.  The expectation
  is that this file was previously uploaded to the temporary content service, and the ID specified here is
  the one returned from the temp content upload request.
    */
  async create(File, name, appId, sourceId, connectionId, tempContentFileId) {
    const formData = new FormData();
    if (File !== void 0) {
      formData.append("File", new Blob([File], { type: "application/octet-stream" }));
    }
    const Json = {};
    if (name !== void 0) {
      Json["name"] = name;
    }
    if (appId !== void 0) {
      Json["appId"] = appId;
    }
    if (sourceId !== void 0) {
      Json["sourceId"] = sourceId;
    }
    if (connectionId !== void 0) {
      Json["connectionId"] = connectionId;
    }
    if (tempContentFileId !== void 0) {
      Json["tempContentFileId"] = tempContentFileId;
    }
    formData.append("Json", JSON.stringify(Json));
    const response = await this.auth.rest(
      "/data-files",
      {
        method: "POST",
        body: formData
      }
    );
    const responseJson = await response.json();
    return new DataFileUploadResponse(responseJson, this.auth);
  }
}
export {
  DataFileUploadResponse,
  DataFiles
};

/**
This is spectacularly generated code by spectacular based on
Qlik Cloud Services APIs
*/
import Auth from '../auth/auth.js';
import ListableResource from '../listable.js';
import type { Config } from '../types/types.js';
export type AutomationDetailRequestObject = {
    description?: string;
    name?: string;
    schedules?: Array<ScheduleRequestObject>;
    /** @defaultValue "available"
  @example "available" */
    state?: 'available' | 'unavailable' | 'disabled' | string;
    /** The workspace generated by the Qlik Application Automations editor. */
    workspace?: object;
    [key: string]: any;
};
/**
  @param connectorIds - A list of connectors used inside the workspace.
  @param createdAt -
  @param description -
  @param endpointIds - A list of endpoints used inside the workspace.
  @param executionToken -
  @param id -
  @param lastRun -
  @param lastRunAt -
  @param lastRunStatus -
  @param name -
  @param ownerId -
  @param runMode -
  @param schedules -
  @param snippetIds - A list of snippets used inside the workspace.
  @param state -
  @param updatedAt -
  @param workspace - The workspace generated by the Qlik Application Automations editor.
  @param auth - Auth object used to make requests
 */
export declare class AutomationDetailResponseObject {
    auth: Auth;
    connectorIds?: Array<string>;
    createdAt?: string;
    description?: string;
    endpointIds?: Array<string>;
    executionToken?: string;
    id?: string;
    lastRun?: RunDetailResponseObject;
    lastRunAt?: string;
    lastRunStatus?: 'failed' | 'finished' | 'finished with warnings' | 'must stop' | 'not started' | 'paused' | 'running' | 'starting' | 'stopped' | string;
    name?: string;
    ownerId?: string;
    runMode?: 'manual' | 'scheduled' | 'triggered' | 'webhook' | string;
    schedules?: Array<ScheduleResponseObject>;
    snippetIds?: Array<string>;
    state?: 'available' | 'unavailable' | 'disabled' | string;
    updatedAt?: string;
    workspace?: object;
    [key: string]: any;
    constructor({ connectorIds, createdAt, description, endpointIds, executionToken, id, lastRun, lastRunAt, lastRunStatus, name, ownerId, runMode, schedules, snippetIds, state, updatedAt, workspace, ...rest }: {
        connectorIds?: Array<string>;
        createdAt?: string;
        description?: string;
        endpointIds?: Array<string>;
        executionToken?: string;
        id?: string;
        lastRun?: RunDetailResponseObject;
        lastRunAt?: string;
        lastRunStatus?: 'failed' | 'finished' | 'finished with warnings' | 'must stop' | 'not started' | 'paused' | 'running' | 'starting' | 'stopped' | string;
        name?: string;
        ownerId?: string;
        runMode?: 'manual' | 'scheduled' | 'triggered' | 'webhook' | string;
        schedules?: Array<ScheduleResponseObject>;
        snippetIds?: Array<string>;
        state?: 'available' | 'unavailable' | 'disabled' | string;
        updatedAt?: string;
        workspace?: object;
    }, auth?: Auth);
    /**
    Copy an automation.
  
      @param name - Name of the new automation.
    */
    copy(name: string): Promise<object>;
    /**
    Disables an automation.
  
    */
    disable(): Promise<void>;
    /**
    Enable an automation.
  
    */
    enable(): Promise<void>;
    /**    This step will remove the history and change logs of this automation. All linked connections used inside an automation will be detached.
    Move an automation to a different user.
  
      @param ownerId -
    */
    move(ownerId: string): Promise<void>;
    /**    Creates a temporary pre-signed AWS S3 URL to download the raw logs of a completed run. This URL is valid for 5 minutes.
    Export a run.
  
      @param runId - The unique identifier for the run.
    */
    export(runId: string): Promise<object>;
    /**    This action allows you to retry a specific run by creating a new run using the same inputs.
    Retry a run.
  
      @param runId - The unique identifier for the run.
    */
    retry(runId: string): Promise<void>;
    /**    Force a run to be stopped immediately.
    Stop a running automation.
  
      @param runId - The unique identifier for the run.
    */
    stop(runId: string): Promise<void>;
    /**
    Retrieves a run
  
      @param runId - The unique identifier for the run.
    */
    getRun(runId: string): Promise<RunDetailResponseObject>;
    /**
    Retrieves a list of runs for a specific automation.
  
      @param filter - Allowed filters: status, context, startTime and title
      @param limit - The number of runs to retrieve.
      @param sort - The field to sort by, with +- prefix indicating sort order. (?query=-startTime => sort on the startTime field using descending order)
    */
    getRuns(queryParams?: {
        filter?: string;
        limit?: number;
        sort?: 'id' | 'status' | 'startTime' | '-id' | '-status' | '-startTime' | '+id' | '+status' | '+startTime';
    }): Promise<ListableResource<RunListObject>>;
    /**
    Create a run
  
      @param data - Run object to create
    */
    createRun(data: RunDetailRequestObject): Promise<RunDetailResponseObject>;
    /**
    Delete an automation
  
    */
    delete(): Promise<void>;
    /**
    Update an automation
  
      @param data - Automation object to update
    */
    set(data: AutomationDetailRequestObject): Promise<AutomationDetailResponseObject>;
}
export type AutomationListObject = {
    /** @example "2021-12-23T12:28:21.000000Z" */
    createdAt?: string;
    description?: string;
    /** @example "e0e720d0-4947-11ec-a1d2-9559fa35801d" */
    id?: string;
    /** @example "2021-12-23T12:28:21.000000Z" */
    lastRunAt?: string;
    /** @example "finished" */
    lastRunStatus?: 'failed' | 'finished' | 'finished with warnings' | 'must stop' | 'not started' | 'paused' | 'running' | 'starting' | 'stopped' | string;
    name?: string;
    /** @example "sWYAHxZxhtcmBT7Ptc5xJ5I6N7HxwnEy" */
    ownerId?: string;
    /** @example "triggered" */
    runMode?: 'manual' | 'scheduled' | 'triggered' | 'webhook' | string;
    /** @defaultValue "available"
  @example "available" */
    state?: 'available' | 'unavailable' | 'disabled' | string;
    /** @example "2021-12-23T12:28:21.000000Z" */
    updatedAt?: string;
    [key: string]: any;
};
export type AutomationUsageObject = {
    /** The unique identifier for the automation.
  @example "00000000-0000-0000-0000-000000000000" */
    guid?: string;
    /** The name for the automation.
  @example "My Automation." */
    name?: string;
    /** The unique identifier for the user who owns the automation
  @example "KP1zJiPDn0gsla236GmETadFcxBW-J8F" */
    ownerId?: string;
    [key: string]: any;
};
export type RunDetailRequestObject = {
    /** The source that triggers the automation will set the context.
  @example "api" */
    context: 'api' | string;
    /** @example "d452d100-9b0b-11ec-b199-8323e1031c3e" */
    id?: string;
    inputs?: object;
    [key: string]: any;
};
export type RunDetailResponseObject = {
    /** The source that triggers the automation will set the context. Certain contexts impact the execution of an automation (for example, The "test_run" context will not process all results when listing items). */
    context?: 'test_run' | 'editor' | 'detail' | 'api_sync' | 'api_async' | 'webhook' | 'lookup' | string;
    /** @example "2021-12-23T12:28:21.000000Z" */
    createdAt?: string;
    error?: object;
    expectedInputs?: object;
    /** @example "d452d100-9b0b-11ec-b199-8323e1031c3e" */
    id?: string;
    inputs?: object;
    isArchived?: boolean;
    isTestRun?: boolean;
    metrics?: {
        blocks?: {
            apiCalls?: number;
            connectorId?: string;
            endpointId?: string;
            rxBytes: number;
            snippetId?: string;
            txBytes: number;
            type: 'snippetBlock' | 'endpointBlock' | string;
        }[];
        network?: {
            rxBytes?: number;
            txBytes?: number;
        };
        totalApiCalls?: number;
    };
    /** @example "2021-12-23T12:28:21.000000Z" */
    scheduledStartTime?: string;
    /** @example "2021-12-23T12:28:21.000000Z" */
    startTime?: string;
    status?: 'failed' | 'finished' | 'finished with warnings' | 'must stop' | 'not started' | 'running' | 'starting' | 'stopped' | string;
    /** @example "2021-12-23T12:28:21.000000Z" */
    stopTime?: string;
    title?: string;
    /** @example "2021-12-23T12:28:21.000000Z" */
    updatedAt?: string;
    [key: string]: any;
};
export type RunListObject = {
    context?: 'test_run' | 'editor' | 'detail' | 'api_sync' | 'api_async' | 'webhook' | 'lookup' | string;
    /** @example "2021-12-23T12:28:21.000000Z" */
    createdAt?: string;
    error?: object;
    /** @example "d452d100-9b0b-11ec-b199-8323e1031c3e" */
    id?: string;
    isArchived?: boolean;
    isTestRun?: boolean;
    /** @example "2021-12-23T12:28:21.000000Z" */
    scheduledStartTime?: string;
    /** @example "2021-12-23T12:28:21.000000Z" */
    startTime?: string;
    status?: 'failed' | 'finished' | 'finished with warnings' | 'must stop' | 'not started' | 'running' | 'starting' | 'stopped' | string;
    /** @example "2021-12-23T12:28:21.000000Z" */
    stopTime?: string;
    title?: string;
    /** @example "2021-12-23T12:28:21.000000Z" */
    updatedAt?: string;
    [key: string]: any;
};
export type ScheduleRequestObject = {
    /** time in seconds.
  @example 30 */
    interval?: number;
    /** @example "2022-01-01 00:00:00" */
    startAt?: string;
    /** @example "2022-12-01 00:00:00" */
    stopAt?: string;
    /** @example "Europe/Stockholm" */
    timezone?: string;
    [key: string]: any;
};
export type ScheduleResponseObject = {
    /** @example "d452d100-9b0b-11ec-b199-8323e1031c3e" */
    id?: string;
    /** time in seconds.
  @example 30 */
    interval?: number;
    /** @example "2022-01-01T12:28:21.000000Z" */
    lastStartedAt?: string;
    /** @example "2021-12-01 00:00:00" */
    startAt?: string;
    /** @example "2022-12-01 00:00:00" */
    stopAt?: string;
    /** @example "Europe/Stockholm" */
    timezone?: string;
    [key: string]: any;
};
export type SettingsObject = {
    automationsEnabled?: boolean;
    [key: string]: any;
};
export type UsageList = {
    data?: Array<UsageObject>;
    [key: string]: any;
};
export type UsageObject = {
    automation?: AutomationUsageObject;
    /** The date for the metric
  @example "2021-12-15" */
    date: string;
    /** The name for the metric
  @example "bandwidthIn" */
    name: 'runs' | 'scheduledRun' | 'triggeredRun' | 'webhookRuns' | 'duration' | 'bandwidthIn' | 'bandwidthOut' | string;
    /** The value count of the metric
  @example 310179713 */
    value: number;
    [key: string]: any;
};
export declare class Automations {
    auth: Auth;
    config: Config;
    constructor(config: Config | Auth);
    /**
    Retrieves the automation settings.
  
    */
    getSettings(): Promise<SettingsObject>;
    /**
    Update the automation settings.
  
      @param data -
    */
    setSettings(data: SettingsObject): Promise<SettingsObject>;
    /**    Limitations:
   * Maximum 1000 metrics per API call
    Retrieves all automation usage for a tenant
  
      @param filter - Indicates how the metrics should be filtered
      @param breakdownBy - If specified, result will be broken apart for each automation
    */
    getUsages(queryParams: {
        filter: string;
        breakdownBy?: string;
    }): Promise<UsageList>;
    /**
    Retrieves an automation
  
      @param id - The unique identifier for the automation.
    */
    get(id: string): Promise<AutomationDetailResponseObject>;
    /**
    Retrieves a list of automations
  
      @param filter - Allowed filters: name, runMode, lastRunStatus, ownerId
      @param limit - The number of automations to retrieve.
      @param sort - The field to sort by, with +- prefix indicating sort order. (?query=-name => sort on the name field using descending order)
    */
    getAutomations(queryParams?: {
        filter?: string;
        limit?: number;
        sort?: 'id' | 'name' | 'runMode' | 'state' | 'createdAt' | 'updatedAt' | 'lastRunAt' | 'lastRunStatus' | '+id' | '+name' | '+runMode' | '+state' | '+createdAt' | '+updatedAt' | '+lastRunAt' | '+lastRunStatus' | '-id' | '-name' | '-runMode' | '-state' | '-createdAt' | '-updatedAt' | '-lastRunAt' | '-lastRunStatus';
    }): Promise<ListableResource<AutomationListObject>>;
    /**
    Create an automation
  
      @param data - Automation object to create
    */
    create(data: AutomationDetailRequestObject): Promise<AutomationDetailResponseObject>;
}

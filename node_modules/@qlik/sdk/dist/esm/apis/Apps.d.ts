/**
This is spectacularly generated code by spectacular based on
Qlik Cloud Services APIs
*/
import Auth from '../auth/auth.js';
import ListableResource from '../listable.js';
import type { Config } from '../types/types.js';
import { Doc } from './Qix.js';
export type AnalysisComposition = {
    description?: {
        long?: string;
        short?: string;
    };
    /** Upper and lower bounds for items of specific classification types */
    dims?: CompositionMinMax;
    /** Upper and lower bounds for items of specific classification types */
    geos?: CompositionMinMax;
    /** Upper and lower bounds for items of specific classification types */
    items?: CompositionMinMax;
    /** Upper and lower bounds for items of specific classification types */
    msrs?: CompositionMinMax;
    /** Upper and lower bounds for items of specific classification types */
    temporals?: CompositionMinMax;
    [key: string]: any;
};
export type AnalysisDescriptor = {
    compositions?: Array<AnalysisComposition>;
    id?: string;
    /** Used for period-specific analyses to indicate the defined or available calendar period must be of type autoCalendar */
    requiresAutoCalendarPeriod?: boolean;
    /** Used for period-specific analyses to indicate the temporal dimension must be associated with one or more analysis periods */
    requiresAvailableAnalysisPeriod?: boolean;
    /** Used for period-specific analyses to indicate the measure must be associated with one or more analysis periods */
    requiresDefinedAnalysisPeriod?: boolean;
    /** If analysis can work with master items (default is true) */
    supportsMasterItems?: boolean;
    [key: string]: any;
};
export type AnalysisDetails = {
    analysis?: 'breakdown' | 'changePoint' | 'comparison' | 'contribution' | 'correlation' | 'fact' | 'mutualInfo' | 'rank' | 'spike' | 'trend' | 'values' | string;
    analysisGroup?: 'anomaly' | 'brekadown' | 'comparison' | 'correl' | 'fact' | 'list' | 'mutualInfo' | 'rank' | string;
    title?: string;
    [key: string]: any;
};
export type AnalysisModelItemField = {
    /** classification defines the default role that attribute can play in an analysis */
    classifications?: Array<string>;
    /** whether the field is hidden in business logic */
    isHidden?: boolean;
    /** populated only for fields */
    name?: string;
    simplifiedClassifications?: Array<string>;
    [key: string]: any;
};
export type AnalysisModelItemMasterItem = {
    caption?: string;
    /** classification defines the default role that attribute can play in an analysis */
    classifications?: Array<string>;
    /** whether the master item is hidden in business logic */
    isHidden?: boolean;
    /** only available for master items */
    libId?: string;
    simplifiedClassifications?: Array<string>;
    [key: string]: any;
};
export type AnalysisModelResponseDetail = {
    fields?: Array<AnalysisModelItemField>;
    /** set only if previous property is true, to indicate if the business logic passes validation */
    isDefinedLogicalModelValid?: boolean;
    /** if the analysis model is constructed based on a user-defined business-logic (as opposed to a default one) */
    isLogicalModelEnabled?: boolean;
    masterItems?: Array<AnalysisModelItemMasterItem>;
    [key: string]: any;
};
export type AnalysisRecommendationResponse = {
    data?: Array<AnalysisRecommendationResponseDetail>;
    [key: string]: any;
};
export type AnalysisRecommendationResponseDetail = {
    nluInfo?: Array<PartialNluInfo>;
    recAnalyses: Array<RecommendedAnalysis>;
    [key: string]: any;
};
export type AnalysisRecommendRequest = {
    [key: string]: any;
};
export type AppAttributes = {
    /** The description of the application */
    description?: string;
    /** Set custom locale instead of the system default */
    locale?: string;
    /** The name (title) of the application */
    name?: string;
    /** The space ID of the application */
    spaceId?: string;
    [key: string]: any;
};
export type AppContentList = {
    /** Content list items. */
    data?: Array<AppContentListItem>;
    /** Content library name. */
    library?: string;
    /** Content library relative listing path. Empty in case of root listed or representing actual subpath listed. */
    subpath?: string;
    [key: string]: any;
};
export type AppContentListItem = {
    /** Unique content identifier. */
    id?: string;
    /** Unique content link. */
    link?: string;
    /** Content name. */
    name?: string;
    /** Content type. */
    type?: string;
    [key: string]: any;
};
export type AppUpdateAttributes = {
    /** The description of the application. */
    description?: string;
    /** The name (title) of the application. */
    name?: string;
    [key: string]: any;
};
export type Cmpbool = {
    /** @example 2.5 */
    absoluteDiff?: number;
    /** @example 0.5 */
    diff?: number;
    /** @example "up" */
    trend?: string;
    baseline?: boolean;
    /** @example true */
    comparison?: boolean;
    [key: string]: any;
};
export type Cmpfloat = {
    /** @example 2.5 */
    absoluteDiff?: number;
    /** @example 0.5 */
    diff?: number;
    /** @example "up" */
    trend?: string;
    /** @example 1.1 */
    baseline?: number;
    /** @example 2.2 */
    comparison?: number;
    [key: string]: any;
};
export type Cmpint = {
    /** @example 2.5 */
    absoluteDiff?: number;
    /** @example 0.5 */
    diff?: number;
    /** @example "up" */
    trend?: string;
    /** @example 1 */
    baseline?: number;
    /** @example 2 */
    comparison?: number;
    [key: string]: any;
};
export type Comparison = {
    appOpenTimeSeconds?: Cmpfloat;
    dataModelSizeMib?: Cmpfloat;
    documentSizeMib?: Cmpfloat;
    fileSizeMib?: Cmpfloat;
    hasSectionAccess?: Cmpbool;
    maxMemoryMib?: Cmpfloat;
    objHeavy?: Sortedcomparisonoobjheavy;
    objNoCache?: Sortedcomparisonobjresponsetime;
    objSingleThreaded?: Sortedcomparisonobjresponsetime;
    objSlowCached?: Sortedcomparisonobjresponsetime;
    objSlowUncached?: Sortedcomparisonobjresponsetime;
    objectCount?: Cmpint;
    rowCount?: Cmpint;
    sheetCount?: Cmpint;
    sheetsCached?: Sortedcomparisonobjresponsetime;
    sheetsUncached?: Sortedcomparisonobjresponsetime;
    topFieldsByBytes?: Sortedcomparisonfields;
    topTablesByBytes?: Sortedcomparisontables;
    [key: string]: any;
};
export type CompositionMinMax = {
    max?: number;
    min?: number;
    [key: string]: any;
};
export type CreateApp = {
    attributes?: AppAttributes;
    [key: string]: any;
};
export type DataModelMetadata = {
    /** List of field descriptions. */
    fields?: Array<FieldMetadata>;
    /** If set to true, the app has section access configured. */
    has_section_access?: boolean;
    is_direct_query_mode?: boolean;
    reload_meta?: LastReloadMetadata;
    /** Static memory usage for the app. */
    static_byte_size?: number;
    /** List of table descriptions. */
    tables?: Array<TableMetadata>;
    /** Profiling data of the tables in the app. */
    tables_profiling_data?: Array<TableProfilingData>;
    [key: string]: any;
};
/**
  @param appId -
  @param appItemId -
  @param appName -
  @param details -
  @param ended -
  @param events -
  @param id -
  @param metadata -
  @param result -
  @param sheetId -
  @param sheetTitle -
  @param started -
  @param status -
  @param tenantId -
  @param timestamp -
  @param version -
  @param auth - Auth object used to make requests
 */
export declare class Evaluation {
    auth: Auth;
    appId?: string;
    appItemId?: string;
    appName?: string;
    details?: {
        concurrentReload?: boolean;
        dedicated?: boolean;
        engineHasCache?: boolean;
        errors?: Array<string>;
        objectMetrics?: object;
        warnings?: Array<string>;
    };
    ended?: string;
    events?: Array<Event>;
    id?: string;
    metadata?: Metadata;
    result?: Result;
    sheetId?: string;
    sheetTitle?: string;
    started?: string;
    status?: string;
    tenantId?: string;
    timestamp?: string;
    version?: number;
    [key: string]: any;
    constructor({ appId, appItemId, appName, details, ended, events, id, metadata, result, sheetId, sheetTitle, started, status, tenantId, timestamp, version, ...rest }: {
        appId?: string;
        appItemId?: string;
        appName?: string;
        details?: {
            concurrentReload?: boolean;
            dedicated?: boolean;
            engineHasCache?: boolean;
            errors?: Array<string>;
            objectMetrics?: object;
            warnings?: Array<string>;
        };
        ended?: string;
        events?: Array<Event>;
        id?: string;
        metadata?: Metadata;
        result?: Result;
        sheetId?: string;
        sheetTitle?: string;
        started?: string;
        status?: string;
        tenantId?: string;
        timestamp?: string;
        version?: number;
    }, auth?: Auth);
    /**    Find and download an evaluation log by a specific evaluation id.
  
    Download a detailed XML log of a specific evaluation
  
    */
    download(): Promise<Evaluation>;
}
export type Event = {
    /** @example "An object failed" */
    details?: string;
    /** @example "ERR-GOPHERCISER" */
    errorCode?: string;
    /** @example "adfRFr" */
    objectId?: string;
    /** @example "profit" */
    objectTitle?: string;
    /** @example "linechart" */
    objectType?: string;
    /** @example "linechart" */
    objectVisualization?: string;
    /** @example "warning" */
    severity?: string;
    /** @example "gregFG" */
    sheetId?: string;
    /** @example "mysheet" */
    sheetTitle?: string;
    [key: string]: any;
};
export type FieldAttributes = {
    /** Defines the decimal separator.
  Example: . */
    Dec?: string;
    /** Defines the format pattern that applies to qText .
  Is used in connection to the type of the field (parameter qType ).
  For more information, see Formatting mechanism.
  Example: YYYY-MM-DD for a date. */
    Fmt?: string;
    /** Defines the thousand separator (if any).
  Is used if qUseThou is set to 1.
  Example: , */
    Thou?: string;
    /** Type of the field.
  Default is U.
  
  One of:
  
  • U or UNKNOWN
  
  • A or ASCII
  
  • I or INTEGER
  
  • R or REAL
  
  • F or FIX
  
  • M or MONEY
  
  • D or DATE
  
  • T or TIME
  
  • TS or TIMESTAMP
  
  • IV or INTERVAL
  @defaultValue "UNKNOWN" */
    Type?: 'UNKNOWN' | 'ASCII' | 'INTEGER' | 'REAL' | 'FIX' | 'MONEY' | 'DATE' | 'TIME' | 'TIMESTAMP' | 'INTERVAL' | string;
    /** Defines whether or not a thousands separator must be used.
  Default is 0. */
    UseThou?: number;
    /** Number of decimals.
  Default is 10.
  @defaultValue 10 */
    nDec?: number;
    [key: string]: any;
};
export type FieldInTableProfilingData = {
    /** Average of all numerical values. NaN otherwise. */
    Average?: number;
    /** Average string length of textual values. 0 otherwise. */
    AvgStringLen?: number;
    /** Number of distinct numeric values */
    DistinctNumericValues?: number;
    /** Number of distinct text values */
    DistinctTextValues?: number;
    /** Number of distinct values */
    DistinctValues?: number;
    /** Number of empty strings */
    EmptyStrings?: number;
    /** List of tags related to the field. */
    FieldTags?: Array<string>;
    /** For textual values the first sorted string. */
    FirstSorted?: string;
    /** The .01, .05, .1, .25, .5, .75, .9, .95, .99 fractiles. Array of NaN otherwise. */
    Fractiles?: Array<number>;
    FrequencyDistribution?: FrequencyDistributionData;
    /** Kurtosis of the numerical values. NaN otherwise. */
    Kurtosis?: number;
    /** For textual values the last sorted string. */
    LastSorted?: string;
    /** Maximum value of numerical values. NaN otherwise. */
    Max?: number;
    /** Maximum string length of textual values. 0 otherwise. */
    MaxStringLen?: number;
    /** Median of all numerical values. NaN otherwise. */
    Median?: number;
    /** Minimum value of numerical values. NaN otherwise. */
    Min?: number;
    /** Minimum string length of textual values. 0 otherwise. */
    MinStringLen?: number;
    /** Three most frequent values and their frequencies */
    MostFrequent?: Array<SymbolFrequency>;
    /** Name of the field. */
    Name?: string;
    /** Number of negative values */
    NegValues?: number;
    /** Number of null values */
    NullValues?: number;
    /** Sets the formatting of a field.
  The properties of qFieldAttributes and the formatting mechanism are described below.
  
   Formatting mechanism:
  The formatting mechanism depends on the type set in qType, as shown below:
  In case of inconsistencies between the type and the format pattern, the format pattern takes precedence over the type.
  
   Type is DATE, TIME, TIMESTAMP or INTERVAL:
  The following applies:
  
  • If a format pattern is defined in qFmt , the formatting is as defined in qFmt .
  
  • If qFmt is empty, the formatting is defined by the number interpretation variables included at the top of the script ( TimeFormat , DateFormat , TimeStampFormat ).
  
  • The properties qDec , qThou , qnDec , qUseThou are not used.
  
   Type is INTEGER:
  The following applies:
  
  • If a format pattern is defined in qFmt , the engine looks at the values set in qDec and qThou . If these properties are not defined, the formatting mechanism uses the number interpretation variables included at the top of the script ( DecimalSep and ThousandSep ).
  
  • If no format pattern is defined in qFmt , no formatting is applied. The properties qDec , qThou , qnDec , qUseThou and the number interpretation variables defined in the script are not used .
  
   Type is REAL:
  The following applies:
  
  • If a format pattern is defined in qFmt , the engine looks at the values set in qDec and qThou . If these properties are not defined, the engine uses the number interpretation variables included at the top of the script ( DecimalSep and ThousandSep ).
  
  • If no format pattern is defined in qFmt , and if the value is almost an integer value (for example, 14,000012), the value is formatted as an integer. The properties qDec , qThou , qnDec , qUseThou are not used.
  
  • If no format pattern is defined in qFmt , and if qnDec is defined and not 0, the property qDec is used. If qDec is not defined, the variable DecimalSep defined at the top of the script is used.
  
  • If no format pattern is defined in qFmt , and if qnDec is 0, the number of decimals is 14 and the property qDec is used. If qDec is not defined, the variable DecimalSep defined at the top of the script is used.
  
   Type is FIX:
  The following applies:
  
  • If a format pattern is defined in qFmt , the engine looks at the values set in qDec and qThou . If these properties are not defined, the engine uses the number interpretation variables included at the top of the script ( DecimalSep and ThousandSep ).
  
  • If no format pattern is defined in qFmt , the properties qDec and qnDec are used. If qDec is not defined, the variable DecimalSep defined at the top of the script is used.
  
   Type is MONEY:
  The following applies:
  
  • If a format pattern is defined in qFmt , the engine looks at the values set in qDec and qThou . If these properties are not defined, the engine uses the number interpretation variables included at the top of any script ( MoneyDecimalSep and MoneyThousandSep ).
  
  • If no format pattern is defined in qFmt , the engine uses the number interpretation variables included at the top of the script ( MoneyDecimalSep and MoneyThousandSep ).
  
   Type is ASCII:
  No formatting, qFmt is ignored. */
    NumberFormat?: FieldAttributes;
    /** Number of numeric values */
    NumericValues?: number;
    /** Number of positive values */
    PosValues?: number;
    /** Skewness of the numerical values. NaN otherwise. */
    Skewness?: number;
    /** Standard deviation of numerical values. NaN otherwise. */
    Std?: number;
    /** Sum of all numerical values. NaN otherwise. */
    Sum?: number;
    /** Squared sum of all numerical values. NaN otherwise. */
    Sum2?: number;
    /** Sum of all characters in strings in the field */
    SumStringLen?: number;
    /** Number of textual values */
    TextValues?: number;
    /** Number of zero values for numerical values */
    ZeroValues?: number;
    [key: string]: any;
};
export type FieldMetadata = {
    /** If set to true, the field has one and only one selection (not 0 and not more than 1).
  If this property is set to true, the field cannot be cleared anymore and no more selections can be performed in that field.
  The default value is false. */
    always_one_selected?: boolean;
    /** Static RAM memory used in bytes. */
    byte_size?: number;
    /** Number of distinct field values. */
    cardinal?: number;
    /** Field comment. */
    comment?: string;
    /** If set to true, only distinct field values are shown.
  The default value is false. */
    distinct_only?: boolean;
    /** Hash of the data in the field. If the data in a reload is the same, the hash will be consistent. */
    hash?: string;
    /** If set to true, the field is hidden.
  The default value is false. */
    is_hidden?: boolean;
    /** If set to true, the field is locked.
  The default value is false. */
    is_locked?: boolean;
    /** Is set to true if the value is a numeric.
  The default value is false. */
    is_numeric?: boolean;
    /** If set to true, the field is semantic.
  The default value is false. */
    is_semantic?: boolean;
    /** If set to true, the field is a system field.
  The default value is false. */
    is_system?: boolean;
    /** Name of the field. */
    name?: string;
    /** List of table names. */
    src_tables?: Array<string>;
    /** Gives information on a field. For example, it can return the type of the field.
  Examples: key, text, ASCII. */
    tags?: Array<string>;
    /** Total number of field values. */
    total_count?: number;
    [key: string]: any;
};
export type FileData = {
    [key: string]: any;
};
export type FrequencyDistributionData = {
    /** Bins edges. */
    BinsEdges?: Array<number>;
    /** Bins frequencies. */
    Frequencies?: Array<number>;
    /** Number of bins. */
    NumberOfBins?: number;
    [key: string]: any;
};
export type HardwareMeta = {
    /** Number of logical cores available. */
    logical_cores?: number;
    /** RAM available. */
    total_memory?: number;
    [key: string]: any;
};
export type JsonObject = {
    [key: string]: any;
};
export type LastReloadMetadata = {
    /** Number of CPU milliseconds it took to reload the app. */
    cpu_time_spent_ms?: number;
    hardware?: HardwareMeta;
    /** Maximum number of bytes used during reload of the app. */
    peak_memory_bytes?: number;
    [key: string]: any;
};
export type LineageInfoRest = {
    /** A string indicating the origin of the data:
  
  • [filename]: the data comes from a local file.
  
  • INLINE: the data is entered inline in the load script.
  
  • RESIDENT: the data comes from a resident table. The table name is listed.
  
  • AUTOGENERATE: the data is generated from the load script (no external table of data source).
  
  • Provider: the data comes from a data connection. The connector source name is listed.
  
  • [webfile]: the data comes from a web-based file.
  
  • STORE: path to QVD or TXT file where data is stored.
  
  • EXTENSION: the data comes from a Server Side Extension (SSE). */
    discriminator?: string;
    /** The LOAD and SELECT script statements from the data load script. */
    statement?: string;
    [key: string]: any;
};
export type Log = {
    /** Provides a link to download the log file. */
    log?: string;
    [key: string]: any;
};
export type Metadata = {
    /** @example 14442 */
    amountofcardinalfieldvalues?: number;
    /** @example 12 */
    amountoffields?: number;
    /** @example 144423433 */
    amountoffieldvalues?: number;
    /** @example 1423423234 */
    amountofrows?: number;
    /** @example 7 */
    amountoftables?: number;
    hassectionaccess?: boolean;
    reloadmeta?: {
        cpuspent?: number;
        peakmemorybytes?: number;
    };
    /** @example 1444234 */
    staticbytesize?: number;
    [key: string]: any;
};
export type NavigationLink = {
    href?: string;
    [key: string]: any;
};
export type NavigationLinks = {
    next?: NavigationLink;
    prev?: NavigationLink;
    [key: string]: any;
};
/**
  Application attributes and user privileges.
  @param attributes - App attributes. This structure can also contain extra user-defined attributes.
  @param create - Object create privileges. Hints to the client what type of objects the user is allowed to create.
  @param privileges - Application privileges.
Hints to the client what actions the user is allowed to perform.
Could be any of:

• read

• create

• update

• delete

• reload

• import

• publish

• duplicate

• export

• exportdata

• change_owner

• change_space
  @param auth - Auth object used to make requests
 */
export declare class NxApp extends Doc {
    auth: Auth;
    attributes?: NxAttributes;
    create?: Array<NxAppCreatePrivileges>;
    privileges?: Array<string>;
    [key: string]: any;
    constructor({ attributes, create, privileges, ...rest }: {
        attributes?: NxAttributes;
        create?: Array<NxAppCreatePrivileges>;
        privileges?: Array<string>;
    }, auth?: Auth);
    /**    Copies a specific app.
  
      @param data - Attributes that should be set in the copy.
    */
    createCopy(data: CreateApp): Promise<NxApp>;
    /**    Retrieves the lineage for an app.
  Returns a JSON-formatted array of strings describing the lineage of the app.
  
    */
    getDataLineages(): Promise<Array<LineageInfoRest>>;
    /**    Retrieves the data model and reload statistics metadata of an app.
  An empty metadata structure is returned if the metadata is not available in the app.
  
    */
    getDataMetadata(): Promise<DataModelMetadata>;
    /**    Exports a specific app.
  
      @param NoData - The flag indicating if only object contents should be exported.
    */
    export(queryParams?: {
        NoData?: boolean;
    }): Promise<string>;
    /**
    Returns analysis recommendations in response to a natural language question, a set of fields and master items, or a set of fields and master items with an optional target analysis.
  
      @param accept-language - language specified as an ISO-639-1 code. Defaults to 'en' (English).
      @param data - Request payload can be of two types, using natural language query or consist of fields or master items and optional target analysis.
  In below examples, consider sales as a master item and product as field, so to get recommendations using sales and product,
  you can utilize below three approaches, also you can set language parameter in headers as part of accept-language.
  Examples:
  ```
  {
    "text": "show me sales by product"
  }
  ```
  ```
  {
    "fields": [
      {
        "name": "product"
      }
    ],
    "libItems": [
      {
        libId: "NwQfJ"
      }
    ]
  }
  ```
  ```
  {
    "fields": [
      {
        "name": "product"
      }
    ],
    "libItems": [
      {
        "libId": "NwQfJ"
      }
    ],
    "targetAnalysis": {
      "id": "rank-rank"
    }
  }
  ```
  
    */
    recommend(data: AnalysisRecommendRequest): Promise<AnalysisRecommendationResponse>;
    /**
    Returns information about model used to make analysis recommendations. Lists all fields and master items in the logical model, along with an indication of the validity of the logical model if the default is not used.
  
    */
    getInsightAnalysesModels(): Promise<ListableResource<AnalysisModelResponseDetail>>;
    /**
    Returns information about supported analyses for the app's data model. Lists available analysis types, along with minimum and maximum number of dimensions, measures, and fields.
  
      @param accept-language - language specified as an ISO-639-1 code. Defaults to 'en' (English).
    */
    getInsightAnalyses(): Promise<ListableResource<AnalysisDescriptor>>;
    /**    Deletes a media content file or complete directory.
  Returns OK if the bytes containing the media file (or the complete content of a directory) were successfully deleted, or error in case of failure or lack of permission.
  
      @param path - Path to file content.
    */
    deleteMediaFile(path: string): Promise<void>;
    /**    Gets media content from file.
  Returns a stream of bytes containing the media file content on success, or error if file is not found.
  
      @param path - Path to file content.
    */
    getMediaFile(path: string): Promise<ArrayBuffer>;
    /**    Stores the media content file.
  Returns OK if the bytes containing the media file content were successfully stored, or error in case of failure, lack of permission or file already exists on the supplied path.
  
      @param path - Path to file content.
      @param data -
    */
    setMediaFile(path: string, data: FileData): Promise<void>;
    /**    Lists media content.
  Returns a JSON formatted array of strings describing the available media content or error if the optional path supplied is not found.
  
      @param path - The path to sub folder with static content relative to the root folder. Use empty path to access the root folder.
      @param show - Optional. List output can include files and folders in different ways:
  
  • Not recursive, default if show option is not supplied or incorrectly specified, results in output with files and empty directories for the path specified only.
  
  • Recursive(r), use ?show=r or ?show=recursive, results in a recursive output with files, all empty folders are excluded.
  
  • All(a), use ?show=a or ?show=all, results in a recursive output with files and empty directories.
    */
    getMediaLists(path: string, queryParams?: {
        show?: string;
    }): Promise<AppContentList>;
    /**    Gets media content from file currently used as application thumbnail.
  Returns a stream of bytes containing the media file content on success, or error if file is not found.
  The image selected as thumbnail is only updated when application is saved.
  
    */
    getMediaThumbnail(): Promise<ArrayBuffer>;
    /**    Sets owner on an app object.
  
      @param objectId - Identifier of the object.
      @param data -
    */
    changeOwner(objectId: string, data: UpdateOwner): Promise<NxAppObject>;
    /**    Changes owner of the app.
  
      @param data -
    */
    setOwner(data: UpdateOwner): Promise<NxApp>;
    /**    Publishes a specific app to a managed space.
  
      @param data - Publish information for the app.
    */
    publish(data: PublishApp): Promise<NxApp>;
    /**    Republishes a published app to a managed space.
  
      @param data - Republish information for the app.
    */
    setPublish(data: RepublishApp): Promise<NxApp>;
    /**    Retrieves the log of a specific reload.
  Returns the log as "text/plain; charset=UTF-8".
  
      @param reloadId - Identifier of the reload.
    */
    getReloadsLog(reloadId: string): Promise<ArrayBuffer>;
    /**    Retrieves the metadata about all script logs stored for an app.
  Returns an array of ScriptLogMeta objects.
  
    */
    getReloadsLogs(): Promise<ScriptLogList>;
    /**    Deletes a specific version of the script for an app.
  Fails if the version to delete is the current version.
  
      @param version - Identifier of the script version
    */
    deleteScript(version: string): Promise<void>;
    /**    Retrieves a version of the script for an app.
  Returns the script text.
  
      @param version - Identifier of the script version, or 'current' for retrieving the current version.
    */
    getScriptByVersion(version: string): Promise<ScriptVersion>;
    /**    Updates a specific version of the script for an app.
  
      @param version - Identifier of the script version.
      @param data - Array of patches for the object ScriptVersion.
  Only /versionMessage can be modified using operations add, remove and replace.
    */
    patchScript(version: string, data: NxPatch): Promise<void>;
    /**    Retrieves the script history for an app.
  Returns information about the saved versions of the script.
  
      @param filter - A scim filter expression defining which script versions should be retrieved. Filterable fields are:
  
  • ScriptId
  
  • ModifiedTime
  
  • ModifierId
      @param limit - Maximum number of records to return from this request.
      @param page - Opaque definition of which page of the result set to return. Returned from a previous call using the same filter. Not yet supported.
    */
    getScriptVersions(queryParams?: {
        filter?: string;
        limit?: string;
        page?: string;
    }): Promise<ScriptMetaList>;
    /**    Sets script for an app.
  
      @param data - The script to set.
    */
    createScript(data: ScriptVersion): Promise<void>;
    /**    Removes space from a specific app.
  
    */
    deleteSpace(): Promise<NxApp>;
    /**    Sets space on a specific app.
  
      @param data - New space.
    */
    setSpace(data: UpdateSpace): Promise<NxApp>;
    /**    Deletes a specific app.
  
    */
    delete(): Promise<void>;
    /**    Updates the information for a specific app.
  
      @param data - Attributes that user wants to set.
    */
    set(data: UpdateApp): Promise<NxApp>;
}
export type NxAppCreatePrivileges = {
    /** Is set to true if the user has privileges to create the resource. */
    canCreate?: boolean;
    /** Type of resource. For example, sheet, story, bookmark, etc. */
    resource?: string;
    [key: string]: any;
};
export type NxAppObject = {
    /** App object attributes. This structure can also contain extra user-defined attributes. */
    attributes?: NxObjectAttributes;
    /** Application object privileges.
  Hints to the client what actions the user is allowed to perform.
  Could be any of:
  
  • read
  
  • create
  
  • update
  
  • delete
  
  • publish
  
  • exportdata
  
  • change_owner */
    privileges?: Array<string>;
    [key: string]: any;
};
export type NxAttributes = {
    /** The date and time when the app was created. */
    createdDate?: string;
    /** Contains dynamic JSON data specified by the client. */
    custom?: JsonObject;
    /** App description. */
    description?: string;
    /** The dynamic color of the app. */
    dynamicColor?: string;
    /** If set to true, the app is encrypted. */
    encrypted?: boolean;
    /** If set to true, the app has section access configured, */
    hasSectionAccess?: boolean;
    /** The App ID. */
    id?: string;
    /** True if the app is a Direct Query app, false if not */
    isDirectQueryMode?: boolean;
    /** Date and time of the last reload of the app. */
    lastReloadTime?: string;
    /** The date and time when the app was modified. */
    modifiedDate?: string;
    /** App name. */
    name?: string;
    /** The Origin App ID for published apps. */
    originAppId?: string;
    /** Deprecated. Use user api to fetch user metadata. */
    owner?: string;
    /** Identifier of the app owner. */
    ownerId?: string;
    /** The date and time when the app was published, empty if unpublished. */
    publishTime?: string;
    /** True if the app is published on-prem, distributed in QCS, false if not. */
    published?: boolean;
    /** App thumbnail. */
    thumbnail?: string;
    [key: string]: any;
};
export type NxObjectAttributes = {
    /** True if the object is approved. */
    approved?: boolean;
    /** The date and time when the object was created. */
    createdAt?: string;
    /** Object description. */
    description?: string;
    /** The generic type of the object.
  
  One of:
  
  • genericObject
  
  • genericBookmark
  
  • genericMeasure
  
  • genericDimension
  
  • genericVariable */
    genericType?: 'genericObject' | 'genericBookmark' | 'genericMeasure' | 'genericDimension' | 'genericVariable' | string;
    /** The object Id. */
    id?: string;
    /** Object name. */
    name?: string;
    /** The type of the object. */
    objectType?: string;
    /** The object owner's Id. */
    ownerId?: string;
    /** The date and time when the object was published, empty if unpublished. */
    publishedAt?: string;
    /** The date and time when the object was modified. */
    updatedAt?: string;
    [key: string]: any;
};
export type NxPatch = {
    /** Operation to perform.
  
  One of:
  
  • add or Add
  
  • remove or Remove
  
  • replace or Replace */
    Op?: 'Add' | 'Remove' | 'Replace' | string;
    /** Path to the property to add, remove or replace. */
    Path?: string;
    /** This parameter is not used in a remove operation.
  Corresponds to the value of the property to add or to the new value of the property to update.
  Examples:
  "false", "2", "\"New title\"" */
    Value?: string;
    [key: string]: any;
};
export type Objectspec = {
    /** @example "fjETFn" */
    id?: string;
    /** @example 1 */
    objectType?: number;
    /** @example "41dbb01c-d1bd-4528-be05-910ee565988b" */
    sheetId?: string;
    /** @example "my chart" */
    title?: string;
    [key: string]: any;
};
export type PartialNluInfo = {
    /** Qlik sense application field selected for given token or phrase */
    fieldName?: string;
    /** Filter value found from query */
    fieldValue?: string;
    /** Role of the token or phrase from query */
    role?: 'dimension' | 'measure' | 'date' | string;
    /** Matching token or phrase from query */
    text?: string;
    /** Type of token from query */
    type?: 'field' | 'filter' | 'master_dimension' | 'master_measure' | 'custom_analysis' | string;
    [key: string]: any;
};
export type PublishApp = {
    attributes?: AppUpdateAttributes;
    /** The published app will have data from source or target app.
  The default is source.
  
  • source: Publish with source data
  
  • target: Publish with target data */
    data?: 'source' | 'target' | string;
    /** The original is moved instead of copied. The current published state of all objects is kept. */
    moveApp?: boolean;
    /** If app is moved, originAppId needs to be provided. */
    originAppId?: string;
    /** The managed space ID where the app will be published. */
    spaceId?: string;
    [key: string]: any;
};
export type RecommendedAnalysis = {
    analysis?: AnalysisDetails;
    /** Chart type given to current recommendation */
    chartType?: 'barchart' | 'combochart' | 'distributionplot' | 'kpi' | 'linechart' | 'map' | 'scatterplot' | 'table' | string;
    /** (chart options + hypercube definition) */
    options?: object;
    /** percentage of selected items in the analysis to the overall items passed to the endpoint */
    relevance?: number;
    /** part analyses (only for macro analyses) */
    parts?: Array<RecommendedAnalysisCore>;
    [key: string]: any;
};
export type RecommendedAnalysisCore = {
    analysis?: AnalysisDetails;
    /** Chart type given to current recommendation */
    chartType?: 'barchart' | 'combochart' | 'distributionplot' | 'kpi' | 'linechart' | 'map' | 'scatterplot' | 'table' | string;
    /** (chart options + hypercube definition) */
    options?: object;
    /** percentage of selected items in the analysis to the overall items passed to the endpoint */
    relevance?: number;
    [key: string]: any;
};
export type RepublishApp = {
    attributes?: AppUpdateAttributes;
    /** Validate that source app is same as originally published.
  @defaultValue true */
    checkOriginAppId?: boolean;
    /** The republished app will have data from source or target app.
  The default is source.
  
  • source: Publish with source data
  
  • target: Publish with target data */
    data?: 'source' | 'target' | string;
    /** The target ID to be republished. */
    targetId?: string;
    [key: string]: any;
};
export type Result = {
    /** @example 12.3 */
    documentSizeMiB?: number;
    hasSectionAccess?: boolean;
    objNoCache?: Array<Resultobjresponsetime>;
    objSingleThreaded?: Array<Resultsingle>;
    objSlowCached?: Array<Resultobjsinglethreaded>;
    objSlowUncached?: Array<Resultobjresponsetime>;
    /** @example 33 */
    objectCount?: number;
    /** @example 20000 */
    rowCount?: number;
    /** @example 5 */
    sheetCount?: number;
    sheets?: Array<Resultobjsheet>;
    topFieldsByBytes?: Array<Resultmetadatatopfields>;
    topTablesByBytes?: Array<Resultmetadatatoptables>;
    [key: string]: any;
};
export type Resultmetadatatopfields = {
    /** @example 1234 */
    byte_size?: number;
    is_system?: boolean;
    /** @example "a" */
    name?: string;
    [key: string]: any;
};
export type Resultmetadatatoptables = {
    /** @example 1234 */
    byte_size?: number;
    is_system?: boolean;
    /** @example "a" */
    name?: string;
    [key: string]: any;
};
export type Resultobjresponsetime = {
    /** @example "fjETFn" */
    id?: string;
    /** @example 1 */
    objectType?: number;
    /** @example "41dbb01c-d1bd-4528-be05-910ee565988b" */
    sheetId?: string;
    /** @example "my chart" */
    title?: string;
    /** @example 12.3 */
    responseTimeSeconds?: number;
    [key: string]: any;
};
export type Resultobjsheet = {
    /** @example 1 */
    objectCount?: number;
    sheet?: Resultobjresponsetime;
    sheetObjects?: Array<Resultobjresponsetime>;
    [key: string]: any;
};
export type Resultobjsinglethreaded = {
    /** @example "fjETFn" */
    id?: string;
    /** @example 1 */
    objectType?: number;
    /** @example "41dbb01c-d1bd-4528-be05-910ee565988b" */
    sheetId?: string;
    /** @example "my chart" */
    title?: string;
    cpuQuotients?: Array<number>;
    /** @example 12.3 */
    responseTimeSeconds?: number;
    schema?: Objectspec;
    [key: string]: any;
};
export type Resultsingle = {
    /** @example "fjETFn" */
    id?: string;
    /** @example 1 */
    objectType?: number;
    /** @example "41dbb01c-d1bd-4528-be05-910ee565988b" */
    sheetId?: string;
    /** @example "my chart" */
    title?: string;
    /** @example 12.3 */
    cpuQuotient1?: number;
    [key: string]: any;
};
export type ScriptLogList = {
    /** Array of scriptLogMeta. */
    data?: Array<ScriptLogMeta>;
    [key: string]: any;
};
export type ScriptLogMeta = {
    /** Duration of reload (ms). */
    duration?: number;
    /** Time when reload ended. */
    endTime?: string;
    links?: Log;
    /** Reload identifier. */
    reloadId?: string;
    /** True if the reload was successful. */
    success?: boolean;
    [key: string]: any;
};
export type ScriptMeta = {
    /** Script version last modification time. */
    modifiedTime?: string;
    /** User last modifying script version. */
    modifierId?: string;
    /** Script id. */
    scriptId?: string;
    /** Script size. */
    size?: number;
    /** Description of this script version */
    versionMessage?: string;
    [key: string]: any;
};
export type ScriptMetaList = {
    links?: NavigationLinks;
    /** Script versions metadata. */
    scripts?: Array<ScriptMeta>;
    [key: string]: any;
};
export type ScriptVersion = {
    /** Script text. */
    script?: string;
    /** Description of this script version */
    versionMessage?: string;
    [key: string]: any;
};
export type Sortedcomparisonfields = {
    absoluteDiffAsc?: Array<any>;
    absoluteDiffDesc?: Array<any>;
    /** @example "full" */
    dataSourceStatus?: 'full' | 'none' | 'baselinemissing' | 'comparisonmissing' | string;
    list?: Array<any>;
    relativeDiffAsc?: Array<any>;
    relativeDiffDesc?: Array<any>;
    [key: string]: any;
};
export type Sortedcomparisonobjresponsetime = {
    absoluteDiffAsc?: Array<any>;
    absoluteDiffDesc?: Array<any>;
    /** @example "full" */
    dataSourceStatus?: 'full' | 'none' | 'baselinemissing' | 'comparisonmissing' | string;
    list?: Array<any>;
    relativeDiffAsc?: Array<any>;
    relativeDiffDesc?: Array<any>;
    [key: string]: any;
};
export type Sortedcomparisonoobjheavy = {
    absoluteDiffAsc?: Array<any>;
    absoluteDiffDesc?: Array<any>;
    /** @example "full" */
    dataSourceStatus?: 'full' | 'none' | 'baselinemissing' | 'comparisonmissing' | string;
    list?: Array<any>;
    relativeDiffAsc?: Array<any>;
    relativeDiffDesc?: Array<any>;
    [key: string]: any;
};
export type Sortedcomparisontables = {
    absoluteDiffAsc?: Array<any>;
    absoluteDiffDesc?: Array<any>;
    /** @example "full" */
    dataSourceStatus?: 'full' | 'none' | 'baselinemissing' | 'comparisonmissing' | string;
    list?: Array<any>;
    relativeDiffAsc?: Array<any>;
    relativeDiffDesc?: Array<any>;
    [key: string]: any;
};
export type SymbolFrequency = {
    /** Frequency of the above symbol in the field */
    Frequency?: number;
    Symbol?: SymbolValue;
    [key: string]: any;
};
export type SymbolValue = {
    /** Numeric value of the symbol. NaN otherwise. */
    Number?: number;
    /** String value of the symbol. This parameter is optional and present only if Symbol is a string. */
    Text?: string;
    [key: string]: any;
};
export type TableMetadata = {
    /** Static RAM memory used in bytes. */
    byte_size?: number;
    /** Table comment. */
    comment?: string;
    /** If set to true, the table is loose due to circular connection.
  The default value is false. */
    is_loose?: boolean;
    /** If set to true, the table is semantic.
  The default value is false. */
    is_semantic?: boolean;
    /** If set to true, the table is a system table.
  The default value is false. */
    is_system?: boolean;
    /** Name of the table. */
    name?: string;
    /** Number of fields. */
    no_of_fields?: number;
    /** Number of key fields. */
    no_of_key_fields?: number;
    /** Number of rows. */
    no_of_rows?: number;
    [key: string]: any;
};
export type TableProfilingData = {
    /** Field values profiling info */
    FieldProfiling?: Array<FieldInTableProfilingData>;
    /** Number of rows in the table. */
    NoOfRows?: number;
    [key: string]: any;
};
export type UpdateApp = {
    attributes?: AppUpdateAttributes;
    [key: string]: any;
};
export type UpdateOwner = {
    ownerId?: string;
    [key: string]: any;
};
export type UpdateSpace = {
    spaceId?: string;
    [key: string]: any;
};
export declare class Apps {
    auth: Auth;
    config: Config;
    constructor(config: Config | Auth);
    /**    Accepts two evaluation ids and downloads a log, in XML format, denoting the differences between the two.
  
    Download a comparison log of two evaluations
  
      @param baseid - Id of the baseline evaluation
      @param comparisonid - Id of the comparison evaluation
    */
    downloadAppsEvaluationsCompare(baseid: string, comparisonid: string): Promise<Comparison>;
    /**    Accepts two evaluation ids and returns a comparison denoting the differences between the two.
  
    Compare two evaluations
  
      @param baseid - Id of the baseline evaluation
      @param comparisonid - Id of the comparison evaluation
      @param all - Get the full list of comparisons including non-significant diffs
      @param format - Specify output format, currently supported are 'json' and 'xml'
    */
    compareAppsEvaluations(baseid: string, comparisonid: string, queryParams?: {
        all?: boolean;
        format?: string;
    }): Promise<Comparison>;
    /**    Find an evaluation by a specific id.
  
    Retrieve a specific evaluation
  
      @param id - Id of the desired evaluation.
      @param all - Get the full data of the evaluation
      @param format - Specify output format, currently supported are 'json' and 'xml'
    */
    getEvaluation(id: string, queryParams?: {
        all?: boolean;
        format?: string;
    }): Promise<Evaluation>;
    /**    Imports an app into the system.
  
      @param appId - The app ID of the target app when source is qvw file.
      @param fallbackName - The name of the target app when source does not have a specified name, applicable if source is qvw file.
      @param fileId - The file ID to be downloaded from Temporary Content Service (TCS) and used during import.
      @param mode - The import mode. In `new` mode (default), the source app will be imported as a new app.The `autoreplace` mode is an internal mode only and is not permitted for external use.
  
  One of:
  
  • NEW
  
  • AUTOREPLACE
      @param name - The name of the target app.
      @param NoData - If NoData is true, the data of the existing app will be kept as is, otherwise it will be replaced by the new incoming data.
      @param spaceId - The space ID of the target app.
      @param data - Path of the source app.
    */
    importApp(data: FileData, queryParams?: {
        appId?: string;
        fallbackName?: string;
        fileId?: string;
        mode?: string;
        name?: string;
        NoData?: boolean;
        spaceId?: string;
    }): Promise<NxApp>;
    /**    Gets the app privileges for the current user, such as create app and import app. Empty means that the current user has no app privileges.
  
    */
    getPrivileges(): Promise<Array<string>>;
    /**    Retrieves information for a specific app.
  
      @param appId - Identifier of the app.
    */
    get(appId: string): Promise<NxApp>;
    /**    Find all evaluations for an app GUID.
  Supports paging via next, prev which are sent in the response body
  
    Retrieve a list of all historic evaluations for an app GUID
  
      @param guid - The app guid.
      @param all - Get the full data of the evaluation
      @param fileMode - Add file transfer headers to response
      @param format - Specify output format, currently supported are 'json' and 'xml'
      @param limit - Number of results to return per page.
      @param next - The app evaluation id to get next page from
      @param prev - The app evaluation id to get previous page from
      @param sort - Property to sort list on
    */
    getEvaluations(guid: string, queryParams?: {
        all?: boolean;
        fileMode?: boolean;
        format?: string;
        limit?: number;
        next?: string;
        prev?: string;
        sort?: string;
    }): Promise<ListableResource<Evaluation>>;
    /**    Queue an app evaluation by its app guid.
  
    Queue an app evaluation
  
      @param guid - Guid of the app.
    */
    createEvaluation(guid: string): Promise<Evaluation>;
    /**    Creates a new app.
  
      @param data - Attributes that the user wants to set in new app.
    */
    create(data: CreateApp): Promise<NxApp>;
    /** Creates an empty session app
   * @param sessionAppId - a self generated 'app_id' prefixed with SessionApp_
   *
   * @example
   * ```js
   * const randomId = Math.random().toString(32).substring(3);
   * const appId = `SessionApp_${randomId}`;
   * const app = qlik.apps.createSessionApp(appId);
   * await app.open();
   * const script = `
   *   TempTable:
   *   Load
   *   RecNo() as Field1,
   *   Rand() as Field2,
   *   Rand() as Field3
   *   AutoGenerate 100
   *   `;
   * await app.setScript(script);
   * await app.doReload();
   * ```
   */
    createSessionApp(sessionAppId: string): NxApp;
}

/**
This is spectacularly generated code by spectacular based on
Qlik Cloud Services APIs
*/
import Auth from '../auth/auth.js';
import ListableResource from '../listable.js';
import type { Config } from '../types/types.js';
export type Delivery = {
    /** The name of the triggering event-type */
    eventType: string;
    /** The delivery's unique identifier */
    id: string;
    request?: {
        body?: object;
        headers?: object;
        url?: string;
    };
    response?: {
        body?: string;
        headers?: object;
        statusCode?: number;
    };
    /** The status of delivery */
    status: 'success' | 'fail' | string;
    /** The status message of the delivery */
    statusMessage?: string;
    /** The UTC timestamp when the delivery was triggered */
    triggeredAt: string;
    /** The unique webhook identifier that the delivery is for */
    webhookId: string;
    [key: string]: any;
};
export type EventType = {
    /** Description of the event type */
    description?: string;
    /** Specifies which levels that are supported for this event type */
    levels?: Array<string>;
    /** Name of the event type */
    name?: string;
    /** Title of the event type */
    title?: string;
    [key: string]: any;
};
export type EventTypes = {
    data?: Array<EventType>;
    [key: string]: any;
};
/**
  @param createdAt - The UTC timestamp when the webhook was created
  @param createdByUserId - The id of the user that created the webhook
  @param description - The reason for creating the webhook
  @param disabledReason - The reason for the webhook to be disabled
  @param disabledReasonCode - The unique code for the reason
  @param enabled - Whether the webhook is active and sending requests
  @param eventTypes - Types of events for which the webhook should trigger.
  @param filter - Filter that should match for a webhook to be triggered.
Supported common attribute names are 'id', 'spaceId' and 'topLevelResourceId', beside the common attributes the "com.qlik.v1.app.reload.finished" event also supports "data.status" that could be either "ok" or "error" but can't be used together with other event types.
Supported attribute operators are 'eq' and 'ne'.
Supported logical operators are 'and' and 'or'.
Note that attribute values must be valid JSON strings, hence they're enclosed with double quotes
For more detailed information regarding the SCIM filter syntax (RFC7644) used please follow the link to external documentation.
  @param headers - Additional headers in the post request
  @param id - The webhook's unique identifier
  @param level - Defines at what level the webhook should operate: for all resources belonging to a tenant or restricted to only those accessible by the webhook-creator.
  @param name - The name for the webhook
  @param ownerId - The id of the user that owns the webhook, only applicable for user level webhooks
  @param secret - String used as secret for calculating HMAC hash sent as header
  @param updatedAt - The UTC timestamp when the webhook was last updated
  @param updatedByUserId - The id of the user that last updated the webhook
  @param url - Target URL for webhook HTTPS requests
  @param auth - Auth object used to make requests
 */
export declare class Webhook {
    auth: Auth;
    createdAt?: string;
    createdByUserId?: string;
    description?: string;
    disabledReason?: string;
    disabledReasonCode?: string;
    enabled?: boolean;
    eventTypes?: Array<string>;
    filter?: string;
    headers?: object;
    id?: string;
    level?: 'tenant' | 'user' | string;
    name: string;
    ownerId?: string;
    secret?: string;
    updatedAt?: string;
    updatedByUserId?: string;
    url: string;
    [key: string]: any;
    constructor({ createdAt, createdByUserId, description, disabledReason, disabledReasonCode, enabled, eventTypes, filter, headers, id, level, name, ownerId, secret, updatedAt, updatedByUserId, url, ...rest }: {
        createdAt?: string;
        createdByUserId?: string;
        description?: string;
        disabledReason?: string;
        disabledReasonCode?: string;
        enabled?: boolean;
        eventTypes?: Array<string>;
        filter?: string;
        headers?: object;
        id?: string;
        level?: 'tenant' | 'user' | string;
        name: string;
        ownerId?: string;
        secret?: string;
        updatedAt?: string;
        updatedByUserId?: string;
        url: string;
    }, auth?: Auth);
    /**
    Resend the delivery with the same payload
  
      @param deliveryId - The delivery's unique identifier.
    */
    resend(deliveryId: string): Promise<Delivery>;
    /**
    Returns details for a specific delivery
  
      @param deliveryId - The delivery's unique identifier.
    */
    getDeliverie(deliveryId: string): Promise<Delivery>;
    /**
    Returns deliveries for a specific webhook
  
      @param eventType - Filter resources by event-type
      @param limit - Maximum number of deliveries to retrieve
      @param next - Cursor to the next page
      @param prev - Cursor to previous next page
      @param sort - Field to sort by, prefix with -/+ to indicate order
      @param status - Filter resources by status (success or fail)
    */
    getDeliveries(queryParams?: {
        eventType?: string;
        limit?: number;
        next?: string;
        prev?: string;
        sort?: 'status' | '+status' | '-status' | 'triggeredAt' | '+triggeredAt' | '-triggeredAt';
        status?: 'success' | 'fail';
    }): Promise<ListableResource<Delivery>>;
    /**
    Deletes a specific webhook
  
    */
    delete(): Promise<void>;
    /**
    Patches a webhook
  
      @param WebhookPatchData -
    */
    patch(WebhookPatchData: Array<WebhookPatch>): Promise<void>;
    /**
    Updates a webhook
  
      @param data -
    */
    set(data: WebhookDef): Promise<Webhook>;
}
export type WebhookDef = {
    /** The reason for creating the webhook */
    description?: string;
    /** Whether the webhook is active and sending requests */
    enabled?: boolean;
    /** Types of events for which the webhook should trigger. */
    eventTypes?: Array<string>;
    /** Filter that should match for a webhook to be triggered.
  Supported common attribute names are 'id', 'spaceId' and 'topLevelResourceId', beside the common attributes the "com.qlik.v1.app.reload.finished" event also supports "data.status" that could be either "ok" or "error" but can't be used together with other event types.
  Supported attribute operators are 'eq' and 'ne'.
  Supported logical operators are 'and' and 'or'.
  Note that attribute values must be valid JSON strings, hence they're enclosed with double quotes
  For more detailed information regarding the SCIM filter syntax (RFC7644) used please follow the link to external documentation.
  @example "id eq \"id123\" or spaceId eq \"spaceId123\" or spaceId eq \"spaceId456\" or topLevelResourceId eq \"id789\"" */
    filter?: string;
    /** Additional headers in the post request
  @example {"headerName":"headerValue"} */
    headers?: object;
    /** Defines at what level the webhook should operate: for all resources belonging to a tenant or restricted to only those accessible by the webhook-creator.
  @defaultValue "tenant" */
    level?: 'tenant' | 'user' | string;
    /** The name for the webhook */
    name: string;
    /** The id of the user that owns the webhook, only applicable for user level webhooks */
    ownerId?: string;
    /** String used as secret for calculating HMAC hash sent as header */
    secret?: string;
    /** Target URL for webhook HTTPS requests */
    url: string;
    [key: string]: any;
};
export type WebhookPatch = {
    /** The operation to be performed */
    op: 'add' | 'remove' | 'replace' | string;
    /** The path for the given resource field to patch
  @example "/description" */
    path: '/name' | '/description' | '/url' | '/eventTypes' | '/headers' | '/enabled' | '/secret' | string;
    /** The value to be used for this operation. */
    value?: boolean | number | object | string;
    [key: string]: any;
};
export declare class Webhooks {
    auth: Auth;
    config: Config;
    constructor(config: Config | Auth);
    /**
    List of event-types that are possible to subscribe to.
  
    */
    getEventTypes(): Promise<EventTypes>;
    /**
    Returns details for a specific webhook
  
      @param id - The webhook's unique identifier.
    */
    get(id: string): Promise<Webhook>;
    /**
    Retrieves all webhooks entries for a tenant
  
      @param createdByUserId - Filter resources by user that created it
      @param enabled - Filter resources by enabled true/false
      @param eventType - Filter resources by event-type
      @param level - Filter resources by level that user has access to (either user or level)
      @param limit - Maximum number of webhooks to retrieve
      @param name - Filter resources by name (wildcard and case insensitive)
      @param next - Cursor to the next page
      @param ownerId - Filter resources by user that owns it, only applicable for user level webhooks
      @param prev - Cursor to previous next page
      @param sort - Field to sort by, prefix with -/+ to indicate order
      @param updatedByUserId - Filter resources by user that last updated the webhook
      @param url - Filter resources by url (wildcard and case insensitive)
    */
    getWebhooks(queryParams?: {
        createdByUserId?: string;
        enabled?: boolean;
        eventType?: string;
        level?: string;
        limit?: number;
        name?: string;
        next?: string;
        ownerId?: string;
        prev?: string;
        sort?: 'name' | '+name' | '-name' | 'url' | '+url' | '-url' | 'createdAt' | '+createdAt' | '-createdAt' | 'updatedAt' | '+updatedAt' | '-updatedAt';
        updatedByUserId?: string;
        url?: string;
    }): Promise<ListableResource<Webhook>>;
    /**
    Creates a new webhook
  
      @param data -
    */
    create(data: WebhookDef): Promise<Webhook>;
}
